import { CreateAffix } from 'src/Affixes/AffixCreate'
import { AffixFactory } from 'src/Affixes/AffixFactory'
import { AddAffix, AffixUtil, RemoveAllWolfAffixes } from 'src/Affixes/AffixUtil'
import { Constants } from 'src/AutoGenerated/Constants'
import { Gameover } from 'src/Events/Gameover'
import { PlayerLeaves } from 'src/Events/PlayerLeavesEvent/PlayerLeaves'
import { APMTracker } from 'src/Events/UnitOrders/APMTracker'
import { VoteEndRound } from 'src/Events/VotingEvents/VoteEndRound'
import { Votekick } from 'src/Events/VotingEvents/Votekick'
import { Circle } from 'src/Game/Entities/Circle'
import { Kitty } from 'src/Game/Entities/Kitty/Kitty'
import { Wolf } from 'src/Game/Entities/Wolf'
import { ItemSpawner } from 'src/Game/Items/ItemSpawner'
import { Kibble } from 'src/Game/Items/Kibble'
import { GameTimer } from 'src/Game/Rounds/GameTimer'
import { RoundManager } from 'src/Game/Rounds/RoundManager'
import { RoundTimer } from 'src/Game/Rounds/RoundTimer'
import { WolfArea } from 'src/Game/WolfArea'
import { WolfLaneHider } from 'src/Game/WolfLaneHider/WolfLaneHider'
import { Gamemode } from 'src/Gamemodes/Gamemode'
import { TeamHandler } from 'src/Gamemodes/Teams/TeamHandler'
import { Globals } from 'src/Global/Globals'
import { RegionList } from 'src/Global/RegionList'
import { BarrierSetup } from 'src/Init/BarrierSetup'
import { Difficulty } from 'src/Init/Difficulty/Difficulty'
import { AIController } from 'src/Misc/AIController'
import { Disco } from 'src/Misc/Disco'
import { FirstPersonCameraManager } from 'src/Misc/FirstPersonCameraManager'
import { ChainedTogether } from 'src/Rewards/Challenges/ChainedTogether'
import { NitroChallenges } from 'src/Rewards/Challenges/NitroChallenges'
import { Savecode } from 'src/Rewards/OldSaves/OldSaves'
import { DateTimeManager } from 'src/Seasonal/DateTimeManager'
import { SeasonalManager } from 'src/Seasonal/SeasonalManager'
import { TerrainChanger } from 'src/Seasonal/Terrain/TerrainChanger'
import { CustomStatFrame } from 'src/UI/CustomStatFrame'
import { FloatingNameTag } from 'src/UI/FloatingNames'
import { FrameManager } from 'src/UI/Frames/FrameManager'
import { MusicFrame } from 'src/UI/Frames/MusicFrame'
import { RewardsFrame } from 'src/UI/Frames/RewardsFrame'
import { ShopFrame } from 'src/UI/Frames/ShopFrame'
import { MultiboardUtil } from 'src/UI/Multiboard/MultiboardUtil'
import { safeArraySplice } from 'src/Utility/ArrayUtils'
import { CameraUtil } from 'src/Utility/CameraUtil'
import { Colors } from 'src/Utility/Colors/Colors'
import { ColorUtils } from 'src/Utility/Colors/ColorUtils'
import { MemoryHandler } from 'src/Utility/MemoryHandler/MemoryHandler'
import { isNullOrEmpty } from 'src/Utility/StringUtils'
import { Utility } from 'src/Utility/Utility'
import { Effect, MapPlayer, Timer } from 'w3ts'
import { ErrorMessagesOn } from '../../../Utility/ErrorMessagesOn'
import { AwardingCmds } from '../AwardingCmds'
import { ExecuteLua } from '../ExecuteLua'
import { CommandsManager } from './CommandsManager'

export class InitCommands {
    public static InitializeCommands = () => {
        const memState: { timer: Timer | undefined } = { timer: undefined }

        CommandsManager.RegisterCommand({
            name: 'help',
            alias: 'commands,?',
            group: 'all',
            argDesc: '',
            description: 'Displays all available commands.',
            action: (player, args) => {
                CommandsManager.HelpCommands(player, args[0] || '')
            },
        })

        CommandsManager.RegisterCommand({
            name: 'memtest',
            alias: '',
            group: 'admin',
            argDesc: '[on][off]',
            description: 'Memory Handler Periodic Message',
            action: (player, args) => {},
        })

        CommandsManager.RegisterCommand({
            name: 'save',
            alias: '',
            group: 'all',
            argDesc: '',
            description: 'Save your current game stats.',
            action: (player, args) => Globals.SaveSystem.Save(player),
        })

        CommandsManager.RegisterCommand({
            name: 'wolfeffects',
            alias: 'we,wolfe',
            group: 'admin',
            argDesc: '[true][false]',
            description: 'Disables the wolves overhead effects!',
            action: (player, args) => (Wolf.DisableEffects = CommandsManager.GetBool(args[0])),
        })

        CommandsManager.RegisterCommand({
            name: 'clear',
            alias: 'clear,clr,c',
            group: 'all',
            argDesc: '',
            description: 'Clears your screen.',
            action: (player, args) => Utility.ClearScreen(player),
        })

        CommandsManager.RegisterCommand({
            name: 'gold',
            alias: 'g',
            group: 'admin',
            argDesc: 'amount',
            description: 'Gives gold to the resolvePlayerID',
            action: (player, args) => {
                if (args[0] === '') {
                    player.DisplayTimedTextTo(
                        5.0,
                        `${Colors.COLOR_YELLOW_ORANGE}Invalid arguments. Usage: gold [amount] [resolvePlayerId]|r`
                    )
                    return
                }

                const amount = S2I(args[0])

                if (args.length < 2) {
                    player.addGold(amount)
                    return
                }

                CommandsManager.ResolvePlayerId(args[1], kitty => {
                    kitty.Player.addGold(amount)
                })
            },
        })

        CommandsManager.RegisterCommand({
            name: 'colors',
            alias: '',
            group: 'all',
            argDesc: '',
            description: 'Display all available colors.',
            action: (player, args) => ColorUtils.ListColorCommands(player),
        })

        CommandsManager.RegisterCommand({
            name: 'color',
            alias: '',
            group: 'all',
            argDesc: '[color]',
            description: 'Set your MapPlayer color.',
            action: (player, args) => ColorUtils.SetPlayerColor(player, args?.[0]),
        })

        CommandsManager.RegisterCommand({
            name: 'kick',
            alias: 'k',
            group: 'all',
            argDesc: '[playerNumber]',
            description: 'Initiate a votekick against a MapPlayer.',
            action: (player, args) => {
                if (Globals.VIPLISTUNFILTERED.includes(player)) {
                    CommandsManager.ResolvePlayerId(args[0], kitty => {
                        if (Globals.VIPLISTUNFILTERED.includes(kitty.Player)) return
                        PlayerLeaves.PlayerLeavesActions(kitty.Player)
                        CustomDefeatBJ(
                            kitty.Player.handle,
                            `${Colors.COLOR_RED}You have been kicked from the game!${Colors.COLOR_RESET}`
                        )
                    })
                } else Votekick.InitiateVotekick(player, args?.[0])
            },
        })

        CommandsManager.RegisterCommand({
            name: 'voteend',
            alias: 've',
            group: 'all',
            argDesc: '',
            description: 'Initiate a vote to end the round (Solo Tournament Only).',
            action: (player, args) => VoteEndRound.InitiateVote(player),
        })

        CommandsManager.RegisterCommand({
            name: 'yes',
            alias: 'y',
            group: 'all',
            argDesc: '',
            description: 'Vote yes for the current vote.',
            action: (player, args) => {
                Votekick.IncrementTally()
                VoteEndRound.IncrementVote(player)
            },
        })

        CommandsManager.RegisterCommand({
            name: 'affixinfo',
            alias: 'ainfo',
            group: 'all',
            argDesc: '[lane #] (1-17)',
            description: 'Displays current round affixes.',
            action: (player, args) => {
                let affixes: string[]
                let laneIndex: number
                if (args[0] !== '') {
                    laneIndex = S2I(args[0])
                    if (laneIndex <= 0 || laneIndex > 17) return
                    affixes = AffixFactory.CalculateAffixes(laneIndex - 1)
                } else {
                    affixes = AffixFactory.CalculateAffixes()
                }
                player.DisplayTextTo(
                    Colors.COLOR_GOLD +
                        'Current Affixes:\n' +
                        affixes.join('\n') +
                        `\n${Colors.COLOR_LAVENDER}All Lanes Count: ${Globals.AllAffixes.length}`
                )
            },
        })

        CommandsManager.RegisterCommand({
            name: 'wolfinfo',
            alias: 'lnbm',
            group: 'all',
            argDesc: '[lane #] (1-17)',
            description: 'Displays the current wolf count.',
            action: (player, args) => {
                let laneIndex: number
                let nbWolves: number
                if (args[0] !== '') {
                    laneIndex = S2I(args[0])
                    if (laneIndex <= 0 || laneIndex > 17) return
                    nbWolves = WolfArea.WolfAreas.get(laneIndex - 1)!.Wolves.length
                    player.DisplayTextTo(
                        Colors.COLOR_GOLD +
                            `Current Wolf Count for Lane ${Colors.COLOR_YELLOW}${laneIndex}: ${nbWolves}${Colors.COLOR_RESET}`
                    )
                    return
                } else nbWolves = Globals.ALL_WOLVES.size
                player.DisplayTextTo(
                    Colors.COLOR_GOLD + `Current Wolf Count: ${Colors.COLOR_YELLOW}${nbWolves}${Colors.COLOR_RESET}`
                )
            },
        })

        CommandsManager.RegisterCommand({
            name: 'setcolor',
            alias: 'sc,vc',
            group: 'all',
            argDesc: '[rgb]',
            description: 'Set your player vertex color.',
            action: (player, args) => ColorUtils.SetPlayerVertexColor(player, args),
        })

        CommandsManager.RegisterCommand({
            name: 'wild',
            alias: '',
            group: 'all',
            argDesc: '',
            description: 'Set a random vertex color.',
            action: (player, args) => ColorUtils.SetPlayerRandomVertexColor(player),
        })

        CommandsManager.RegisterCommand({
            name: 'names',
            alias: 'n',
            group: 'all',
            argDesc: '',
            description: 'Hide all floating name tags.',
            action: (player, args) => FloatingNameTag.ShowAllNameTags(player, CommandsManager.GetBool(args[0])),
        })

        CommandsManager.RegisterCommand({
            name: 'zoom',
            alias: 'cam',
            group: 'all',
            argDesc: '[xxxx]',
            description: 'Adjust the camera zoom level.',
            action: (player, args) => CameraUtil.HandleZoomCommand(player, args),
        })

        CommandsManager.RegisterCommand({
            name: 'lockcamera',
            alias: 'lc,spectate',
            group: 'all',
            argDesc: '',
            description: 'Locks your camera to a unit.',
            action: (player, args) => {
                if (args[0] === '') {
                    CameraUtil.LockCamera(player)
                    return
                }
            },
        })

        CommandsManager.RegisterCommand({
            name: 'firstperson',
            alias: 'fpc,firstpersoncamera',
            group: 'all',
            argDesc: '',
            description: 'Toggle first person camera.',
            action: (player, args) => FirstPersonCameraManager.ToggleFirstPerson(player),
        })

        CommandsManager.RegisterCommand({
            name: 'reset',
            alias: '',
            group: 'all',
            argDesc: '',
            description: 'Resets your camera to default.',
            action: (player, args) => {
                CameraUtil.UnlockCamera(player)
                FrameManager.InitalizeButtons()
            },
        })

        CommandsManager.RegisterCommand({
            name: 'kc',
            alias: '',
            group: 'all',
            argDesc: '',
            description: 'Kicks yourself from the game.',
            action: (player, args) => {
                PlayerLeaves.PlayerLeavesActions(player)
                CustomDefeatBJ(player.handle, `${Colors.COLOR_RED}You kicked yourself!${Colors.COLOR_RESET}`)
            },
        })

        CommandsManager.RegisterCommand({
            name: 'oldcode',
            alias: '',
            group: 'all',
            argDesc: '',
            description: 'Loads a previous save from RKR 4.2.0+.',
            action: (player, args) => Savecode.LoadString(),
        })

        CommandsManager.RegisterCommand({
            name: 'apm',
            alias: '',
            group: 'all',
            argDesc: '',
            description: 'Displays your APM for ACTIVE game time (not counting intermissions).',
            action: (player, args) => player.DisplayTimedTextTo(10.0, APMTracker.CalculateAllAPM()),
        })

        CommandsManager.RegisterCommand({
            name: 'kibble',
            alias: '',
            group: 'all',
            argDesc: '',
            description: 'Displays the kibble collected by each player.',
            action: (player, args) => {
                let kibbleList = ''
                for (let i = 0; i < Globals.ALL_KITTIES_LIST.length; i++) {
                    const kitty = Globals.ALL_KITTIES_LIST[i]
                    const kibbleCollected = kitty.CurrentStats.CollectedKibble
                    kibbleList += `${ColorUtils.PlayerNameColored(kitty.Player)}: ${kibbleCollected}\n`
                }
                player.DisplayTimedTextTo(
                    7.0,
                    `${Colors.COLOR_GOLD}Kibble Collected:\n${kibbleList}${Colors.COLOR_RESET}`
                )
            },
        })

        CommandsManager.RegisterCommand({
            name: 'watcher',
            alias: 'watching',
            group: 'all',
            argDesc: '',
            description: 'Removes all units from game and you become an observer/spectator.',
            action: (player, args) => InitCommands.MakePlayerSpectator(player),
        })

        CommandsManager.RegisterCommand({
            name: 'overheadcam',
            alias: 'overhead,topdown,ohc',
            group: 'all',
            argDesc: '',
            description: 'Gives an overhead view.',
            action: (player, args) => CameraUtil.OverheadCamera(player, 280),
        })

        CommandsManager.RegisterCommand({
            name: 'komotocam',
            alias: '',
            group: 'all',
            argDesc: '',
            description: 'KomotoCam: Toggle.',
            action: (player, args) => CameraUtil.ToggleKomotoCam(player),
        })

        CommandsManager.RegisterCommand({
            name: 'glow',
            alias: '',
            group: 'all',
            argDesc: '[true/false]',
            description: 'Toggle unit glow.',
            action: (player, args) => {
                Globals.ALL_KITTIES.get(player)!.Unit.showTeamGlow(CommandsManager.GetBool(args[0]))
            },
        })

        CommandsManager.RegisterCommand({
            name: 'mirror',
            alias: 'reverse',
            group: 'all',
            argDesc: '',
            description: 'Toggle mirror mode.',
            action: (player, args) => {
                if (Globals.ALL_KITTIES.get(player)!.Slider.IsOnSlideTerrain()) {
                    player.DisplayTextTo(Colors.COLOR_YELLOW_ORANGE + "You can't toggle mirror mode while sliding!")
                    return
                }
                Globals.ALL_KITTIES.get(player)!.ToggleMirror()
                player.DisplayTextTo(
                    Colors.COLOR_GOLD + 'Mirror: ' + (Globals.ALL_KITTIES.get(player)!.IsMirror ? 'On' : 'Off')
                )
            },
        })

        CommandsManager.RegisterCommand({
            name: 'disco',
            alias: '',
            group: 'all',
            argDesc: '[on][off]',
            description: 'Toggle disco mode.',
            action: (player, args) => {
                if (args[0] === '') {
                    player.DisplayTimedTextTo(
                        5.0,
                        `${Colors.COLOR_YELLOW_ORANGE}Invalid arguments. Usage: disco [on/off]|r`
                    )
                    return
                }

                const status = CommandsManager.GetBool(args[0])
                if (CommandsManager.GetPlayerGroup(player) === 'admin' && args.length > 1) {
                    if (args[1] === 'wolves' || args[1] === 'wolf') {
                        for (const [_, wolf] of Globals.ALL_WOLVES) {
                            wolf.Disco ??= MemoryHandler.getEmptyClass(Disco, wolf.Unit)
                            wolf.Disco.ToggleDisco(status)
                            if (!status) {
                                wolf.Disco = null as never
                                wolf.Unit.setVertexColor(150, 120, 255, 255)
                            }
                        }
                    } else {
                        CommandsManager.ResolvePlayerId(args[1], kitty => {
                            kitty.Disco.ToggleDisco(status)
                        })
                    }
                } else {
                    const playerKitty = Globals.ALL_KITTIES.get(player)!
                    playerKitty.Disco.ToggleDisco(status)
                }

                player.DisplayTextTo(Colors.COLOR_GOLD + 'Disco: ' + (status ? 'On' : 'Off'))
            },
        })

        CommandsManager.RegisterCommand({
            name: 'animate',
            alias: 'animation,an',
            group: 'all',
            argDesc: '[index]',
            description: 'Set unit animation by index.',
            action: (player, args) =>
                SetUnitAnimationByIndex(Globals.ALL_KITTIES.get(player)!.Unit.handle, S2I(args[0])),
        })

        CommandsManager.RegisterCommand({
            name: 'spincam',
            alias: '',
            group: 'all',
            argDesc: '[speed]',
            description: 'SpinCam: Toggle.',
            action: (player, args) => {
                const speed: number = args[0] !== '' ? S2I(args[0]) : 0
                Globals.ALL_KITTIES.get(player)!.SpinCam.ToggleSpinCam(speed)
                player.DisplayTextTo(
                    Colors.COLOR_GOLD +
                        'SpinCam: ' +
                        (Globals.ALL_KITTIES.get(player)!.SpinCam.IsSpinCamActive() ? 'On' : 'Off')
                )
            },
        })

        CommandsManager.RegisterCommand({
            name: 'activatebarrier',
            alias: 'ab',
            group: 'admin',
            argDesc: '',
            description: 'Activates the barrier.',
            action: (player, args) => BarrierSetup.ActivateBarrier(),
        })

        CommandsManager.RegisterCommand({
            name: 'rtr',
            alias: '',
            group: 'all',
            argDesc: '[on/off] [player]',
            description: 'Set RTR mode on/off.',
            action: (player, args) => {
                if (args[0] === '') {
                    player.DisplayTimedTextTo(
                        5.0,
                        `${Colors.COLOR_YELLOW_ORANGE}Invalid arguments. Usage: rtr [on/off] [player]|r`
                    )
                    return
                }

                const mode: boolean = CommandsManager.GetBool(args[0])

                if (args.length < 2 || args[1] === '') {
                    // Apply to self
                    if (mode) {
                        Globals.ALL_KITTIES.get(player)!.RTR.StartRTR()
                        player.DisplayTextTo(Colors.COLOR_GOLD + 'RTR: On')
                    } else {
                        Globals.ALL_KITTIES.get(player)!.RTR.StopRTR()
                        player.DisplayTextTo(Colors.COLOR_GOLD + 'RTR: Off')
                    }
                    return
                }

                let isMatch: boolean = false

                CommandsManager.ResolvePlayerId(args[1], kitty => {
                    if (kitty === null) return
                    isMatch = true

                    if (mode) {
                        kitty.RTR.StartRTR()
                    } else {
                        kitty.RTR.StopRTR()
                    }
                })

                if (isMatch) {
                    player.DisplayTextTo(Colors.COLOR_GOLD + `RTR set to ${mode ? 'On' : 'Off'} for target player`)
                }
            },
        })

        CommandsManager.RegisterCommand({
            name: 'deactivatebarrier',
            alias: 'db',
            group: 'admin',
            argDesc: '',
            description: 'Deactivates the barrier.',
            action: (player, args) => BarrierSetup.DeactivateBarrier(),
        })

        CommandsManager.RegisterCommand({
            name: 'endround',
            alias: 'er',
            group: 'admin',
            argDesc: '',
            description: 'Ends the current round.',
            action: (player, args) => RoundManager.RoundEnd(),
        })

        CommandsManager.RegisterCommand({
            name: 'level',
            alias: 'lvl',
            group: 'admin',
            argDesc: '[level][player/selected]',
            description: 'Sets the level of the selected unit.',
            action: (player, args) => {
                if (args.length < 2) {
                    const kitty = Globals.ALL_KITTIES.get(player)!
                    kitty.Unit.setHeroLevel(S2I(args[0]), true)
                    return
                }
                CommandsManager.ResolvePlayerId(args[1], kitty => {
                    kitty.Unit.setHeroLevel(S2I(args[0]), true)
                })
            },
        })

        CommandsManager.RegisterCommand({
            name: 'blink',
            alias: 'tele',
            group: 'admin',
            argDesc: '',
            description: 'Adds a blink item to the kitty.',
            action: (player, args) => {
                const kitty = Globals.ALL_KITTIES.get(player)!
                kitty.Unit.addItemById(FourCC('desc'))
            },
        })

        CommandsManager.RegisterCommand({
            name: 'difficulty',
            alias: 'diff',
            group: 'admin',
            argDesc: '[difficulty]',
            description: 'Changes the game difficulty.',
            action: (player, args) => {
                const difficulty = args[0] !== '' ? args[0] : 'normal'
                Difficulty.ChangeDifficulty(difficulty)
                AffixFactory.DistAffixes()
                MultiboardUtil.RefreshMultiboards()
                NitroChallenges.SetNitroRoundTimes()
            },
        })

        CommandsManager.RegisterCommand({
            name: 'revive',
            alias: 'rpos',
            group: 'admin',
            argDesc: '',
            description: 'yourself: Revives.',
            action: (player, args) => {
                // if args is null or empty, revive self
                // else resolve playerid
                if (args[0] === '') {
                    Globals.ALL_KITTIES.get(player)!.ReviveKitty()
                    return
                }

                CommandsManager.ResolvePlayerId(args[0], kitty => kitty.ReviveKitty())
            },
        })

        CommandsManager.RegisterCommand({
            name: 'reviveto',
            alias: 'rto,rposto',
            group: 'admin',
            argDesc: '',
            description: 'Revives your hero to another hero with the same facing angle.',
            action: (player, args) => {
                if (args.length === 1) {
                    CommandsManager.ResolvePlayerId(args[0], kitty => {
                        Globals.ALL_KITTIES.get(player)!.ReviveKitty()
                        Globals.ALL_KITTIES.get(player)!.Unit.setPosition(kitty.Unit.x, kitty.Unit.y)
                        Globals.ALL_KITTIES.get(player)!.Unit.setFacingEx(kitty.Unit.facing)
                    })
                } else if (args.length === 2) {
                    CommandsManager.ResolvePlayerId(args[1], kitty => {
                        CommandsManager.ResolvePlayerId(args[0], kitty2 => {
                            kitty.ReviveKitty()
                            kitty.Unit.setPosition(kitty2.Unit.x, kitty2.Unit.y)
                            kitty.Unit.setFacingEx(kitty2.Unit.facing)
                        })
                    })
                }
            },
        })

        CommandsManager.RegisterCommand({
            name: 'summon',
            alias: 'smn',
            group: 'admin',
            argDesc: '',
            description: 'Revives another hero to yours with the same facing angle.',
            action: (player, args) => {
                CommandsManager.ResolvePlayerId(args[0], kitty => {
                    kitty.ReviveKitty()
                    kitty.Unit.setPosition(
                        Globals.ALL_KITTIES.get(player)!.Unit.x,
                        Globals.ALL_KITTIES.get(player)!.Unit.y
                    )
                    kitty.Unit.setFacingEx(Globals.ALL_KITTIES.get(player)!.Unit.facing)
                })
            },
        })

        CommandsManager.RegisterCommand({
            name: 'sharecontrol',
            alias: 'share',
            group: 'admin',
            argDesc: '[resolvePlayerId] [on/off]',
            description: 'Sets whether or not to force the player to share control [default: off]',
            action: (player, args) => {
                if (args.length < 2) {
                    player.DisplayTimedTextTo(
                        5.0,
                        `${Colors.COLOR_YELLOW_ORANGE}Invalid arguments. Usage: sharecontrol [player] [on/off]${Colors.COLOR_RESET}`
                    )
                    return
                }
                const status = CommandsManager.GetBool(args[1])
                CommandsManager.ResolvePlayerId(args[0], kitty => {
                    kitty.Player.setAlliance(player, ALLIANCE_SHARED_CONTROL, status)
                })
            },
        })

        CommandsManager.RegisterCommand({
            name: 'wolfshare',
            alias: 'wshare',
            group: 'admin',
            argDesc: '[on][off]',
            description: 'Gives you control of all the wolves.',
            action: (player, args) => {
                const status = CommandsManager.GetBool(args[0])
                MapPlayer.fromIndex(PLAYER_NEUTRAL_AGGRESSIVE)!.setAlliance(player, ALLIANCE_SHARED_CONTROL, status)
                MapPlayer.fromIndex(bj_PLAYER_NEUTRAL_EXTRA)!.setAlliance(player, ALLIANCE_SHARED_CONTROL, status)
                MapPlayer.fromIndex(PLAYER_NEUTRAL_PASSIVE)!.setAlliance(player, ALLIANCE_SHARED_CONTROL, status)
                MapPlayer.fromIndex(bj_PLAYER_NEUTRAL_VICTIM)!.setAlliance(player, ALLIANCE_SHARED_CONTROL, status)

                for (let i = 0; i < 24; i++) {
                    const p = MapPlayer.fromIndex(i)!
                    if (p.slotState !== PLAYER_SLOT_STATE_PLAYING) {
                        p.setAlliance(player, ALLIANCE_SHARED_CONTROL, status)
                    }
                }
            },
        })

        CommandsManager.RegisterCommand({
            name: 'resetcooldowns',
            alias: 'cooldown,cd',
            group: 'admin',
            argDesc: '',
            description: 'Resets the cooldowns of the selected unit.',
            action: (player, args) => CustomStatFrame.SelectedUnit.get(player)!.resetCooldown(), // Assuming this resets all cooldowns?
        })

        CommandsManager.RegisterCommand({
            name: 'activatechristmas',
            alias: 'christmas',
            group: 'admin',
            argDesc: '',
            description: 'Activates the Christmas terrain.',
            action: (player, args) => SeasonalManager.ActivateChristmas(),
        })

        CommandsManager.RegisterCommand({
            name: 'deactivateseason',
            alias: 'noseason',
            group: 'admin',
            argDesc: '',
            description: 'Deactivates any current seasons.',
            action: (player, args) => SeasonalManager.NoSeason(),
        })

        CommandsManager.RegisterCommand({
            name: 'award',
            alias: '',
            group: 'admin',
            argDesc: '[name]',
            description: 'Award currently selected player using award [name].',
            action: (player, args) => AwardingCmds.Awarding(player, args),
        })

        CommandsManager.RegisterCommand({
            name: 'stat',
            alias: '',
            group: 'admin',
            argDesc: '[stat] [value]',
            description: 'Sets the specified game stat for the selected player.',
            action: (player, args) => AwardingCmds.SettingGameStats(player, args),
        })

        CommandsManager.RegisterCommand({
            name: 'time',
            alias: '',
            group: 'admin',
            argDesc: '[time]',
            description: 'Sets the specified game time for the selected player.',
            action: (player, args) => AwardingCmds.SettingGameTimes(player, args),
        })

        CommandsManager.RegisterCommand({
            name: 'invulnerability',
            alias: 'invul,godmode,god',
            group: 'admin',
            argDesc: '[player][on/off]',
            description: 'invulnerability: Gives.',
            action: (player, args) => {
                if (args.length < 2) {
                    const setting = CommandsManager.GetBool(args[0])
                    const kitty = (Globals.ALL_KITTIES.get(player)!.Invulnerable = setting)
                    player.DisplayTimedTextTo(5.0, `${Colors.COLOR_GOLD}Invulnerability: ${setting}|r`)
                } else if (args.length === 2) {
                    CommandsManager.ResolvePlayerId(args[0], kitty => {
                        const setting = CommandsManager.GetBool(args[1])
                        kitty.Invulnerable = setting
                        player.DisplayTimedTextTo(
                            5.0,
                            `${Colors.COLOR_GOLD}Invulnerability for ${ColorUtils.PlayerNameColored(kitty.Player)}: ${setting}|r`
                        )
                    })
                }
            },
        })

        CommandsManager.RegisterCommand({
            name: 'pausewolves',
            alias: 'pw,pause',
            group: 'admin',
            argDesc: '[on][off]',
            description: 'Pauses all wolves. Defaults to [on]',
            action: (player, args) => {
                const status = args[0] === '' || CommandsManager.GetBool(args[0])
                Wolf.PauseAllWolves(status)
            },
        })

        CommandsManager.RegisterCommand({
            name: 'wolfpause',
            alias: 'wp',
            group: 'admin',
            argDesc: '[on][off]',
            description: 'Pauses selected wolf. Defaults to [on]',
            action: (player, args) => {
                const status = args[0] === '' || CommandsManager.GetBool(args[0])
                const selected = CustomStatFrame.SelectedUnit.get(player)
                if (selected) {
                    Wolf.PauseSelectedWolf(selected, status)
                }
            },
        })

        CommandsManager.RegisterCommand({
            name: 'wolfwalk',
            alias: 'ww',
            group: 'admin',
            argDesc: '[on][off]',
            description: 'Sets the selected wolf to walking or not. Defaults to [on]',
            action: (player, args) => {
                const status = args[0] === '' || CommandsManager.GetBool(args[0])
                const selected = CustomStatFrame.SelectedUnit.get(player)
                if (selected) {
                    const wolf = Globals.ALL_WOLVES.get(selected)
                    if (wolf) {
                        wolf.IsWalking = status
                    }
                }
            },
        })

        CommandsManager.RegisterCommand({
            name: 'spawnlocation',
            alias: 'spawnloc',
            group: 'admin',
            argDesc: '',
            description: 'Moves all kitties to the spawn location.',
            action: (player, args) => {
                const spawnCenter = RegionList.SpawnRegions[1]
                for (let i = 0; i < Globals.ALL_KITTIES_LIST.length; i++) {
                    const kitty = Globals.ALL_KITTIES_LIST[i]
                    kitty.Unit.setPosition(spawnCenter.centerX, spawnCenter.centerY)
                }
            },
        })

        CommandsManager.RegisterCommand({
            name: 'pauseround',
            alias: 'roundpause,rp',
            group: 'admin',
            argDesc: '',
            description: 'Pauses the round timer.',
            action: (player, args) => RoundTimer.StartRoundTimer.pause(),
        })

        CommandsManager.RegisterCommand({
            name: 'moretime',
            alias: 'mt',
            group: 'all',
            argDesc: '',
            description: 'Adds 20 seconds to the round timer. Can only happen once per round.',
            action: (player, args) => {
                if (!RoundManager.AddMoreRoundTime()) return
                print(
                    `${ColorUtils.PlayerNameColored(player)}${Colors.COLOR_TURQUOISE} has added more time to start the round.${Colors.COLOR_RESET}${Colors.COLOR_RED}(${RoundTimer.StartRoundTimer.remaining.toFixed(2)} seconds remaining)${Colors.COLOR_RESET}`
                )
            },
        })

        CommandsManager.RegisterCommand({
            name: 'unpauseround',
            alias: 'roundunpause,rup',
            group: 'admin',
            argDesc: '',
            description: 'Unpauses the round timer.',
            action: (player, args) => RoundTimer.StartRoundTimer.resume(),
        })

        CommandsManager.RegisterCommand({
            name: 'en',
            alias: 'hidelanes',
            group: 'admin',
            argDesc: '',
            description: 'Hides the lanes.',
            action: (player, args) => WolfLaneHider.LanesHider(),
        })

        CommandsManager.RegisterCommand({
            name: 'applyaffixall',
            alias: 'affixall,aa',
            group: 'admin',
            argDesc: '[affix]',
            description: 'Applies the specified affix to all wolves.',
            action: (player, args) => {
                const affixName =
                    args[0] !== '' ? args[0][0].toUpperCase() + args[0].substring(1).toLowerCase() : 'Speedster'
                print(`Applying ${affixName} to all wolves.`)
                for (const [_, wolf] of Globals.ALL_WOLVES) {
                    if (Globals.DNTNamedWolves.includes(wolf)) continue
                    const affix = CreateAffix(wolf, affixName)
                    AddAffix(affix, wolf)
                }
            },
        })

        CommandsManager.RegisterCommand({
            name: 'applyaffix',
            alias: 'affix,a',
            group: 'admin',
            argDesc: '[affix]',
            description: 'Applies the specified affix to the currently selected wolf.',
            action: (player, args) => {
                const affixName =
                    args[0] !== '' ? args[0][0].toUpperCase() + args[0].substring(1).toLowerCase() : 'Speedster'
                const selectedUnit = CustomStatFrame.SelectedUnit.get(player)
                if (!selectedUnit) return
                if (!Globals.ALL_WOLVES.has(selectedUnit)) return
                if (Globals.DNTNamedWolves.includes(Globals.ALL_WOLVES.get(selectedUnit)!)) return
                const affix = CreateAffix(Globals.ALL_WOLVES.get(selectedUnit)!, affixName)
                AddAffix(affix, Globals.ALL_WOLVES.get(selectedUnit)!)
            },
        })

        CommandsManager.RegisterCommand({
            name: 'removeaffix',
            alias: 'ra',
            group: 'admin',
            argDesc: '[affix]',
            description: 'Removes the specified affix from the currently selected wolf.',
            action: (player, args) => {
                const affixName = args[0] !== '' ? args[0][0].toUpperCase() + args[0].substring(1).toLowerCase() : ''
                const selectedUnit = CustomStatFrame.SelectedUnit.get(player)
                if (!selectedUnit) return
                if (!Globals.ALL_WOLVES.has(selectedUnit)) return
                if (affixName === '') return
                if (!Globals.ALL_WOLVES.get(selectedUnit)!.HasAffix(affixName)) return
                AffixUtil.RemoveAffix(affixName, Globals.ALL_WOLVES.get(selectedUnit)!)
            },
        })

        CommandsManager.RegisterCommand({
            name: 'clearaffixes',
            alias: 'ca',
            group: 'admin',
            argDesc: '',
            description: 'Clears all affixes from all wolves.',
            action: (player, args) => {
                for (const [_, wolf] of Globals.ALL_WOLVES) {
                    RemoveAllWolfAffixes(wolf)
                }
            },
        })

        CommandsManager.RegisterCommand({
            name: 'observer',
            alias: 'obs',
            group: 'admin',
            argDesc: '[playerNameMatch]',
            description: 'Forces a player into observer mode.',
            action: (player, args) => {
                const name = args[0] !== '' ? args[0] : '??__'
                for (const p of Globals.ALL_PLAYERS) {
                    if (p.name.toLowerCase().startsWith(name)) {
                        InitCommands.MakePlayerSpectator(p)
                        break
                    }
                }
            },
        })

        CommandsManager.RegisterCommand({
            name: 'summonall',
            alias: '',
            group: 'admin',
            argDesc: '',
            description: 'Summons all players to your location.',
            action: (player, args) => {
                const kitty = Globals.ALL_KITTIES.get(player)!
                for (const [_, k] of Globals.ALL_KITTIES) {
                    if (k.Unit.owner === player) continue
                    k.Unit.setPosition(kitty.Unit.x, kitty.Unit.y)
                }
            },
        })

        CommandsManager.RegisterCommand({
            name: 'camfield',
            alias: '',
            group: 'admin',
            argDesc: '[value]',
            description: 'Adjusts the camera field.',
            action: (player, args) => {
                const value = args[0] !== '' ? S2I(args[0]) : 0.0
                if (!player.isLocal()) return
                SetCameraField(CAMERA_FIELD_ANGLE_OF_ATTACK, value, 0)
            },
        })

        CommandsManager.RegisterCommand({
            name: 'roundset',
            alias: '',
            group: 'admin',
            argDesc: '[round]',
            description: 'Sets the current round.',
            action: (player, args) => {
                const round = args[0] !== '' ? S2I(args[0]) : 1
                if (round < 1 || round > 5) return
                Globals.ROUND = round - 1
                RoundManager.RoundEnd()
            },
        })

        CommandsManager.RegisterCommand({
            name: 'noend',
            alias: '',
            group: 'admin',
            argDesc: '[on/off]',
            description: "Game won't end if turned on and all kitties die.",
            action: (player, args) => {
                const status = CommandsManager.GetBool(args[0])
                Gameover.NoEnd = status
                player.DisplayTimedTextTo(6.0, `${Colors.COLOR_YELLOW_ORANGE}Game will end: ${!status}|r`)
            },
        })

        CommandsManager.RegisterCommand({
            name: 'ability',
            alias: '',
            group: 'admin',
            argDesc: '[abilityId]',
            description: 'Adds or removes an ability from the kitty.',
            action: (player, args) => {
                const abilityId = args[0] !== '' ? args[0] : ''
                const kitty = Globals.ALL_KITTIES.get(player)

                if (!kitty) return

                if (kitty.Unit.getAbilityLevel(FourCC(abilityId)) > 0) {
                    kitty.Unit.removeAbility(FourCC(abilityId))
                    const abilityName = GetObjectName(FourCC(abilityId)) // GetObjectName is async
                    player.DisplayTimedTextTo(10.0, `${Colors.COLOR_YELLOW_ORANGE}Removed ${abilityName}.`)
                } else {
                    kitty.Unit.addAbility(FourCC(abilityId))
                    const abilityName = GetObjectName(FourCC(abilityId)) // GetObjectName is async
                    player.DisplayTimedTextTo(10.0, `${Colors.COLOR_YELLOW_ORANGE}Added ${abilityName}.`)
                }
            },
        })

        CommandsManager.RegisterCommand({
            name: 'scale',
            alias: '',
            group: 'admin',
            argDesc: '[scale], [player]',
            description: "Sets the scale of the passed player's kitty parameter.",
            action: (player, args) => {
                const scale = args[0] !== '' ? S2I(args[0]) : 0.6

                if (args.length < 2 || args[1] === '') {
                    Globals.ALL_KITTIES.get(player)!.Unit.setScale(scale, scale, scale)
                    return
                }

                CommandsManager.ResolvePlayerId(args[1], kitty => {
                    if (kitty === null) return
                    kitty.Unit.setScale(scale, scale, scale)
                })
            },
        })

        CommandsManager.RegisterCommand({
            name: 'day',
            alias: '',
            group: 'red',
            argDesc: '',
            description: 'Sets the time of day to day.',
            action: (player, args) => {
                SetFloatGameState(GAME_STATE_TIME_OF_DAY, 12)
                SetTimeOfDayScale(0.0)
            },
        })

        CommandsManager.RegisterCommand({
            name: 'night',
            alias: '',
            group: 'red',
            argDesc: '',
            description: 'Sets the time of day to night.',
            action: (player, args) => {
                SetFloatGameState(GAME_STATE_TIME_OF_DAY, 0.0)
                SetTimeOfDayScale(0.0)
            },
        })

        CommandsManager.RegisterCommand({
            name: 'mem',
            alias: '',
            group: 'admin',
            argDesc: 'create | timer | all | (track <boolean>)',
            description: 'Show memory usage',
            action: (player, args) => {
                ;(_G as any)['printCreation'] = false
                memState.timer?.destroy()

                const debugObjects = args[0]
                const param2 = args[1]

                if (debugObjects === 'create' || debugObjects === 'all') {
                    ;(_G as any)['printCreation'] = true
                }

                if (debugObjects === 'track') {
                    ;(_G as any)['trackPrintMap'] = CommandsManager.GetBool(param2)
                    print(`Mem: trackPrintMap ${CommandsManager.GetBool(param2) ? 'on' : 'off'}`)
                    return true
                }

                if (debugObjects === 'timer' || debugObjects === 'all') {
                    memState.timer = Timer.create().start(1, true, MemoryHandler.printDebugInfo)
                }

                if (debugObjects === '') {
                    MemoryHandler.printDebugInfo()
                } else {
                    print(`Mem: ${debugObjects}`)
                }

                return true
            },
        })

        CommandsManager.RegisterCommand({
            name: 'aishare',
            alias: '',
            group: 'admin',
            argDesc: '',
            description: 'Shares control with all AI players.',
            action: (player, args) => {
                for (const p of Globals.ALL_PLAYERS) {
                    if (p.slotState !== PLAYER_SLOT_STATE_PLAYING) {
                        p.setAlliance(player, ALLIANCE_SHARED_CONTROL, true)
                    }
                }
            },
        })

        CommandsManager.RegisterCommand({
            name: 'exec',
            alias: '',
            group: 'admin',
            argDesc: '',
            description: 'Executes lua script',
            action: (player, args) => {
                const script = args[0] !== '' ? args.join(' ') : ''
                if (isNullOrEmpty(script)) return
                ExecuteLua.LuaCode(player, script)
            },
        })

        CommandsManager.RegisterCommand({
            name: 'createhero',
            alias: 'crh',
            group: 'admin',
            argDesc: '[playerNumber]',
            description: 'Creates a hero for the specified player.',
            action: (player, args) => {
                for (let i = 0; i < 24; i++) {
                    const target: number =
                        args.length > 0 && args[0] !== 'all'
                            ? S2I(args[0]) - 1
                            : args.length > 0 && args[0] === 'all'
                              ? i
                              : -1

                    if (target === i || args[0] === 'all') {
                        const compPlayer = MapPlayer.fromIndex(target)!

                        if (Globals.ALL_KITTIES.has(compPlayer)) {
                            player.DisplayTimedTextTo(10.0, `${Colors.COLOR_YELLOW_ORANGE}Player already has a hero.`)
                            continue
                        }

                        Globals.ALL_PLAYERS.push(compPlayer)
                        new Circle(compPlayer)
                        const newKitty = new Kitty(compPlayer)
                        newKitty.Unit.addItemById(FourCC('bspd'))
                    }
                }
            },
        })

        CommandsManager.RegisterCommand({
            name: 'deletehero',
            alias: 'delh',
            group: 'admin',
            argDesc: '[playerNumber]',
            description: 'Deletes the hero of the specified player.',
            action: (player, args) => {
                if (args[0] === '') {
                    // cannot delete self anyway, but for usage i guess.
                    player.DisplayTimedTextTo(
                        10.0,
                        `${Colors.COLOR_YELLOW_ORANGE}Usage: deletehero [player] or [all]|r`
                    )
                    return
                }

                CommandsManager.ResolvePlayerId(args[0], kitty => {
                    if (kitty === null) return
                    if (!Globals.ALL_KITTIES.has(kitty.Player)) {
                        player.DisplayTimedTextTo(10.0, `${Colors.COLOR_YELLOW_ORANGE}Player does not have a hero.|r`)
                        return
                    }
                    if (
                        kitty.Player.slotState === PLAYER_SLOT_STATE_PLAYING &&
                        kitty.Player.controller !== MAP_CONTROL_COMPUTER
                    ) {
                        // if slotted, it becomes computer.. this allows for deletion of even slotted comps
                        player.DisplayTimedTextTo(10.0, `${Colors.COLOR_YELLOW_ORANGE}Player is not a computer.|r`)
                        return
                    }

                    PlayerLeaves.PlayerLeavesActions(kitty.Player)
                })
            },
        })

        CommandsManager.RegisterCommand({
            name: 'skin',
            alias: '',
            group: 'admin',
            argDesc: '[skinId], [player]',
            description: 'Sets the skin of the passed player parameter. Use "none" for default skin.',
            action: (player, args) => {
                const skin: number = args[0] === '' || args[0] === 'none' ? Constants.UNIT_KITTY : FourCC(args[0])

                if (args.length < 2 || args[1] === '') {
                    const kitty = Globals.ALL_KITTIES.get(player)
                    if (!kitty) return
                    kitty.Unit.skin = skin
                    return
                }

                CommandsManager.ResolvePlayerId(args[1], kitty => {
                    if (!kitty) return
                    kitty.Unit.skin = skin
                })
                return
            },
        })

        CommandsManager.RegisterCommand({
            name: 'ai',
            alias: '',
            group: 'admin',
            argDesc: '[playerNumber]',
            description: 'Toggles AI for the specified player.',
            action: (player, args) => {
                CommandsManager.ResolvePlayerId(args[0], kitty => {
                    if (kitty === null) return
                    if (!Globals.ALL_KITTIES.has(kitty.Player)) {
                        player.DisplayTimedTextTo(10.0, `${Colors.COLOR_YELLOW_ORANGE}Player does not have a hero.`)
                        return
                    }

                    if (kitty.aiController.IsEnabled()) {
                        kitty.aiController.StopAi()
                        player.DisplayTimedTextTo(1.0, `${Colors.COLOR_YELLOW}AI deactivated.`)
                    } else {
                        kitty.aiController.StartAi()
                        player.DisplayTimedTextTo(1.0, `${Colors.COLOR_YELLOW}AI activated.`)
                    }
                })
            },
        })

        CommandsManager.RegisterCommand({
            name: 'aisetup',
            alias: '',
            group: 'admin',
            argDesc: '[dodgeRadius] [timerInterval] [laser]',
            description: 'Sets up AI parameters.',
            action: (player, args) => {
                if (args[0] === '') {
                    player.DisplayTimedTextTo(
                        10.0,
                        `${Colors.COLOR_YELLOW_ORANGE}Usage: aisetup [dodgeRadius=192] [timerInterval=0.1] [laser=0]`
                    )
                    return
                }

                const dodgeRadius = args.length > 0 ? S2I(args[0]) : 192.0
                const timerInterval = args.length > 1 ? S2I(args[1]) : 0.1
                const laser = args.length > 2 ? S2I(args[2]) : 0

                for (const [_, compKitty] of Globals.ALL_KITTIES) {
                    if (compKitty.aiController.IsEnabled()) {
                        compKitty.aiController.DODGE_RADIUS = dodgeRadius
                        compKitty.aiController.timerInterval = timerInterval
                        compKitty.aiController.laser = laser === 1
                    }
                }

                player.DisplayTimedTextTo(
                    10.0,
                    `${Colors.COLOR_YELLOW}AI setup: dodgeRadius=${dodgeRadius}, timerInterval=${timerInterval}, laser=${laser}`
                )
            },
        })

        CommandsManager.RegisterCommand({
            name: 'ailaser',
            alias: 'lasercolor',
            group: 'admin',
            argDesc: '[free/blocked] [ID: string]',
            description: 'Changes the color of the laser on all the AI, free or blocked',
            action: (player, args) => {
                if (args[0] === '') {
                    return
                }

                const laserType = args[0].toLowerCase()
                if (laserType !== 'free' && laserType !== 'blocked') {
                    player.DisplayTimedTextTo(
                        10.0,
                        `${Colors.COLOR_YELLOW_ORANGE}Usage: ailaser [free/blocked] [string]`
                    )
                    return
                }

                if (laserType === 'free') AIController.FREE_LASER_COLOR = args[1].toUpperCase()
                else if (laserType === 'blocked') AIController.BLOCKED_LASER_COLOR = args[1].toUpperCase()

                player.DisplayTimedTextTo(
                    10.0,
                    `${Colors.COLOR_YELLOW}Laser color changed: ${laserType} laser color is now ${args[1].toUpperCase()}`
                )
            },
        })

        CommandsManager.RegisterCommand({
            name: 'aitest',
            alias: 'test33',
            group: 'admin',
            argDesc: '',
            description: 'Changes the color of the laser on all the AI, free or blocked',
            action: (player, args) => {
                for (const [_, compKitty] of Globals.ALL_KITTIES) {
                    if (compKitty.aiController.IsEnabled()) {
                        compKitty.aiController.DODGE_RADIUS = 160.0
                        compKitty.aiController.timerInterval = 0.1
                        compKitty.aiController.laser = true
                    }
                }
                player.DisplayTimedTextTo(10.0, `${Colors.COLOR_YELLOW}Test started`)
            },
        })

        CommandsManager.RegisterCommand({
            name: 'killunit',
            alias: 'kill,kl',
            group: 'admin',
            argDesc: 'playerID: resolve',
            description: 'Kills yourself by default, enter player name/number/selected parm. KITTIES ONLY',
            action: (player, args) => {
                if (args[0] === '') {
                    Globals.ALL_KITTIES.get(player)!.KillKitty()
                    return
                }
                CommandsManager.ResolvePlayerId(args[0], kitty => kitty.KillKitty())
            },
        })

        CommandsManager.RegisterCommand({
            name: 'kibblecurrency',
            alias: 'kibbleinfo,kbinfo',
            group: 'all',
            argDesc: 'player name, #, selected, or self',
            description: 'Gets the Kibble Currency information on the given player.',
            action: (player, args) => {
                CommandsManager.ResolvePlayerId(args[0], kitty => AwardingCmds.GetKibbleCurrencyInfo(player, kitty))
            },
        })

        CommandsManager.RegisterCommand({
            name: 'error',
            alias: '',
            group: 'all',
            argDesc: '[on][off]',
            description: 'Turns the error prompts on or off',
            action: (player, args) => {
                const status = args[0] !== '' && CommandsManager.GetBool(args[0])
                ErrorMessagesOn.active = status
                player.DisplayTimedTextTo(5.0, `${Colors.COLOR_YELLOW_ORANGE}Error messages: ${status}`)
            },
        })

        CommandsManager.RegisterCommand({
            name: 'times',
            alias: 'gettimes',
            group: 'all',
            argDesc: '[player] [difficulty]',
            description:
                'Gets fastest overall times of the passed player and difficulty parm, if no parm then yourself and current difficulty.',
            action: (player, args) => {
                const difficulty = args.length > 1 && args[1] !== '' ? args[1] : Difficulty.DifficultyOption.name
                if (args[0] === '') {
                    AwardingCmds.GetAllGameTimes(player, Globals.ALL_KITTIES.get(player)!, difficulty)
                    return
                }
                CommandsManager.ResolvePlayerId(args[0], kitty =>
                    AwardingCmds.GetAllGameTimes(player, kitty, difficulty)
                )
            },
        })

        CommandsManager.RegisterCommand({
            name: 'personalbests',
            alias: 'pbs,bests',
            group: 'all',
            argDesc: '[player]',
            description: 'Gets personal best stats of the passed player parm, if no parm then yourself.',
            action: (player, args) => {
                if (args[0] === '') {
                    AwardingCmds.GetAllPersonalBests(player, Globals.ALL_KITTIES.get(player)!)
                    return
                }
                CommandsManager.ResolvePlayerId(args[0], kitty => AwardingCmds.GetAllPersonalBests(player, kitty))
            },
        })

        CommandsManager.RegisterCommand({
            name: 'stats',
            alias: '',
            group: 'all',
            argDesc: '',
            description: 'Gets the game stats of the passed player parm, if no parm then yourself.',
            action: (player, args) => {
                if (args[0] === '') {
                    AwardingCmds.GetAllGameStats(player, Globals.ALL_KITTIES.get(player)!)
                    return
                }
                CommandsManager.ResolvePlayerId(args[0], kitty => AwardingCmds.GetAllGameStats(player, kitty))
            },
        })

        CommandsManager.RegisterCommand({
            name: 'shop',
            alias: '',
            group: 'all',
            argDesc: '',
            description: 'Opens the shop frame.',
            action: (player, args) => {
                ShopFrame.ShopFrameActions()
            },
        })

        CommandsManager.RegisterCommand({
            name: 'rewards',
            alias: '',
            group: 'all',
            argDesc: '',
            description: 'Opens the rewards frame.',
            action: (player, args) => {
                RewardsFrame.RewardsFrameActions()
            },
        })

        CommandsManager.RegisterCommand({
            name: 'music',
            alias: '',
            group: 'all',
            argDesc: '',
            description: 'Opens the music frame.',
            action: (player, args) => {
                MusicFrame.MusicFrameActions()
            },
        })

        CommandsManager.RegisterCommand({
            name: 'revivetest',
            alias: 'yoshi',
            group: 'admin',
            argDesc: '[on][off]',
            description: 'Activates the revive invul for 6.0 seconds. Served as a test run.',
            action: (player, args) => {
                const status: boolean = args[0] !== '' && CommandsManager.GetBool(args[0])
                Kitty.InvulTest = status
                player.DisplayTimedTextTo(3.0, `${Colors.COLOR_YELLOW_ORANGE}Revive invul test: ${status}`)
            },
        })

        CommandsManager.RegisterCommand({
            name: 'col',
            alias: 'collision',
            group: 'admin',
            argDesc: '[player]',
            description: 'Gets collision of passed player, or yourself if no args.',
            action: (player, args) => {
                if (args[0] === '') {
                    player.DisplayTimedTextTo(3.0, `${Globals.ALL_KITTIES.get(player)!.CurrentStats.CollisonRadius}`)
                    return
                }
                CommandsManager.ResolvePlayerId(args[0], kitty => {
                    player.DisplayTimedTextTo(
                        3.0,
                        `${ColorUtils.PlayerNameColored(kitty.Player)} : ${kitty.CurrentStats.CollisonRadius}`
                    )
                })
            },
        })

        CommandsManager.RegisterCommand({
            name: 'fortest',
            alias: '',
            group: 'admin',
            argDesc: '[on][off]',
            description: 'Foreach memory test, executes 20k iterations of for loop.',
            action: (player, args) => {
                // Roughly 3MB of memory per 20k iterations.
                for (let i = 0; i < 20000; i++) {
                    for (const [_, k] of Globals.ALL_KITTIES) {
                        const a = k.TeamID
                    }
                }
                player.DisplayTextTo(Colors.COLOR_YELLOW_ORANGE + 'Done')
            },
        })

        CommandsManager.RegisterCommand({
            name: 'spawnkibble',
            alias: 'skb',
            group: 'admin',
            argDesc: '[# of kibble]',
            description: 'Spawns specified number of kibbles',
            action: (player, args) => {
                const amount = args[0] !== '' ? S2I(args[0]) : ItemSpawner.NUMBER_OF_ITEMS
                ItemSpawner.SpawnKibble(amount)
            },
        })

        CommandsManager.RegisterCommand({
            name: 'savedvc',
            alias: 'svc, ssc',
            group: 'all',
            argDesc: '',
            description: 'Sets you to your previously last saved vortex color if you have one.',
            action: (player, args) => {
                const kitty: Kitty = Globals.ALL_KITTIES.get(player)!
                const vortexColor: string = kitty.SaveData.PlayerColorData.VortexColor
                if (vortexColor === '') return
                const rgb = vortexColor.split(',')
                ColorUtils.SetPlayerVertexColor(kitty.Player, rgb)
            },
        })

        CommandsManager.RegisterCommand({
            name: 'sendtostart',
            alias: 'sts',
            group: 'admin',
            argDesc: '[resolvePlayerId]',
            description: 'Sends the passed player to the start',
            action: (player, args) => {
                CommandsManager.ResolvePlayerId(args[0], kitty => {
                    if (kitty === null) return
                    const spawnCenter = RegionList.SpawnRegions[1]
                    kitty.Unit.setPosition(spawnCenter.centerX, spawnCenter.centerY)
                })
            },
        })

        CommandsManager.RegisterCommand({
            name: 'team',
            alias: 't',
            group: 'all',
            argDesc: '[team #]',
            description: 'Assigns you to the provided team # (TEAM MODE ONLY)',
            action: (player, args) => {
                if (args[0] === '') {
                    player.DisplayTimedTextTo(
                        5.0,
                        `${Colors.COLOR_YELLOW_ORANGE}Usage: team [team #]${Colors.COLOR_RESET}`
                    )
                    return
                }
                TeamHandler.Handler(player, S2I(args[0]))
            },
        })

        CommandsManager.RegisterCommand({
            name: 'test5',
            alias: 't5',
            group: 'admin',
            argDesc: '',
            description: 'Creates a team deathless effect',
            action: (player, args) => {
                print(`${Colors.COLOR_TURQUOISE}# of Commands: ${CommandsManager.length}`)
            },
        })

        CommandsManager.RegisterCommand({
            name: 'deathless',
            alias: 'dl',
            group: 'admin',
            argDesc: '[player]',
            description: 'Teleports the ResolvePlayerId to each safezone all the way to the end',
            action: (player, args) => {
                if (args[0] === '') {
                    player.DisplayTimedTextTo(5.0, `${Colors.COLOR_YELLOW_ORANGE}Usage: -deathless [ResolvePlayerId]|r`)
                    return
                }
                CommandsManager.ResolvePlayerId(args[0], kitty => {
                    if (kitty === null) return
                    const safeZones = RegionList.SafeZones
                    for (const safeZone of safeZones) {
                        kitty.Unit.setPosition(safeZone.centerX, safeZone.centerY)
                    }
                })
            },
        })

        CommandsManager.RegisterCommand({
            name: 'restart',
            alias: 'rst',
            group: 'admin',
            argDesc: '',
            description: 'Restarts the current round and time to 0:00',
            action: (player, args) => {
                if (Globals.ROUND <= 0) return
                Globals.GAME_SECONDS = Globals.GAME_SECONDS - GameTimer.RoundTime[Globals.ROUND]
                GameTimer.RoundTime[Globals.ROUND] = 0.0 // reset the round end time
                Globals.ROUND = Globals.ROUND - 1
                RoundManager.RoundEnd()
            },
        })

        CommandsManager.RegisterCommand({
            name: 'disablekibble',
            alias: 'dkb',
            group: 'red',
            argDesc: '',
            description: 'Kibble: Disables',
            action: (player, args) => {
                Kibble.SpawningKibble = !Kibble.SpawningKibble
                print(`Kibble spawning is now: ${Kibble.SpawningKibble}`)
            },
        })

        CommandsManager.RegisterCommand({
            name: 'weather',
            alias: '',
            group: 'red',
            argDesc: '[weather]',
            description: 'Options: snow, hsnow, blizzard, rain, hrain, rays, moonlight, none',
            action: (player, args) => {
                if (args[0] === '') {
                    player.DisplayTimedTextTo(
                        5.0,
                        `${Colors.COLOR_YELLOW_ORANGE}Usage: weather [weather type]${Colors.COLOR_RESET}`
                    )
                    return
                }
                SeasonalManager.SetWeatherArg(args[0])
            },
        })

        CommandsManager.RegisterCommand({
            name: 'test9',
            alias: '',
            group: 'admin',
            argDesc: '[weather]',
            description: 'Test: Sand',
            action: (player, args) => {
                TerrainChanger.ChangeMapTerrain(TerrainChanger.LastWolfTerrain, FourCC('Zdrg'))
                print('Terrain: Changed')
            },
        })

        CommandsManager.RegisterCommand({
            name: 'test8',
            alias: '',
            group: 'admin',
            argDesc: '',
            description: 'Puts an effect test on for some nitro thingy',
            action: (player, args) => {
                const unitKitty = Globals.ALL_KITTIES.get(player)!.Unit
                Effect.createAttachment('TestThing.mdx', unitKitty, 'origin')!
            },
        })

        CommandsManager.RegisterCommand({
            name: 'kittylist',
            alias: '',
            group: 'admin',
            argDesc: '',
            description: 'Lists all kitties',
            action: (player, args) => {
                let x: string = ''
                for (const k of Globals.ALL_KITTIES_LIST) {
                    x += `${ColorUtils.PlayerNameColored(k.Player)} (${k.Player.id})\n`
                }
                print(x)
            },
        })

        CommandsManager.RegisterCommand({
            name: 'chainedtest',
            alias: '',
            group: 'admin',
            argDesc: '',
            description: 'Starts chained together test',
            action: (player, args) => {
                ChainedTogether.TriggerEvent()
                ChainedTogether.StartEvent()
            },
        })

        CommandsManager.RegisterCommand({
            name: 'chaineffect',
            alias: '',
            group: 'admin',
            argDesc: '',
            description: 'Testing the chain effect model',
            action: (player, args) => {
                const kitty = Globals.ALL_KITTIES.get(player)!
                Effect.createAttachment('ChainTest.mdx', kitty.Unit, 'origin')!
            },
        })

        CommandsManager.RegisterCommand({
            name: 'teammove',
            alias: 'tm',
            group: 'admin',
            argDesc: '[ResolvePlayerId] [Team #]',
            description: 'Swaps the passed ResolvePlayerId to the provided Team #, no restrictions',
            action: (player, args) => {
                if (args.length < 2 || args[0] === '' || args[1] === '') {
                    player.DisplayTimedTextTo(
                        5.0,
                        `${Colors.COLOR_YELLOW_ORANGE}Usage: teammove [ResolvePlayerId] [Team #]${Colors.COLOR_RESET}`
                    )
                    return
                }
                CommandsManager.ResolvePlayerId(args[0], kitty => {
                    TeamHandler.Handler(kitty.Player, S2I(args[1]), true)
                })
            },
        })

        CommandsManager.RegisterCommand({
            name: 'playersperteam',
            alias: 'ppt',
            group: 'admin',
            argDesc: '[# Allowed Per Team]',
            description: 'Sets the maximum # of people allowed per team to passed parm.',
            action: (player, args) => {
                if (args[0] === '') {
                    player.DisplayTimedTextTo(
                        5.0,
                        `${Colors.COLOR_YELLOW_ORANGE}Usage: playersperteam [# Allowed Per Team]${Colors.COLOR_RESET}`
                    )
                    return
                }
                const maxPlayersPerTeam = parseInt(args[0], 10)
                if (isNaN(maxPlayersPerTeam) || maxPlayersPerTeam < 1 || maxPlayersPerTeam > 24) {
                    player.DisplayTimedTextTo(
                        5.0,
                        `${Colors.COLOR_YELLOW_ORANGE}Invalid number of team players. (1-24)|r`
                    )
                    return
                }
                Gamemode.PlayersPerTeam = maxPlayersPerTeam
                player.DisplayTimedTextTo(
                    5.0,
                    `${Colors.COLOR_YELLOW_ORANGE}Players Per Team set to Max ${maxPlayersPerTeam}|r`
                )
            },
        })

        CommandsManager.RegisterCommand({
            name: 'test10',
            alias: '',
            group: 'admin',
            argDesc: '',
            description: 'Getting wolf timer address information',
            action: (player, args) => {
                const selectedUnit = CustomStatFrame.SelectedUnit.get(player)
                if (!selectedUnit) return
                if (!Globals.ALL_WOLVES.has(selectedUnit)) return
                const wolf = Globals.ALL_WOLVES.get(selectedUnit)!
                const timerAddress: string = `WCTimerAddresses:${wolf.WanderTimer} : ${wolf.EffectTimer}`
                print(`${timerAddress}`)
            },
        })

        CommandsManager.RegisterCommand({
            name: 'getdate',
            alias: '',
            group: 'all',
            argDesc: '',
            description: 'Gets the current date, time, day, month, etc.',
            action: (player, args) => {
                player.DisplayTimedTextTo(
                    3.0,
                    `${Colors.COLOR_YELLOW_ORANGE}Date: ${DateTimeManager.DateTime.toString()}`
                )
            },
        })

        CommandsManager.RegisterCommand({
            name: 'slidespeed',
            alias: 'ss',
            group: 'admin',
            argDesc: '[speed] [player]',
            description: 'Sets the absolute slide speed of the passed player, or yourself if no player is provided.',
            action: (player, args) => {
                if (args[0] === '') {
                    player.DisplayTimedTextTo(5.0, `${Colors.COLOR_YELLOW_ORANGE}Usage: slidespeed [speed] [player]|r`)
                    return
                }

                const speed: number = S2I(args[0])
                if (args.length < 2 || args[1] === '') {
                    Globals.ALL_KITTIES.get(player)!.Slider.absoluteSlideSpeed = speed > 0 ? speed : null
                    player.DisplayTimedTextTo(5.0, `${Colors.COLOR_YELLOW_ORANGE}Set your slide speed to ${speed}|r`)
                    return
                }

                let isMatch: boolean = false

                CommandsManager.ResolvePlayerId(args[1], kitty => {
                    if (kitty === null) return
                    isMatch = true
                    kitty.Slider.absoluteSlideSpeed = speed > 0 ? speed : null
                })

                if (isMatch) {
                    player.DisplayTimedTextTo(5.0, `${Colors.COLOR_YELLOW_ORANGE}Set their slide speed to ${speed}|r`)
                }
            },
        })

        CommandsManager.RegisterCommand({
            name: 'movespeed',
            alias: 'ms',
            group: 'admin',
            argDesc: '[speed] [player]',
            description: 'Sets the absolute move speed of the passed player, or yourself if no player is provided.',
            action: (player, args) => {
                if (args[0] === '') {
                    player.DisplayTimedTextTo(5.0, `${Colors.COLOR_YELLOW_ORANGE}Usage: movespeed [speed] [player]|r`)
                    return
                }

                const speed: number = S2I(args[0])
                if (args.length < 2 || args[1] === '') {
                    const kitty = Globals.ALL_KITTIES.get(player)
                    if (!kitty) return
                    kitty.RTR.absoluteMoveSpeed = speed > 0 ? speed : 0
                    player.DisplayTimedTextTo(5.0, `${Colors.COLOR_YELLOW_ORANGE}Set your move speed to ${speed}|r`)
                    return
                }

                let isMatch: boolean = false

                CommandsManager.ResolvePlayerId(args[1], kitty => {
                    if (kitty === null) return
                    isMatch = true
                    kitty.RTR.absoluteMoveSpeed = speed > 0 ? speed : 0
                })

                if (isMatch) {
                    player.DisplayTimedTextTo(5.0, `${Colors.COLOR_YELLOW_ORANGE}Set their move speed to ${speed}|r`)
                }
            },
        })

        CommandsManager.RegisterCommand({
            name: 'speededit',
            alias: 'se',
            group: 'admin',
            argDesc: '[on/off] [player]',
            description: 'Turns on RTR and sets move speed to 800 for the specified player.',
            action: (player, args) => {
                if (args[0] === '') {
                    player.DisplayTimedTextTo(5.0, `${Colors.COLOR_YELLOW_ORANGE}Usage: speededit [on/off] [player]|r`)
                    return
                }

                const mode: boolean = CommandsManager.GetBool(args[0])

                if (args.length < 2 || args[1] === '') {
                    // Apply to self
                    if (mode) {
                        Globals.ALL_KITTIES.get(player)!.RTR.StartRTR()
                        Globals.ALL_KITTIES.get(player)!.RTR.absoluteMoveSpeed = 800
                        player.DisplayTextTo(Colors.COLOR_GOLD + 'Speed Edit: On (RTR + 800 speed)')
                    } else {
                        Globals.ALL_KITTIES.get(player)!.RTR.StopRTR()
                        Globals.ALL_KITTIES.get(player)!.RTR.absoluteMoveSpeed = 0
                        player.DisplayTextTo(Colors.COLOR_GOLD + 'Speed Edit: Off')
                    }
                    return
                }

                let isMatch: boolean = false

                CommandsManager.ResolvePlayerId(args[1], kitty => {
                    if (kitty === null) return
                    isMatch = true
                    if (mode) {
                        kitty.RTR.StartRTR()
                        kitty.RTR.absoluteMoveSpeed = 800
                    } else {
                        kitty.RTR.StopRTR()
                        kitty.RTR.absoluteMoveSpeed = 0
                    }
                })

                if (isMatch) {
                    player.DisplayTextTo(
                        Colors.COLOR_GOLD +
                            `Speed Edit set to ${mode ? 'On (RTR + 800 speed)' : 'Off'} for target player`
                    )
                }
            },
        })
    }

    /// <summary>
    /// Makes a player a spectator by removing them from their team,
    /// disposing of their in-game objects, and refreshing the game state.
    /// </summary>
    /// <param name="player">The player to be made a spectator.</param>
    public static MakePlayerSpectator(player: MapPlayer) {
        PlayerLeaves.TeamRemovePlayer(player)
        Globals.ALL_KITTIES.get(player)?.dispose()
        Globals.ALL_CIRCLES.get(player)?.dispose()
        safeArraySplice(Globals.ALL_PLAYERS, p => p === player)
        Globals.ALL_KITTIES.get(player)?.NameTag?.dispose()
        RoundManager.RoundEndCheck()
        MultiboardUtil.RefreshMultiboards()
    }
}
