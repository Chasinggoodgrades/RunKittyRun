import { Regions } from 'src/AutoGenerated/Regions'
import { Kitty } from 'src/Game/Entities/Kitty/Kitty'
import { ItemSpatialGrid } from 'src/Game/Items/ItemSpatialGrid'
import { Globals } from 'src/Global/Globals'
import { ErrorHandler } from 'src/Utility/ErrorHandler'
import { getTriggerPlayer } from 'src/Utility/w3tsUtils'
import { MapPlayer, Timer, Trigger, Unit } from 'w3ts'

export class FirstPersonCamera {
    private timerPeriod: number = 0.001
    private FIRSTPERSON_ANGLE_PER_PERIOD: number = 0.3

    private forceCamTimer: Timer
    private hero: Unit
    private player: MapPlayer
    private keyDownState: Map<string, boolean>
    private lastUnitAnimation: string

    public constructor(hero: Unit, player: MapPlayer) {
        this.hero = hero
        this.player = player
        this.keyDownState = {
            UP: false,
            DOWN: false,
            LEFT: false,
            RIGHT: false,
        }
    }

    public IsFirstPerson(): boolean {
        return this.forceCamTimer != null
    }

    public ToggleFirstPerson(active: boolean) {
        if (active) {
            if (this.forceCamTimer == null) {
                this.forceCamTimer = Timer.create()
                this.forceCamTimer.start(this.timerPeriod, true, ErrorHandler.Wrap(this.UpdateCamera))
            }
        } else {
            if (this.forceCamTimer != null) {
                this.forceCamTimer.pause()
                this.forceCamTimer.destroy()
                this.ResetCamera()
            }
        }
    }

    private UpdateCamera() {
        if (this.hero == null || !this.hero.isAlive()) return

        let fwd: number = 0

        if (
            !(this.keyDownState['LEFT'] && this.keyDownState['RIGHT']) &&
            (this.keyDownState['LEFT'] || this.keyDownState['RIGHT'])
        ) {
            let angle: number = GetUnitFacing(this.hero)
            if (this.keyDownState['LEFT']) angle += this.FIRSTPERSON_ANGLE_PER_PERIOD
            if (this.keyDownState['RIGHT']) angle -= this.FIRSTPERSON_ANGLE_PER_PERIOD
            this.hero.setFacingEx(angle)
        }

        if (
            !(this.keyDownState['UP'] && this.keyDownState['DOWN']) &&
            (this.keyDownState['UP'] || this.keyDownState['DOWN'])
        ) {
            let moveSpeed: number = this.hero.moveSpeed
            let movePerTick: number = moveSpeed * this.timerPeriod

            let kitty: Kitty = Globals.ALL_KITTIES.get(this.player)!

            if (kitty.Slider.IsEnabled()) {
                movePerTick = 0.2
            }

            let angle: number = Rad2Deg(GetUnitFacing(this.hero))
            if (this.keyDownState['UP']) fwd += movePerTick
            if (this.keyDownState['DOWN']) fwd -= movePerTick

            let oldX: number = this.hero.x
            let oldY: number = this.hero.y

            let newX: number = oldX + fwd * Cos(angle)
            let newY: number = oldY + fwd * Sin(angle)

            if (!Globals.GAME_ACTIVE && Regions.BarrierRegion.includes(newX, newY)) {
                return
            }

            if (IsTerrainPathable(newX, oldY, PATHING_TYPE_WALKABILITY)) {
                newX = oldX
            }

            if (IsTerrainPathable(oldX, newY, PATHING_TYPE_WALKABILITY)) {
                newY = oldY
            }

            this.hero.setPathing(false)
            SetUnitPosition(this.hero, newX, newY)
            this.hero.setPathing(true)
        }

        if (fwd == 0) {
            if (this.lastUnitAnimation != 'stand') {
                this.lastUnitAnimation = 'stand'
                this.hero.setAnimation(0) // 0 is stand for most units
            }
        } else {
            if (this.lastUnitAnimation != 'walk') {
                this.lastUnitAnimation = 'walk'
                this.hero.setAnimation(6) // POTM is 6 for walk
            }
        }

        SetCameraTargetControllerNoZForPlayer(this.player, this.hero, 0, 0, true)
        SetCameraFieldForPlayer(this.player, CAMERA_FIELD_ANGLE_OF_ATTACK, 310, 0)
        SetCameraFieldForPlayer(this.player, CAMERA_FIELD_FIELD_OF_VIEW, 1500, 0)
        SetCameraFieldForPlayer(this.player, CAMERA_FIELD_ROTATION, GetUnitFacing(this.hero), 0)
        SetCameraFieldForPlayer(this.player, CAMERA_FIELD_ZOFFSET, 100, 0)

        this.ItemPickup()
    }

    public SetKeyDownState(key: string, state: boolean) {
        if (this.keyDownState.has(key)) {
            this.keyDownState[key] = state
        }
    }

    private ResetCamera() {
        if (!this.player.isLocal()) return
        SetCameraTargetControllerNoZForPlayer(this.player, this.hero, 0, 0, false)
        ResetToGameCamera(0)
        SetCameraField(CAMERA_FIELD_TARGET_DISTANCE, 2400.0, 0.0)
    }

    private ItemPickup() {
        let kitty: Kitty = Globals.ALL_KITTIES.get(this.player)!
        ItemSpatialGrid.KittyItemPickup(kitty)
    }
}

export class FirstPersonCameraManager {
    private static cameras: Map<player, FirstPersonCamera> = new Map()

    public static Initialize() {
        for (let player of Globals.ALL_PLAYERS) {
            let hero = FirstPersonCameraManager.GetHeroForPlayer(player)
            if (hero != null) {
                FirstPersonCameraManager.cameras[player] = new FirstPersonCamera(hero, player)
            }
        }

        FirstPersonCameraManager.RegisterKeyEvents()
    }

    private static RegisterKeyEvents() {
        let keyStates: Map<string, number> = {
            true: bj_KEYEVENTTYPE_DEPRESS,
            false: bj_KEYEVENTTYPE_RELEASE,
        }

        let keys: Map<string, number> = {
            UP: bj_KEYEVENTKEY_UP,
            DOWN: bj_KEYEVENTKEY_DOWN,
            LEFT: bj_KEYEVENTKEY_LEFT,
            RIGHT: bj_KEYEVENTKEY_RIGHT,
        }

        for (let keyState in keyStates) {
            for (let key in keys) {
                for (let p of Globals.ALL_PLAYERS) {
                    let keyTrigger = Trigger.create()!
                    let localKey = key.Key // Create a local copy of the key
                    let localValue = keyState.Key // Create a local copy of the value
                    TriggerRegisterPlayerKeyEventBJ(keyTrigger, p, keyState.Value, key.Value)
                    TriggerAddAction(keyTrigger, () => FirstPersonCameraManager.OnKeyEvent(localKey, localValue))
                }
            }
        }
    }

    private static OnKeyEvent(key: string, isDown: boolean) {
        if (FirstPersonCameraManager.cameras.has(getTriggerPlayer())) {
            FirstPersonCameraManager.cameras[getTriggerPlayer()].SetKeyDownState(key, isDown)
        }
    }

    private static GetHeroForPlayer(player: MapPlayer): Unit {
        return Globals.ALL_KITTIES.has(player) ? Globals.ALL_KITTIES.get(player)!.Unit : null
    }

    public static ToggleFirstPerson(player: MapPlayer) {
        if (FirstPersonCameraManager.cameras.has(player)) {
            FirstPersonCameraManager.cameras[player].ToggleFirstPerson(
                !FirstPersonCameraManager.cameras[player].IsFirstPerson()
            )
        }
    }

    public static SetFirstPerson(player: MapPlayer, active: boolean) {
        if (FirstPersonCameraManager.cameras.has(player)) {
            FirstPersonCameraManager.cameras[player].ToggleFirstPerson(active)
        }
    }
}
