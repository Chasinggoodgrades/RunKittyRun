import { Constants } from 'src/AutoGenerated/Constants'
import { PROD } from 'src/env'
import { Kitty } from 'src/Game/Entities/Kitty/Kitty'
import { Wolf } from 'src/Game/Entities/Wolf'
import { Safezone } from 'src/Game/Management/Safezone'
import { WolfArea } from 'src/Game/WolfArea'
import { DEFAULT_WOLF_COLLISION_RADIUS, Globals } from 'src/Global/Globals'
import { IDisposable } from 'src/Utility/CSUtils'
import { MemoryHandler } from 'src/Utility/MemoryHandler/MemoryHandler'
import { clamp } from 'src/Utility/Utility'
import { MapPlayer, Timer } from 'w3ts'

export class AIController {
    private kitty: Kitty
    private enabled = false
    public DODGE_RADIUS = 192.0
    public DODGE_RADIUS_STILL = 128.0
    private DODGE_DISTANCE = 128 // Amount to walk away
    public static FREE_LASER_COLOR = 'GRSB'
    public static BLOCKED_LASER_COLOR = 'RESB'
    private static WindwalkID = FourCC('BOwk')
    private static offsets: number[] = [-90, -45, 0.0, 45, 90]
    public _timerInterval = 0.1

    public get timerInterval(): number {
        return this._timerInterval
    }

    public set timerInterval(value: number) {
        const clamped = Math.max(value, 0.01)
        if (clamped === this._timerInterval) {
            return
        }

        this._timerInterval = clamped

        if (this.IsEnabled()) {
            this.PauseAi()
            this.ResumeAi()
        }
    }

    public laser = !PROD

    private lastCommand = ''
    private lastX = 0
    private lastY = 0
    private hasLastOrder = false
    private lastOrderTime = 0
    private elapsedTime = 0

    private moveTimer: Timer | undefined
    private wolvesInRange: Wolf[] = []
    private lastLightning: lightning | undefined

    private lastSafeZoneIndexId: number | undefined
    private reachedLastProgressZoneCenter = false
    private availableBlockedLightnings: lightning[] = []
    private availableClearLightnings: lightning[] = []
    private usedBlockedLightnings: lightning[] = []
    private usedClearLightnings: lightning[] = []
    private blockedIntervals: AngleInterval[] = []
    private freeGaps: AngleInterval[] = []
    private mergedIntervals: AngleInterval[] = []
    private static claimedKitties: Map<Kitty, Kitty> = new Map()
    private wallPoints: Point[] = []

    public constructor(kitty: Kitty) {
        this.kitty = kitty
        this.enabled = false
    }

    /**
     * Starts the AI controller for the kitty
     */
    public StartAi = () => {
        this.enabled = true
        this.ResumeAi()
    }

    /**
     * Resumes the AI movement timer and clears any claimed kitties
     */
    public ResumeAi = () => {
        if (!this.enabled) return

        if (!this.moveTimer) {
            this.moveTimer = Timer.create()
            this.moveTimer.start(this.timerInterval, true, this.PollMovement)
        }

        // If I revive release me from the claimedKitties
        if (AIController.claimedKitties.has(this.kitty)) {
            AIController.claimedKitties.delete(this.kitty)
        }
    }

    /**
     * Stops the AI controller completely
     */
    public StopAi = () => {
        this.enabled = false
        this.PauseAi()
    }

    /**
     * Pauses the AI movement timer and cleans up resources
     */
    public PauseAi = () => {
        this.lastCommand = ''
        this.lastX = 0
        this.lastY = 0
        this.hasLastOrder = false
        this.lastOrderTime = 0
        this.elapsedTime = 0

        if (!!this.moveTimer) {
            this.moveTimer.pause()
            this.moveTimer.destroy()
            this.moveTimer = undefined
        }

        this.lastLightning && DestroyLightning(this.lastLightning)

        this.HideAllLightnings()
        this.HideAllFreeLightnings()

        // If I die release my target from the claimedKitties
        if (AIController.claimedKitties.has(this.kitty)) {
            AIController.claimedKitties.delete(this.kitty)
        }
    }

    /**
     * Returns whether the AI controller is currently enabled
     */
    public IsEnabled(): boolean {
        return this.enabled
    }

    /**
     * Calculates the current progress zone for the given kitty
     * @param kitty The kitty to calculate the progress zone for
     * @returns The current progress zone ID
     */
    private CalcProgressZone = (kitty: Kitty) => {
        let currentProgressZoneId = kitty.ProgressZone

        if (this.IsInSafeZone(kitty.Unit.x, kitty.Unit.y, currentProgressZoneId + 1)) {
            currentProgressZoneId++
        }

        return currentProgressZoneId
    }

    /**
     * Handles the main AI movement logic - determines target position and moves kitty
     */
    private MoveKittyToPosition = () => {
        const currentProgressZoneId = this.CalcProgressZone(this.kitty)
        const currentSafezone = Globals.SAFE_ZONES[currentProgressZoneId]
        const nextSafezone =
            currentProgressZoneId + 1 < Globals.SAFE_ZONES.length - 1
                ? Globals.SAFE_ZONES[currentProgressZoneId + 1]
                : currentSafezone
        const currentSafezoneCenter = this.GetCenterPositionInSafezone(currentSafezone)
        const nextSafezoneCenter = this.GetCenterPositionInSafezone(nextSafezone)

        const currentSafeZoneId = this.IsInSafeZone(this.kitty.Unit.x, this.kitty.Unit.y, currentProgressZoneId)
            ? currentProgressZoneId
            : undefined

        if (currentSafeZoneId !== this.lastSafeZoneIndexId) {
            this.reachedLastProgressZoneCenter = !currentSafeZoneId
            this.lastSafeZoneIndexId = currentSafeZoneId
        }

        const distanceToCurrentCenter = Math.sqrt(
            Math.pow(this.kitty.Unit.x - currentSafezoneCenter[0], 2) +
                Math.pow(this.kitty.Unit.y - currentSafezoneCenter[1], 2)
        )
        const SAFEZONE_THRESHOLD = 128.0

        if (distanceToCurrentCenter <= SAFEZONE_THRESHOLD) {
            this.reachedLastProgressZoneCenter = true
        }

        let allKittiesAtSameOrHigherSafezone = true // IEnumberable is dog shit for C# -> Lua conversion, this should -help-
        for (let i = 0; i < Globals.ALL_KITTIES_LIST.length; i++) {
            const k = Globals.ALL_KITTIES_LIST[i]
            if (!PROD && k.Player === MapPlayer.fromIndex(0)!) {
                continue
            }

            if (this.CalcProgressZone(k) < currentProgressZoneId) {
                allKittiesAtSameOrHigherSafezone = false
                break
            }
        }

        let targetPosition =
            this.reachedLastProgressZoneCenter && allKittiesAtSameOrHigherSafezone
                ? nextSafezoneCenter
                : currentSafezoneCenter

        for (const [_, circle] of Globals.ALL_CIRCLES) {
            const deadKitty = Globals.ALL_KITTIES.get(circle.Player)!
            const deadKittyProgressZoneId = this.CalcProgressZone(deadKitty)

            if (deadKittyProgressZoneId > currentProgressZoneId) {
                continue
            }

            if (deadKitty === this.kitty) {
                continue
            }

            if (!deadKitty.isAlive()) {
                if (!AIController.claimedKitties.has(deadKitty)) {
                    const thisDistance = Math.sqrt(
                        Math.pow(this.kitty.Unit.x - deadKitty.Unit.x, 2) +
                            Math.pow(this.kitty.Unit.y - deadKitty.Unit.y, 2)
                    )
                    const thisLaneDiff = Math.abs(currentProgressZoneId - deadKittyProgressZoneId)

                    let isNearest = true

                    for (let i = 0; i < Globals.ALL_KITTIES_LIST.length; i++) {
                        const otherKitty = Globals.ALL_KITTIES_LIST[i]
                        if (!PROD && otherKitty.Player === MapPlayer.fromIndex(0)!) {
                            continue
                        }

                        if (otherKitty !== this.kitty && otherKitty.isAlive()) {
                            const otherDistance = Math.sqrt(
                                Math.pow(otherKitty.Unit.x - deadKitty.Unit.x, 2) +
                                    Math.pow(otherKitty.Unit.y - deadKitty.Unit.y, 2)
                            )
                            const otherLaneDiff = Math.abs(this.CalcProgressZone(otherKitty) - deadKittyProgressZoneId)

                            // Prioritize by lane difference first, then by distance.
                            // Don't think this works for some reason..
                            if (
                                otherLaneDiff < thisLaneDiff ||
                                (otherLaneDiff === thisLaneDiff && otherDistance < thisDistance)
                            ) {
                                isNearest = false
                                break
                            }
                        }
                    }

                    if (isNearest) {
                        AIController.claimedKitties.set(deadKitty, this.kitty)
                    }
                }

                if (
                    AIController.claimedKitties.has(deadKitty) &&
                    AIController.claimedKitties.get(deadKitty) === this.kitty
                ) {
                    if (deadKittyProgressZoneId !== currentProgressZoneId) {
                        if (
                            this.IsInSafeZone(this.kitty.Unit.x, this.kitty.Unit.y, currentProgressZoneId) &&
                            this.reachedLastProgressZoneCenter
                        ) {
                            targetPosition =
                                currentProgressZoneId - 1 >= 0
                                    ? this.GetCenterPositionInSafezone(Globals.SAFE_ZONES[currentProgressZoneId - 1])
                                    : currentSafezoneCenter
                        } else {
                            targetPosition = currentSafezoneCenter
                        }

                        break
                    }

                    targetPosition = [circle.Unit.x, circle.Unit.y]
                    break
                }
            }
        }

        const wolvesInLane = WolfArea.WolfAreas.get(currentProgressZoneId)!.Wolves

        this.wolvesInRange = []
        for (let i = 0; i < wolvesInLane.length; i++) {
            const wolf = wolvesInLane[i]
            if (
                this.IsWithinRadius(
                    this.kitty.Unit.x,
                    this.kitty.Unit.y,
                    wolf.Unit.x,
                    wolf.Unit.y,
                    wolf.IsWalking ? this.DODGE_RADIUS : this.DODGE_RADIUS_STILL
                )
            ) {
                this.wolvesInRange.push(wolf)
            }
        }

        const forwardDirection: [number, number] = [
            targetPosition[0] - this.kitty.Unit.x,
            targetPosition[1] - this.kitty.Unit.y,
        ]

        if (this.wolvesInRange.length > 0) {
            const dodgePosition = this.GetCompositeDodgePosition(this.wolvesInRange, forwardDirection)
            this.IssueOrder('move', dodgePosition[0], dodgePosition[1], true)
            return
        } else {
            this.HideAllLightnings()
            this.HideAllFreeLightnings()
        }

        const deltaX = targetPosition[0] - this.kitty.Unit.x
        const deltaY = targetPosition[1] - this.kitty.Unit.y
        const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY)
        if (distance > 256) {
            const scale = 256 / distance
            const moveX = this.kitty.Unit.x + deltaX * scale
            const moveY = this.kitty.Unit.y + deltaY * scale
            this.IssueOrder('move', moveX, moveY, false)
        } else {
            this.IssueOrder('move', targetPosition[0], targetPosition[1], false)
        }
    }

    /**
     * Checks if the given coordinates are within the lane bounds for the current progress zone
     * @param x The X coordinate to check
     * @param y The Y coordinate to check
     * @returns True if the position is within lane bounds
     */
    private IsWithinLaneBounds = (x: number, y: number) => {
        const currentProgressZoneId = this.kitty.ProgressZone
        const laneBounds = WolfArea.WolfAreas.get(currentProgressZoneId)!.Rectangle

        const width = laneBounds.maxX - laneBounds.minX
        const height = laneBounds.maxY - laneBounds.minY

        // Assume a vertical lane if its width is less than its height.
        if (width < height) {
            // Vertical lane: check only the y coordinate.
            return x >= laneBounds.minX && x <= laneBounds.maxX
        } else {
            // Horizontal lane: check only the x coordinate.
            return y >= laneBounds.minY && y <= laneBounds.maxY
        }
    }

    /**
     * Checks if the given coordinates are within a specific safe zone
     * @param x The X coordinate to check
     * @param y The Y coordinate to check
     * @param safeZoneId The ID of the safe zone to check
     * @returns True if the position is within the safe zone
     */
    private IsInSafeZone = (x: number, y: number, safeZoneId: number) => {
        if (safeZoneId < 0 || safeZoneId >= Globals.SAFE_ZONES.length) {
            return false // prevent out of bounds errors xd
        }
        const safezone = Globals.SAFE_ZONES[safeZoneId]

        return (
            x >= safezone.Rectangle.minX &&
            x <= safezone.Rectangle.maxX &&
            y >= safezone.Rectangle.minY &&
            y <= safezone.Rectangle.maxY
        )
    }

    /**
     * Issues a movement or position order to the kitty with debouncing
     * @param command The command to issue (e.g., 'move')
     * @param x The target X coordinate
     * @param y The target Y coordinate
     * @param isDodge Whether this is a dodge movement (affects minimum distance threshold)
     */
    private IssueOrder = (command: string, x: number, y: number, isDodge: boolean) => {
        const MIN_MOVE_DISTANCE = isDodge ? 16.0 : 64.0

        if (command === 'move') {
            if (!!this.lastLightning) {
                MoveLightning(this.lastLightning, false, this.kitty.Unit.x, this.kitty.Unit.y, x, y)
            } else {
                if (this.laser) {
                    this.lastLightning = AddLightning('DRAM', false, this.kitty.Unit.x, this.kitty.Unit.y, x, y)!
                }
            }
        }

        const deltaX = x - this.lastX
        const deltaY = y - this.lastY
        const distanceSquared = deltaX * deltaX + deltaY * deltaY

        if (
            this.hasLastOrder &&
            this.lastCommand === command &&
            distanceSquared < MIN_MOVE_DISTANCE * MIN_MOVE_DISTANCE
        ) {
            if (this.elapsedTime - this.lastOrderTime < 4) {
                return
            }
        }

        this.lastCommand = command
        this.lastX = x
        this.lastY = y
        this.lastOrderTime = this.elapsedTime
        this.hasLastOrder = true
        this.kitty.Unit.issueOrderAt(command, x, y)
    }

    /**
     * Issues a basic order to the kitty without coordinates
     * @param command The command to issue
     */
    private IssueOrderBasic = (command: string) => {
        this.lastCommand = command
        this.lastX = -1
        this.lastY = -1
        this.lastOrderTime = this.elapsedTime
        this.hasLastOrder = true
        this.kitty.Unit.issueImmediateOrder(command)
    }

    /**
     * Gets the center position of a given safe zone
     * @param safezone The safe zone to get the center of
     * @returns Array containing [centerX, centerY] coordinates
     */
    private GetCenterPositionInSafezone = (safezone: Safezone) => {
        const centerX = (safezone.Rectangle.minX + safezone.Rectangle.maxX) / 2
        const centerY = (safezone.Rectangle.minY + safezone.Rectangle.maxY) / 2
        return [centerX, centerY]
    }

    /**
     * Calculates crossing points where the kitty's dodge range intersects with lane boundaries.
     * For walls to be within range of the kitty, a line must pass through the circle at two points.
     * Uses mathematical formula for a line passing through two points on a circle.
     */
    CalcCrossingPoints = () => {
        for (let i = 0; i < this.wallPoints.length; i++) {
            const point = this.wallPoints[i]
            point.dispose()
        }

        this.wallPoints = []

        const dodgeRange = this.DODGE_DISTANCE * (this.timerInterval + 0.2)
        const currentProgressZoneId = this.kitty.ProgressZone
        const laneBounds = WolfArea.WolfAreas.get(currentProgressZoneId)!.Rectangle

        const width = laneBounds.maxX - laneBounds.minX
        const height = laneBounds.maxY - laneBounds.minY

        const isVertical = width < height

        if (isVertical) {
            // Handle vertical walls (left/right) as before.
            let constant = Number.NaN
            if (this.kitty.Unit.x - dodgeRange < laneBounds.minX) constant = laneBounds.minX
            else if (this.kitty.Unit.x + dodgeRange > laneBounds.maxX) constant = laneBounds.maxX
            else return

            const relativeY = Math.sqrt(dodgeRange * dodgeRange - Math.pow(this.kitty.Unit.x - constant, 2))
            if (!Number.isNaN(relativeY) && relativeY !== 0) {
                const a = MemoryHandler.getEmptyClass(Point, constant, relativeY + this.kitty.Unit.y)
                this.wallPoints.push(a)

                const b = MemoryHandler.getEmptyClass(Point, constant, -relativeY + this.kitty.Unit.y)
                this.wallPoints.push(b)
            }
        } else {
            let constant = Number.NaN
            if (this.kitty.Unit.y + dodgeRange > laneBounds.maxY) constant = laneBounds.maxY
            else if (this.kitty.Unit.y - dodgeRange < laneBounds.minY) constant = laneBounds.minY
            else return

            const relativeX = Math.sqrt(dodgeRange * dodgeRange - Math.pow(this.kitty.Unit.y - constant, 2))
            if (!Number.isNaN(relativeX) && relativeX !== 0) {
                const a = MemoryHandler.getEmptyClass(Point, relativeX + this.kitty.Unit.x, constant)
                this.wallPoints.push(a)

                const b = MemoryHandler.getEmptyClass(Point, -relativeX + this.kitty.Unit.x, constant)
                this.wallPoints.push(b)
            }
        }

        return
    }

    /**
     * Calculates the angles formed by two points on the circumference relative to the center
     * @param pointA First point on the circumference
     * @param pointB Second point on the circumference
     * @returns Array containing [angleA, angleB] in radians
     */
    AnglesFromCenter(pointA: [number, number], pointB: [number, number]) {
        const angleA = this.AngleOf(pointA, [this.kitty.Unit.x, this.kitty.Unit.y])
        const angleB = this.AngleOf(pointB, [this.kitty.Unit.x, this.kitty.Unit.y])
        return [angleA, angleB]
    }

    /**
     * Calculates the angle of a point relative to a center point
     * @param point The point to calculate the angle for
     * @param center The center point to calculate from
     * @returns The normalized angle in radians
     */
    AngleOf(point: [number, number], center: [number, number]) {
        const deltaX = point[0] - center[0]
        const deltaY = point[1] - center[1]
        const radians = Math.atan2(deltaY, deltaX)
        return this.NormalizeAngle(radians)
    }

    /**
     * Calculates the optimal dodge position to avoid wolves while moving toward the target.
     * Uses a reusable struct array instead of creating new objects for better performance.
     * @param wolves Array of wolves to dodge
     * @param forwardDirection The desired forward direction as [x, y]
     * @returns The optimal dodge position as [x, y] coordinates
     */
    private GetCompositeDodgePosition = (wolves: Wolf[], forwardDirection: [number, number]) => {
        const forwardAngle = this.NormalizeAngle(Math.atan2(forwardDirection[1], forwardDirection[0]))
        const requiredClearance = 22.5 * (Math.PI / 180)

        // Calculate the angle interval that each wolf “blocks.”
        for (let i = 0; i < wolves.length; i++) {
            const wolf: Wolf = wolves[i]

            let MIN_TOTAL_BLOCKED_ANGLE = 45.0 * (Math.PI / 180)
            let MAX_TOTAL_BLOCKED_ANGLE = 270.0 * (Math.PI / 180)

            if (!wolf.IsWalking) {
                MIN_TOTAL_BLOCKED_ANGLE = 30.0 * (Math.PI / 180)
                MAX_TOTAL_BLOCKED_ANGLE = 150.0 * (Math.PI / 180)
            }

            const dx = wolf.Unit.x - this.kitty.Unit.x
            const dy = wolf.Unit.y - this.kitty.Unit.y
            const distance = Math.sqrt(dx * dx + dy * dy)

            if (distance < 1) continue // Skip if the wolf is at the same position to avoid division by zero

            const centerAngle = Math.atan2(wolf.Unit.y - this.kitty.Unit.y, wolf.Unit.x - this.kitty.Unit.x)
            const clampedDistance = clamp(distance, DEFAULT_WOLF_COLLISION_RADIUS, this.DODGE_RADIUS)
            const ratio =
                (clampedDistance - DEFAULT_WOLF_COLLISION_RADIUS) / (this.DODGE_RADIUS - DEFAULT_WOLF_COLLISION_RADIUS)

            const totalBlockedAngle =
                MIN_TOTAL_BLOCKED_ANGLE + (MAX_TOTAL_BLOCKED_ANGLE - MIN_TOTAL_BLOCKED_ANGLE) * (1 - ratio)
            const halfAngle = totalBlockedAngle / 2

            // Create the interval [centerAngle - halfAngle, centerAngle + halfAngle]
            const start = this.NormalizeAngle(centerAngle - halfAngle)
            const end = this.NormalizeAngle(centerAngle + halfAngle)

            // If the interval wraps around 0, split it into two parts.
            if (start > end) {
                const a = MemoryHandler.getEmptyClass(AngleInterval, start, 2 * Math.PI)
                this.blockedIntervals.push(a)

                const b = MemoryHandler.getEmptyClass(AngleInterval, 0, end)
                this.blockedIntervals.push(b)
            } else {
                const a = MemoryHandler.getEmptyClass(AngleInterval, start, end)
                this.blockedIntervals.push(a)
            }
        }

        this.CalcCrossingPoints()

        if (this.wallPoints.length === 2) {
            let [angleA, angleB] = this.AnglesFromCenter(
                [this.wallPoints[0].x, this.wallPoints[0].y],
                [this.wallPoints[1].x, this.wallPoints[1].y]
            )

            if (angleA > angleB) {
                const temp = angleA
                angleA = angleB
                angleB = temp
            }

            let start: number
            let end: number

            if (angleB - angleA > 180.0 * (Math.PI / 180)) {
                start = angleB
                end = angleA
            } else {
                start = angleA
                end = angleB
            }

            // If the interval wraps around 0, split it into two parts.
            if (start > end) {
                const a = MemoryHandler.getEmptyClass(AngleInterval, start, 2 * Math.PI)
                this.blockedIntervals.push(a)

                const b = MemoryHandler.getEmptyClass(AngleInterval, 0, end)
                this.blockedIntervals.push(b)
            } else {
                const a = MemoryHandler.getEmptyClass(AngleInterval, start, end)
                this.blockedIntervals.push(a)
            }
        }

        // Merge any overlapping blocked intervals.
        this.MergeIntervals(this.blockedIntervals)

        // Visualize the blocked intervals
        this.HideAllLightnings()
        for (let i = 0; i < this.mergedIntervals.length; i++) {
            this.VisualizeBlockedInterval(this.mergedIntervals[i])
        }

        // Determine free angular gaps on the circle.
        if (this.mergedIntervals.length === 0) {
            // No wolves blocking any direction; entire circle is free.
            const a = MemoryHandler.getEmptyClass(AngleInterval, 0, 2 * Math.PI)
            this.freeGaps.push(a)
        } else {
            // Ensure the merged intervals are sorted by their start angle.
            //mergedIntervals.Sort((a, b) => a.Start.CompareTo(b.Start));
            this.SortAngleIntervals(this.mergedIntervals)

            // The gap between the end of the last interval and the start of the first (accounting for wrap-around).
            const wrapGap =
                this.mergedIntervals[0].Start + 2 * Math.PI - this.mergedIntervals[this.mergedIntervals.length - 1].End
            if (wrapGap > 0) {
                const a = MemoryHandler.getEmptyClass(
                    AngleInterval,
                    this.mergedIntervals[this.mergedIntervals.length - 1].End,
                    this.mergedIntervals[0].Start + 2 * Math.PI
                )
                this.freeGaps.push(a)
            }
            // Gaps between consecutive intervals.
            for (let i = 0; i < this.mergedIntervals.length - 1; i++) {
                const gapSize = this.mergedIntervals[i + 1].Start - this.mergedIntervals[i].End
                if (gapSize > 0) {
                    const a = MemoryHandler.getEmptyClass(
                        AngleInterval,
                        this.mergedIntervals[i].End,
                        this.mergedIntervals[i + 1].Start
                    )
                    this.freeGaps.push(a)
                }
            }
        }

        // Visualize the free intervals
        this.HideAllFreeLightnings()
        for (let i = 0; i < this.freeGaps.length; i++) {
            const interval = this.freeGaps[i]
            this.VisualizeFreeInterval(interval)
        }

        const targetX = this.kitty.Unit.x + Math.cos(forwardAngle) * this.DODGE_DISTANCE
        const targetY = this.kitty.Unit.y + Math.sin(forwardAngle) * this.DODGE_DISTANCE

        let bestCandidateScore = math.maxinteger
        let bestCandidateAngle = -500 // Default to the original forward angle

        for (let i = 0; i < AIController.offsets.length; i++) {
            const offset = AIController.offsets[i]
            const candidateAngle = this.NormalizeAngle(forwardAngle + offset)

            const bestAngle = this.calcAngle(candidateAngle, requiredClearance)

            if (bestAngle === -500) {
                continue
            }

            const candX = this.kitty.Unit.x + Math.cos(bestAngle) * this.DODGE_DISTANCE
            const candY = this.kitty.Unit.y + Math.sin(bestAngle) * this.DODGE_DISTANCE

            const dx = Math.abs(candX - targetX)
            const dy = Math.abs(candY - targetY)
            const score = dx * dx + dy * dy

            if (score < bestCandidateScore) {
                bestCandidateScore = score
                bestCandidateAngle = bestAngle
            }
        }

        if (bestCandidateAngle === -500) {
            this.cleanArrays()
            return [this.kitty.Unit.x, this.kitty.Unit.y]
        }

        // Update the forward direction to the chosen dodge direction.
        const forwardDirection2 = [Math.cos(bestCandidateAngle), Math.sin(bestCandidateAngle)]

        this.cleanArrays()

        // Return the target dodge position (kitty's position plus 128 in the chosen direction).
        return [
            this.kitty.Unit.x + forwardDirection2[0] * this.DODGE_DISTANCE,
            this.kitty.Unit.y + forwardDirection2[1] * this.DODGE_DISTANCE,
        ]
    }

    /**
     * Calculates the best angle to move in, considering required clearance from obstacles
     * @param forwardAngle The desired forward angle in radians
     * @param requiredClearance The minimum clearance required in radians
     * @returns The best angle to move in, or -500 if no valid angle found
     */
    private calcAngle = (forwardAngle: number, requiredClearance: number) => {
        // Initialize bestAngle to the original forward direction
        let bestAngle = -500
        let foundGapContainingForward = false

        // First, check if forwardAngle falls within any free gap.
        for (let i = 0; i < this.freeGaps.length; i++) {
            const gap: AngleInterval = this.freeGaps[i]

            if (gap.End - gap.Start < requiredClearance) {
                continue
            }

            if (this.IsAngleInInterval(forwardAngle, gap)) {
                foundGapContainingForward = true
                // Calculate the distance from forwardAngle to the gap boundaries.
                const diffToStart = this.AngleDifference(forwardAngle, gap.Start)
                const diffToEnd = this.AngleDifference(gap.End, forwardAngle)

                // If too close to the start boundary, adjust forwardAngle to be 45° inside.
                if (diffToStart < requiredClearance) {
                    bestAngle = gap.Start + requiredClearance
                }
                // If too close to the end boundary, adjust forwardAngle to be 45° inside.
                else {
                    if (diffToEnd < requiredClearance) {
                        bestAngle = gap.End - requiredClearance
                    } else {
                        bestAngle = forwardAngle // It’s safely in the middle.
                    }
                }
                break
            }
        }

        // If forwardAngle isn't within any free gap, find the candidate edge closest to forwardAngle.
        if (!foundGapContainingForward) {
            let bestScore = math.maxinteger
            for (
                let i = 0;
                i < this.freeGaps.length;
                i++ // Replacing for with for loop
            ) {
                const gap: AngleInterval = this.freeGaps[i] // Accessing the element by index

                if (gap.End - gap.Start < requiredClearance) {
                    continue
                }

                // Calculate candidate angles from each gap’s boundaries (adjusted by required clearance).
                const candidateFromStart = this.NormalizeAngle(gap.Start + requiredClearance)
                const candidateFromEnd = this.NormalizeAngle(gap.End - requiredClearance)

                const diffStart = this.AngleDifference(forwardAngle, candidateFromStart)
                const diffEnd = this.AngleDifference(candidateFromEnd, forwardAngle)

                if (diffStart < bestScore) {
                    bestScore = diffStart
                    bestAngle = candidateFromStart
                }

                if (diffEnd < bestScore) {
                    bestScore = diffEnd
                    bestAngle = candidateFromEnd
                }
            }
        }

        return bestAngle
    }

    /**
     * Checks if an angle falls within a given angle interval
     * @param angle The angle to check (in radians)
     * @param interval The angle interval to check against
     * @returns True if the angle is within the interval
     */
    private IsAngleInInterval = (angle: number, interval: AngleInterval) => {
        // Normalize the angle and interval boundaries to [0, 2π)
        angle = this.NormalizeAngle(angle)
        const start = this.NormalizeAngle(interval.Start)
        const end = this.NormalizeAngle(interval.End)

        // Check if the interval does not wrap around.
        if (start <= end) {
            return angle >= start && angle <= end
        }
        // If the interval wraps around 0 (e.g., 350° to 10°), the angle is within the interval
        // if it's greater than or equal to the start OR less than or equal to the end.
        return angle >= start || angle <= end
    }

    /**
     * Cleans up temporary arrays used for angle calculations and disposes of objects
     */
    private cleanArrays = () => {
        for (let i = 0; i < this.blockedIntervals.length; i++) {
            this.blockedIntervals[i].dispose()
        }
        this.blockedIntervals = []

        for (let i = 0; i < this.freeGaps.length; i++) {
            this.freeGaps[i].dispose()
        }
        this.freeGaps = []

        // Clear mergedIntervals without destroying references
        this.mergedIntervals = []
    }

    /**
     * Visualizes a blocked angle interval using lightning effects
     * @param interval The angle interval to visualize
     */
    private VisualizeBlockedInterval = (interval: AngleInterval) => {
        if (!this.laser) {
            return
        }

        const radius = this.DODGE_RADIUS
        const step = 0.1 // Adjust step size for smoother lines
        for (let angle = interval.Start; angle < interval.End; angle += step) {
            const x1 = this.kitty.Unit.x + radius * Math.cos(angle)
            const y1 = this.kitty.Unit.y + radius * Math.sin(angle)
            const x2 = this.kitty.Unit.x + radius * Math.cos(angle + step)
            const y2 = this.kitty.Unit.y + radius * Math.sin(angle + step)

            //
            let freeLightning: lightning | null = null

            if (this.availableBlockedLightnings.length > 0) {
                freeLightning = this.availableBlockedLightnings[this.availableBlockedLightnings.length - 1]
                this.availableBlockedLightnings.splice(this.availableBlockedLightnings.length - 1, 1)
            }

            if (!freeLightning) {
                freeLightning = AddLightning(AIController.BLOCKED_LASER_COLOR, false, x1, y1, x2, y2)! // "AFOD" is finger of death code
            }

            this.usedBlockedLightnings.push(freeLightning)
            MoveLightning(freeLightning, false, x1, y1, x2, y2)
        }
    }

    /**
     * Visualizes a free angle interval using lightning effects
     * @param interval The angle interval to visualize
     */
    private VisualizeFreeInterval = (interval: AngleInterval) => {
        if (!this.laser) {
            return
        }

        const radius = this.DODGE_RADIUS
        const step = 0.1 // Adjust step size for smoother lines
        for (let angle = interval.Start; angle < interval.End; angle += step) {
            const x1 = this.kitty.Unit.x + radius * Math.cos(angle)
            const y1 = this.kitty.Unit.y + radius * Math.sin(angle)
            const x2 = this.kitty.Unit.x + radius * Math.cos(angle + step)
            const y2 = this.kitty.Unit.y + radius * Math.sin(angle + step)

            //
            let freeLightning: lightning | null = null

            if (this.availableClearLightnings.length > 0) {
                freeLightning = this.availableClearLightnings[this.availableClearLightnings.length - 1]
                this.availableClearLightnings.splice(this.availableClearLightnings.length - 1, 1)
            }

            if (!freeLightning) {
                freeLightning = AddLightning(AIController.FREE_LASER_COLOR, false, x1, y1, x2, y2)!
            }

            this.usedClearLightnings.push(freeLightning)
            MoveLightning(freeLightning, false, x1, y1, x2, y2)
        }
    }

    /**
     * Hides all blocked lightning effects by moving them to (0,0) and returning them to the available pool
     */
    private HideAllLightnings = () => {
        for (let i = 0; i < this.usedBlockedLightnings.length; i++) {
            const lightning = this.usedBlockedLightnings[i]
            MoveLightning(lightning, false, 0.0, 0.0, 0.0, 0.0)
            this.availableBlockedLightnings.push(lightning)
        }

        this.usedBlockedLightnings = []
    }

    /**
     * Hides all free lightning effects by moving them to (0,0) and returning them to the available pool
     */
    private HideAllFreeLightnings = () => {
        for (let i = 0; i < this.usedClearLightnings.length; i++) {
            const lightning = this.usedClearLightnings[i]
            MoveLightning(lightning, false, 0.0, 0.0, 0.0, 0.0)
            this.availableClearLightnings.push(lightning)
        }

        this.usedClearLightnings = []
    }

    /**
     * Normalizes an angle (in radians) to the range [0, 2π)
     * @param angle The angle to normalize
     * @returns The normalized angle
     */
    private NormalizeAngle = (angle: number) => {
        while (angle < 0) angle += 2 * Math.PI
        while (angle >= 2 * Math.PI) angle -= 2 * Math.PI
        return angle
    }

    /**
     * Returns the smallest difference (in radians) between two angles
     * @param a First angle
     * @param b Second angle
     * @returns The absolute difference between the angles
     */
    private AngleDifference = (a: number, b: number) => {
        const diff = ((a - b + Math.PI) % (2 * Math.PI)) - Math.PI
        return Math.abs(diff)
    }

    /**
     * Sorts an array of angle intervals by their start angle using bubble sort
     * @param intervals The array of angle intervals to sort
     */
    private SortAngleIntervals = (intervals: AngleInterval[]) => {
        for (let i = 0; i < intervals.length - 1; i++) {
            for (let j = 0; j < intervals.length - i - 1; j++) {
                if (intervals[j].Start > intervals[j + 1].Start) {
                    // Swap intervals[j] and intervals[j + 1]
                    const temp = intervals[j]
                    intervals[j] = intervals[j + 1]
                    intervals[j + 1] = temp
                }
            }
        }
    }

    /**
     * Merges overlapping angular intervals into a single merged list
     * @param intervals The array of intervals to merge
     */
    private MergeIntervals = (intervals: AngleInterval[]) => {
        this.SortAngleIntervals(intervals)

        let current: AngleInterval = intervals[0]

        for (let i = 1; i < intervals.length; i++) {
            if (this.IsAngleInInterval(intervals[i].Start, current)) {
                // Extend the current interval if needed.
                current.End = Math.max(current.End, intervals[i].End)
            } else {
                this.mergedIntervals.push(current)
                current = intervals[i]
            }
        }

        this.mergedIntervals.push(current)
    }

    /**
     * Checks if two points are within a specified radius of each other
     * @param x1 First point X coordinate
     * @param y1 First point Y coordinate
     * @param x2 Second point X coordinate
     * @param y2 Second point Y coordinate
     * @param radius The radius to check within
     * @returns True if the points are within the specified radius
     */
    private IsWithinRadius = (x1: number, y1: number, x2: number, y2: number, radius: number) => {
        const distance = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1))
        return distance <= radius
    }

    /**
     * Main polling method that handles AI movement, skill learning, and windwalk usage
     */
    private PollMovement = () => {
        if (!this.enabled) return
        this.elapsedTime += this.timerInterval
        this.LearnSkills()
        this.UseWindWalkIfAvailable()
        this.MoveKittyToPosition()
    }

    /**
     * Automatically learns available skills for the kitty
     */
    private LearnSkills = () => {
        if (this.kitty.Unit.skillPoints > 0) {
            this.kitty.Unit.selectSkill(Constants.ABILITY_WIND_WALK)
            this.kitty.Unit.selectSkill(Constants.ABILITY_AGILITY_AURA)
            this.kitty.Unit.selectSkill(Constants.ABILITY_ENERGY_AURA)
        }
    }

    /**
     * Uses windwalk ability if available and kitty has sufficient mana
     */
    private UseWindWalkIfAvailable = () => {
        const wwLvl = GetUnitAbilityLevel(this.kitty.Unit.handle, Constants.ABILITY_WIND_WALK)

        if (
            wwLvl === 0 ||
            (wwLvl === 1 && this.kitty.Unit.mana < 75) ||
            (wwLvl === 2 && this.kitty.Unit.mana < 60) ||
            (wwLvl === 3 && this.kitty.Unit.mana < 45)
        ) {
            return
        }

        if (UnitHasBuffBJ(this.kitty.Unit.handle, AIController.WindwalkID)) return

        this.IssueOrderBasic('windwalk')
    }
}

/**
 * Helper class representing an angular interval [Start, End] in radians.
 */
export class AngleInterval extends IDisposable {
    public Start = 0
    public End = 0

    public constructor(start: number, end: number) {
        super()
        this.Start = start
        this.End = end
    }

    /**
     * Disposes of the angle interval object
     */
    public dispose = () => {
        MemoryHandler.destroyObject(this)
    }
}

/**
 * Helper class representing a 2D point with x and y coordinates
 */
export class Point extends IDisposable {
    public x = 0
    public y = 0

    public constructor(x: number, y: number) {
        super()
        this.x = x
        this.y = y
    }

    /**
     * Disposes of the point object
     */
    public dispose = () => {
        MemoryHandler.destroyObject(this)
    }
}
