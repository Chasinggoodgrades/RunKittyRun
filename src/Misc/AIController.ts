import { Constants } from 'src/AutoGenerated/Constants'
import { PROD } from 'src/env'
import { Kitty } from 'src/Game/Entities/Kitty/Kitty'
import { Wolf } from 'src/Game/Entities/Wolf'
import { Safezone } from 'src/Game/Management/Safezone'
import { WolfArea } from 'src/Game/WolfArea'
import { DEFAULT_WOLF_COLLISION_RADIUS, Globals } from 'src/Global/Globals'
import { IDisposable } from 'src/Utility/CSUtils'
import { ErrorHandler } from 'src/Utility/ErrorHandler'
import { MemoryHandler } from 'src/Utility/MemoryHandler/MemoryHandler'
import { clamp, int } from 'src/Utility/Utility'
import { MapPlayer, Timer } from 'w3ts'

export class AIController {
    private kitty: Kitty
    private enabled: boolean
    public DODGE_RADIUS: number = 192.0
    public DODGE_RADIUS_STILL: number = 128.0
    private DODGE_DISTANCE: number = 128 // Amount to walk away
    public static FREE_LASER_COLOR: string = 'GRSB'
    public static BLOCKED_LASER_COLOR: string = 'RESB'
    private static WindwalkID: number = FourCC('BOwk')
    private static offsets: number[] = [-90, -45, 0.0, 45, 90]
    public _timerInterval: number = 0.1

    public get timerInterval(): number {
        return this._timerInterval
    }

    public set timerInterval(value: number) {
        const clamped = Math.max(value, 0.01)
        if (clamped === this._timerInterval) {
            return
        }

        this._timerInterval = clamped

        if (this.IsEnabled()) {
            this.PauseAi()
            this.ResumeAi()
        }
    }

    public laser: boolean = !PROD

    private lastCommand: string = ''
    private lastX: number
    private lastY: number
    private hasLastOrder: boolean = false
    private lastOrderTime: number = 0
    private elapsedTime: number = 0

    private moveTimer: Timer
    private wolvesInRange: Wolf[] = []
    private lastLightning: lightning

    private lastSafeZoneIndexId: number | null
    private reachedLastProgressZoneCenter: boolean = false
    private availableBlockedLightnings: lightning[] = []
    private availableClearLightnings: lightning[] = []
    private usedBlockedLightnings: lightning[] = []
    private usedClearLightnings: lightning[] = []
    private blockedIntervals: AngleInterval[] = []
    private freeGaps: AngleInterval[] = []
    private mergedIntervals: AngleInterval[] = []
    private claimedKitties: Map<Kitty, Kitty> = new Map()
    private wallPoints: Point[] = []

    public constructor(kitty: Kitty) {
        this.kitty = kitty
        this.enabled = false
    }

    public StartAi() {
        this.enabled = true
        this.ResumeAi()
    }

    public ResumeAi() {
        if (!this.enabled) return

        if (this.moveTimer === null) {
            this.moveTimer = Timer.create()
            this.moveTimer.start(
                this.timerInterval,
                true,
                ErrorHandler.Wrap(() => this.PollMovement())
            )
        }

        // If I revive release me from the claimedKitties
        if (this.claimedKitties.has(this.kitty)) {
            this.claimedKitties.delete(this.kitty)
        }
    }

    public StopAi() {
        this.enabled = false
        this.PauseAi()
    }

    public PauseAi() {
        this.lastCommand = ''
        this.lastX = 0
        this.lastY = 0
        this.hasLastOrder = false
        this.lastOrderTime = 0
        this.elapsedTime = 0

        if (this.moveTimer !== null) {
            this.moveTimer.pause()
            this.moveTimer.destroy()
        }

        DestroyLightning(this.lastLightning)

        this.HideAllLightnings()
        this.HideAllFreeLightnings()

        // If I die release my target from the claimedKitties
        if (this.claimedKitties.has(this.kitty)) {
            this.claimedKitties.delete(this.kitty)
        }
    }

    public IsEnabled(): boolean {
        return this.enabled
    }

    private CalcProgressZone(kitty: Kitty) {
        let currentProgressZoneId = kitty.ProgressZone

        if (this.IsInSafeZone(kitty.Unit.x, kitty.Unit.y, currentProgressZoneId + 1)) {
            currentProgressZoneId++
        }

        return currentProgressZoneId
    }

    private MoveKittyToPosition() {
        let currentProgressZoneId = this.CalcProgressZone(this.kitty)
        let currentSafezone = Globals.SAFE_ZONES[currentProgressZoneId]
        let nextSafezone =
            currentProgressZoneId + 1 < Globals.SAFE_ZONES.length - 1
                ? Globals.SAFE_ZONES[currentProgressZoneId + 1]
                : currentSafezone
        let currentSafezoneCenter = this.GetCenterPositionInSafezone(currentSafezone)
        let nextSafezoneCenter = this.GetCenterPositionInSafezone(nextSafezone)

        let currentSafeZoneId: number | null = this.IsInSafeZone(
            this.kitty.Unit.x,
            this.kitty.Unit.y,
            currentProgressZoneId
        )
            ? currentProgressZoneId
            : null

        if (currentSafeZoneId !== this.lastSafeZoneIndexId) {
            this.reachedLastProgressZoneCenter = currentSafeZoneId === null
            this.lastSafeZoneIndexId = currentSafeZoneId
        }

        let distanceToCurrentCenter = Math.sqrt(
            Math.pow(this.kitty.Unit.x - currentSafezoneCenter[0], 2) +
                Math.pow(this.kitty.Unit.y - currentSafezoneCenter[1], 2)
        )
        let SAFEZONE_THRESHOLD: number = 128.0

        if (distanceToCurrentCenter <= SAFEZONE_THRESHOLD) {
            this.reachedLastProgressZoneCenter = true
        }

        let allKittiesAtSameOrHigherSafezone: boolean = true // IEnumberable is dog shit for C# -> Lua conversion, this should -help-
        for (let i: number = 0; i < Globals.ALL_KITTIES_LIST.length; i++) {
            let k = Globals.ALL_KITTIES_LIST[i]
            if (!PROD && k.Player === MapPlayer.fromIndex(0)!) {
                continue
            }

            if (this.CalcProgressZone(k) < currentProgressZoneId) {
                allKittiesAtSameOrHigherSafezone = false
                break
            }
        }

        let targetPosition =
            this.reachedLastProgressZoneCenter && allKittiesAtSameOrHigherSafezone
                ? nextSafezoneCenter
                : currentSafezoneCenter

        for (let [_, circle] of Globals.ALL_CIRCLES) {
            let deadKitty = Globals.ALL_KITTIES.get(circle.Player)!
            let deadKittyProgressZoneId = this.CalcProgressZone(deadKitty)

            if (deadKittyProgressZoneId > currentProgressZoneId) {
                continue
            }

            if (deadKitty === this.kitty) {
                continue
            }

            if (!deadKitty.isAlive()) {
                if (!this.claimedKitties.has(deadKitty)) {
                    let thisDistance: number = Math.sqrt(
                        Math.pow(this.kitty.Unit.x - deadKitty.Unit.x, 2) +
                            Math.pow(this.kitty.Unit.y - deadKitty.Unit.y, 2)
                    )
                    let thisLaneDiff: number = Math.abs(currentProgressZoneId - deadKittyProgressZoneId)

                    let isNearest: boolean = true

                    for (let i: number = 0; i < Globals.ALL_KITTIES_LIST.length; i++) {
                        let otherKitty = Globals.ALL_KITTIES_LIST[i]
                        if (!PROD && otherKitty.Player === MapPlayer.fromIndex(0)!) {
                            continue
                        }

                        if (otherKitty !== this.kitty && otherKitty.isAlive()) {
                            let otherDistance: number = Math.sqrt(
                                Math.pow(otherKitty.Unit.x - deadKitty.Unit.x, 2) +
                                    Math.pow(otherKitty.Unit.y - deadKitty.Unit.y, 2)
                            )
                            let otherLaneDiff: number = Math.abs(
                                this.CalcProgressZone(otherKitty) - deadKittyProgressZoneId
                            )

                            // Prioritize by lane difference first, then by distance.
                            // Don't think this works for some reason..
                            if (
                                otherLaneDiff < thisLaneDiff ||
                                (otherLaneDiff === thisLaneDiff && otherDistance < thisDistance)
                            ) {
                                isNearest = false
                                break
                            }
                        }
                    }

                    if (isNearest) {
                        this.claimedKitties.set(deadKitty, this.kitty)
                    }
                }

                if (this.claimedKitties.has(deadKitty) && this.claimedKitties.get(deadKitty) === this.kitty) {
                    if (deadKittyProgressZoneId !== currentProgressZoneId) {
                        if (
                            this.IsInSafeZone(this.kitty.Unit.x, this.kitty.Unit.y, currentProgressZoneId) &&
                            this.reachedLastProgressZoneCenter
                        ) {
                            targetPosition =
                                currentProgressZoneId - 1 >= 0
                                    ? this.GetCenterPositionInSafezone(Globals.SAFE_ZONES[currentProgressZoneId - 1])
                                    : currentSafezoneCenter
                        } else {
                            targetPosition = currentSafezoneCenter
                        }

                        break
                    }

                    targetPosition = [circle.Unit.x, circle.Unit.y]
                    break
                }
            }
        }

        let wolvesInLane = WolfArea.WolfAreas.get(currentProgressZoneId)!.Wolves

        this.wolvesInRange = []
        for (let i: number = 0; i < wolvesInLane.length; i++) {
            let wolf = wolvesInLane[i]
            if (
                this.IsWithinRadius(
                    this.kitty.Unit.x,
                    this.kitty.Unit.y,
                    wolf.Unit.x,
                    wolf.Unit.y,
                    wolf.IsWalking ? this.DODGE_RADIUS : this.DODGE_RADIUS_STILL
                )
            ) {
                this.wolvesInRange.push(wolf)
            }
        }

        let forwardDirection: [number, number] = [
            targetPosition[0] - this.kitty.Unit.x,
            targetPosition[1] - this.kitty.Unit.y,
        ]

        if (this.wolvesInRange.length > 0) {
            let dodgePosition = this.GetCompositeDodgePosition(this.wolvesInRange, forwardDirection) // TODO; Cleanup:             let dodgePosition = GetCompositeDodgePosition(wolvesInRange, ref forwardDirection);
            this.IssueOrder('move', dodgePosition[0], dodgePosition[1], true)
            return
        } else {
            this.HideAllLightnings()
            this.HideAllFreeLightnings()
        }

        let deltaX = targetPosition[0] - this.kitty.Unit.x
        let deltaY = targetPosition[1] - this.kitty.Unit.y
        let distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY)
        if (distance > 256) {
            let scale = 256 / distance
            let moveX = this.kitty.Unit.x + deltaX * scale
            let moveY = this.kitty.Unit.y + deltaY * scale
            this.IssueOrder('move', moveX, moveY, false)
        } else {
            this.IssueOrder('move', targetPosition[0], targetPosition[1], false)
        }
    }

    private IsWithinLaneBounds(x: number, y: number) {
        let currentProgressZoneId = this.kitty.ProgressZone
        let laneBounds = WolfArea.WolfAreas.get(currentProgressZoneId)!.Rectangle

        const width = laneBounds.maxX - laneBounds.minX
        const height = laneBounds.maxY - laneBounds.minY

        // Assume a vertical lane if its width is less than its height.
        if (width < height) {
            // Vertical lane: check only the y coordinate.
            return x >= laneBounds.minX && x <= laneBounds.maxX
        } else {
            // Horizontal lane: check only the x coordinate.
            return y >= laneBounds.minY && y <= laneBounds.maxY
        }
    }

    private IsInSafeZone(x: number, y: number, safeZoneId: number) {
        if (safeZoneId < 0 || safeZoneId >= Globals.SAFE_ZONES.length) {
            return false // prevent out of bounds errors xd
        }
        let safezone = Globals.SAFE_ZONES[safeZoneId]

        return (
            x >= safezone.Rectangle.minX &&
            x <= safezone.Rectangle.maxX &&
            y >= safezone.Rectangle.minY &&
            y <= safezone.Rectangle.maxY
        )
    }

    private IssueOrder(command: string, x: number, y: number, isDodge: boolean) {
        let MIN_MOVE_DISTANCE: number = isDodge ? 16.0 : 64.0

        if (command === 'move') {
            if (this.lastLightning !== null) {
                MoveLightning(this.lastLightning, false, this.kitty.Unit.x, this.kitty.Unit.y, x, y)
            } else {
                if (this.laser) {
                    this.lastLightning = AddLightning('DRAM', false, this.kitty.Unit.x, this.kitty.Unit.y, x, y)!
                }
            }
        }

        let deltaX: number = x - this.lastX
        let deltaY: number = y - this.lastY
        let distanceSquared: number = deltaX * deltaX + deltaY * deltaY

        if (
            this.hasLastOrder &&
            this.lastCommand === command &&
            distanceSquared < MIN_MOVE_DISTANCE * MIN_MOVE_DISTANCE
        ) {
            if (this.elapsedTime - this.lastOrderTime < 4) {
                return
            }
        }

        this.lastCommand = command
        this.lastX = x
        this.lastY = y
        this.lastOrderTime = this.elapsedTime
        this.hasLastOrder = true
        this.kitty.Unit.issueOrderAt(command, x, y)
    }

    private IssueOrderBasic(command: string) {
        this.lastCommand = command
        this.lastX = -1
        this.lastY = -1
        this.lastOrderTime = this.elapsedTime
        this.hasLastOrder = true
        this.kitty.Unit.issueImmediateOrder(command)
    }

    private GetCenterPositionInSafezone(safezone: Safezone) {
        let centerX = (safezone.Rectangle.minX + safezone.Rectangle.maxX) / 2
        let centerY = (safezone.Rectangle.minY + safezone.Rectangle.maxY) / 2
        return [centerX, centerY]
    }

    /**
     * the: wall: to: be: within: range: For of kitty: the, what: has: to: basically happen is that a line passes through the circle at two points.
     * the: mathematical: formula: for: a: line: passing: through: two: points: Using on a circle, this can be calculated.
     */
    CalcCrossingPoints() {
        for (let i: number = 0; i < this.wallPoints.length; i++) {
            let point = this.wallPoints[i]
            point.dispose()
        }

        this.wallPoints = []

        let dodgeRange = this.DODGE_DISTANCE * (this.timerInterval + 0.2)
        let currentProgressZoneId = this.kitty.ProgressZone
        let laneBounds = WolfArea.WolfAreas.get(currentProgressZoneId)!.Rectangle

        const width = laneBounds.maxX - laneBounds.minX
        const height = laneBounds.maxY - laneBounds.minY

        let isVertical: boolean = width < height

        if (isVertical) {
            // Handle vertical walls (left/right) as before.
            let constant: number = Number.NaN
            if (this.kitty.Unit.x - dodgeRange < laneBounds.minX) constant = laneBounds.minX
            else if (this.kitty.Unit.x + dodgeRange > laneBounds.maxX) constant = laneBounds.maxX
            else return

            let relativeY: number = Math.sqrt(dodgeRange * dodgeRange - Math.pow(this.kitty.Unit.x - constant, 2))
            if (!Number.isNaN(relativeY) && relativeY !== 0) {
                let a = MemoryHandler.getEmptyObject<Point>()
                a.x = constant
                a.y = relativeY + this.kitty.Unit.y
                this.wallPoints.push(a)

                let b = MemoryHandler.getEmptyObject<Point>()
                b.x = constant
                b.y = -relativeY + this.kitty.Unit.y
                this.wallPoints.push(b)
            }
        } else {
            let constant: number = Number.NaN
            if (this.kitty.Unit.y + dodgeRange > laneBounds.maxY) constant = laneBounds.maxY
            else if (this.kitty.Unit.y - dodgeRange < laneBounds.minY) constant = laneBounds.minY
            else return

            let relativeX: number = Math.sqrt(dodgeRange * dodgeRange - Math.pow(this.kitty.Unit.y - constant, 2))
            if (!Number.isNaN(relativeX) && relativeX !== 0) {
                let a = MemoryHandler.getEmptyObject<Point>()
                a.x = relativeX + this.kitty.Unit.x
                a.y = constant
                this.wallPoints.push(a)

                let b = MemoryHandler.getEmptyObject<Point>()
                b.x = -relativeX + this.kitty.Unit.x
                b.y = constant
                this.wallPoints.push(b)
            }
        }

        return
    }

    /**
     * function: find: the: angle: formed: among: two: points: This of circumference: the
     * the: center: on: the: X: axis: and
     */
    AnglesFromCenter(pointA: [number, number], pointB: [number, number]) {
        let angleA: number = this.AngleOf(pointA, [this.kitty.Unit.x, this.kitty.Unit.y])
        let angleB: number = this.AngleOf(pointB, [this.kitty.Unit.x, this.kitty.Unit.y])
        return [angleA, angleB]
    }

    AngleOf(point: [number, number], center: [number, number]) {
        let deltaX: number = point[0] - center[0]
        let deltaY: number = point[1] - center[1]
        let radians: number = Math.atan2(deltaY, deltaX)
        return this.NormalizeAngle(radians)
    }

    // Rewritten GetCompositeDodgePosition using a reusable struct array instead of creating new objects.
    private GetCompositeDodgePosition(wolves: Wolf[], forwardDirection: [number, number]) {
        // TODO; Cleanup:     private (number X, number Y) GetCompositeDodgePosition(wolves: Wolf[], ref (number X, number Y) forwardDirection)
        let forwardAngle: number = this.NormalizeAngle(Math.atan2(forwardDirection[1], forwardDirection[0]))
        let requiredClearance: number = 22.5 * (Math.PI / 180)

        // Calculate the angle interval that each wolf “blocks.”
        for (let i: number = 0; i < wolves.length; i++) {
            let wolf: Wolf = wolves[i]

            let MIN_TOTAL_BLOCKED_ANGLE: number = 45.0 * (Math.PI / 180)
            let MAX_TOTAL_BLOCKED_ANGLE: number = 270.0 * (Math.PI / 180)

            if (!wolf.IsWalking) {
                MIN_TOTAL_BLOCKED_ANGLE = 30.0 * (Math.PI / 180)
                MAX_TOTAL_BLOCKED_ANGLE = 150.0 * (Math.PI / 180)
            }

            let dx: number = wolf.Unit.x - this.kitty.Unit.x
            let dy: number = wolf.Unit.y - this.kitty.Unit.y
            let distance: number = Math.sqrt(dx * dx + dy * dy)

            if (distance < 1) continue // Skip if the wolf is at the same position to avoid division by zero

            let centerAngle: number = Math.atan2(wolf.Unit.y - this.kitty.Unit.y, wolf.Unit.x - this.kitty.Unit.x)
            let clampedDistance: number = clamp(distance, DEFAULT_WOLF_COLLISION_RADIUS, this.DODGE_RADIUS)
            let ratio: number =
                (clampedDistance - DEFAULT_WOLF_COLLISION_RADIUS) / (this.DODGE_RADIUS - DEFAULT_WOLF_COLLISION_RADIUS)

            let totalBlockedAngle: number =
                MIN_TOTAL_BLOCKED_ANGLE + (MAX_TOTAL_BLOCKED_ANGLE - MIN_TOTAL_BLOCKED_ANGLE) * (1 - ratio)
            let halfAngle: number = totalBlockedAngle / 2

            // Create the interval [centerAngle - halfAngle, centerAngle + halfAngle]
            let start: number = this.NormalizeAngle(centerAngle - halfAngle)
            let end: number = this.NormalizeAngle(centerAngle + halfAngle)

            // If the interval wraps around 0, split it into two parts.
            if (start > end) {
                let a = MemoryHandler.getEmptyObject<AngleInterval>()
                a.Start = start
                a.End = 2 * Math.PI
                this.blockedIntervals.push(a)

                let b = MemoryHandler.getEmptyObject<AngleInterval>()
                b.Start = 0
                b.End = end
                this.blockedIntervals.push(b)
            } else {
                let a = MemoryHandler.getEmptyObject<AngleInterval>()
                a.Start = start
                a.End = end
                this.blockedIntervals.push(a)
            }
        }

        this.CalcCrossingPoints()

        if (this.wallPoints.length === 2) {
            let [angleA, angleB] = this.AnglesFromCenter(
                [this.wallPoints[0].x, this.wallPoints[0].y],
                [this.wallPoints[1].x, this.wallPoints[1].y]
            )

            if (angleA > angleB) {
                let temp: number = angleA
                angleA = angleB
                angleB = temp
            }

            let start: number
            let end: number

            if (angleB - angleA > 180.0 * (Math.PI / 180)) {
                start = angleB
                end = angleA
            } else {
                start = angleA
                end = angleB
            }

            // If the interval wraps around 0, split it into two parts.
            if (start > end) {
                let a = MemoryHandler.getEmptyObject<AngleInterval>()
                a.Start = start
                a.End = 2 * Math.PI
                this.blockedIntervals.push(a)

                let b = MemoryHandler.getEmptyObject<AngleInterval>()
                b.Start = 0
                b.End = end
                this.blockedIntervals.push(b)
            } else {
                let a = MemoryHandler.getEmptyObject<AngleInterval>()
                a.Start = start
                a.End = end
                this.blockedIntervals.push(a)
            }
        }

        // Merge any overlapping blocked intervals.
        this.MergeIntervals(this.blockedIntervals)

        // Visualize the blocked intervals
        this.HideAllLightnings()
        for (let i: number = 0; i < this.mergedIntervals.length; i++) {
            this.VisualizeBlockedInterval(this.mergedIntervals[i])
        }

        // Determine free angular gaps on the circle.
        if (this.mergedIntervals.length === 0) {
            // No wolves blocking any direction; entire circle is free.
            let a = MemoryHandler.getEmptyObject<AngleInterval>()
            a.Start = 0
            a.End = 2 * Math.PI
            this.freeGaps.push(a)
        } else {
            // Ensure the merged intervals are sorted by their start angle.
            //mergedIntervals.Sort((a, b) => a.Start.CompareTo(b.Start));
            this.SortAngleIntervals(this.mergedIntervals)

            // The gap between the end of the last interval and the start of the first (accounting for wrap-around).
            let wrapGap: number =
                this.mergedIntervals[0].Start + 2 * Math.PI - this.mergedIntervals[this.mergedIntervals.length - 1].End
            if (wrapGap > 0) {
                let a = MemoryHandler.getEmptyObject<AngleInterval>()
                a.Start = this.mergedIntervals[this.mergedIntervals.length - 1].End
                a.End = this.mergedIntervals[0].Start + 2 * Math.PI
                this.freeGaps.push(a)
            }
            // Gaps between consecutive intervals.
            for (let i: number = 0; i < this.mergedIntervals.length - 1; i++) {
                let gapSize: number = this.mergedIntervals[i + 1].Start - this.mergedIntervals[i].End
                if (gapSize > 0) {
                    let a = MemoryHandler.getEmptyObject<AngleInterval>()
                    a.Start = this.mergedIntervals[i].End
                    a.End = this.mergedIntervals[i + 1].Start
                    this.freeGaps.push(a)
                }
            }
        }

        // Visualize the free intervals
        this.HideAllFreeLightnings()
        for (let i: number = 0; i < this.freeGaps.length; i++) {
            let interval = this.freeGaps[i]
            this.VisualizeFreeInterval(interval)
        }

        let targetX: number = this.kitty.Unit.x + Math.cos(forwardAngle) * this.DODGE_DISTANCE
        let targetY: number = this.kitty.Unit.y + Math.sin(forwardAngle) * this.DODGE_DISTANCE

        let bestCandidateScore: number = int.MaxValue
        let bestCandidateAngle: number = -500 // Default to the original forward angle

        for (let i: number = 0; i < AIController.offsets.length; i++) {
            let offset: number = AIController.offsets[i]
            let candidateAngle: number = this.NormalizeAngle(forwardAngle + offset)

            let bestAngle: number = this.calcAngle(candidateAngle, requiredClearance)

            if (bestAngle === -500) {
                continue
            }

            let candX: number = this.kitty.Unit.x + Math.cos(bestAngle) * this.DODGE_DISTANCE
            let candY: number = this.kitty.Unit.y + Math.sin(bestAngle) * this.DODGE_DISTANCE

            let dx: number = Math.abs(candX - targetX)
            let dy: number = Math.abs(candY - targetY)
            let score: number = dx * dx + dy * dy

            if (score < bestCandidateScore) {
                bestCandidateScore = score
                bestCandidateAngle = bestAngle
            }
        }

        if (bestCandidateAngle === -500) {
            this.cleanArrays()
            return [this.kitty.Unit.x, this.kitty.Unit.y]
        }

        // Update the forward direction to the chosen dodge direction.
        let forwardDirection2 = [Math.cos(bestCandidateAngle), Math.sin(bestCandidateAngle)]

        this.cleanArrays()

        // Return the target dodge position (kitty's position plus 128 in the chosen direction).
        return [
            this.kitty.Unit.x + forwardDirection2[0] * this.DODGE_DISTANCE,
            this.kitty.Unit.y + forwardDirection2[1] * this.DODGE_DISTANCE,
        ]
    }

    private calcAngle(forwardAngle: number, requiredClearance: number) {
        // Initialize bestAngle to the original forward direction
        let bestAngle: number = -500
        let foundGapContainingForward: boolean = false

        // First, check if forwardAngle falls within any free gap.
        for (let i: number = 0; i < this.freeGaps.length; i++) {
            let gap: AngleInterval = this.freeGaps[i]

            if (gap.End - gap.Start < requiredClearance) {
                continue
            }

            if (this.IsAngleInInterval(forwardAngle, gap)) {
                foundGapContainingForward = true
                // Calculate the distance from forwardAngle to the gap boundaries.
                let diffToStart: number = this.AngleDifference(forwardAngle, gap.Start)
                let diffToEnd: number = this.AngleDifference(gap.End, forwardAngle)

                // If too close to the start boundary, adjust forwardAngle to be 45° inside.
                if (diffToStart < requiredClearance) {
                    bestAngle = gap.Start + requiredClearance
                }
                // If too close to the end boundary, adjust forwardAngle to be 45° inside.
                else {
                    if (diffToEnd < requiredClearance) {
                        bestAngle = gap.End - requiredClearance
                    } else {
                        bestAngle = forwardAngle // It’s safely in the middle.
                    }
                }
                break
            }
        }

        // If forwardAngle isn't within any free gap, find the candidate edge closest to forwardAngle.
        if (!foundGapContainingForward) {
            let bestScore: number = int.MaxValue
            for (
                let i: number = 0;
                i < this.freeGaps.length;
                i++ // Replacing for with for loop
            ) {
                let gap: AngleInterval = this.freeGaps[i] // Accessing the element by index

                if (gap.End - gap.Start < requiredClearance) {
                    continue
                }

                // Calculate candidate angles from each gap’s boundaries (adjusted by required clearance).
                let candidateFromStart: number = this.NormalizeAngle(gap.Start + requiredClearance)
                let candidateFromEnd: number = this.NormalizeAngle(gap.End - requiredClearance)

                let diffStart: number = this.AngleDifference(forwardAngle, candidateFromStart)
                let diffEnd: number = this.AngleDifference(candidateFromEnd, forwardAngle)

                if (diffStart < bestScore) {
                    bestScore = diffStart
                    bestAngle = candidateFromStart
                }

                if (diffEnd < bestScore) {
                    bestScore = diffEnd
                    bestAngle = candidateFromEnd
                }
            }
        }

        return bestAngle
    }

    private IsAngleInInterval(angle: number, interval: AngleInterval) {
        // Normalize the angle and interval boundaries to [0, 2π)
        angle = this.NormalizeAngle(angle)
        let start: number = this.NormalizeAngle(interval.Start)
        let end: number = this.NormalizeAngle(interval.End)

        // Check if the interval does not wrap around.
        if (start <= end) {
            return angle >= start && angle <= end
        }
        // If the interval wraps around 0 (e.g., 350° to 10°), the angle is within the interval
        // if it's greater than or equal to the start OR less than or equal to the end.
        return angle >= start || angle <= end
    }

    private cleanArrays() {
        for (let i: number = 0; i < this.blockedIntervals.length; i++) {
            this.blockedIntervals[i].dispose()
        }
        this.blockedIntervals = []

        for (let i: number = 0; i < this.freeGaps.length; i++) {
            this.freeGaps[i].dispose()
        }
        this.freeGaps = []

        // Clear mergedIntervals without destroying references
        this.mergedIntervals = []
    }

    private VisualizeBlockedInterval(interval: AngleInterval) {
        if (!this.laser) {
            return
        }

        let radius: number = this.DODGE_RADIUS
        let step: number = 0.1 // Adjust step size for smoother lines
        for (let angle: number = interval.Start; angle < interval.End; angle += step) {
            let x1: number = this.kitty.Unit.x + radius * Math.cos(angle)
            let y1: number = this.kitty.Unit.y + radius * Math.sin(angle)
            let x2: number = this.kitty.Unit.x + radius * Math.cos(angle + step)
            let y2: number = this.kitty.Unit.y + radius * Math.sin(angle + step)

            //
            let freeLightning: lightning | null = null

            if (this.availableBlockedLightnings.length > 0) {
                freeLightning = this.availableBlockedLightnings[this.availableBlockedLightnings.length - 1]
                this.availableBlockedLightnings.splice(this.availableBlockedLightnings.length - 1, 1)
            }

            if (freeLightning === null) {
                freeLightning = AddLightning(AIController.BLOCKED_LASER_COLOR, false, x1, y1, x2, y2)! // "AFOD" is finger of death code
            }

            this.usedBlockedLightnings.push(freeLightning)
            MoveLightning(freeLightning, false, x1, y1, x2, y2)
        }
    }

    private VisualizeFreeInterval(interval: AngleInterval) {
        if (!this.laser) {
            return
        }

        let radius: number = this.DODGE_RADIUS
        let step: number = 0.1 // Adjust step size for smoother lines
        for (let angle: number = interval.Start; angle < interval.End; angle += step) {
            let x1: number = this.kitty.Unit.x + radius * Math.cos(angle)
            let y1: number = this.kitty.Unit.y + radius * Math.sin(angle)
            let x2: number = this.kitty.Unit.x + radius * Math.cos(angle + step)
            let y2: number = this.kitty.Unit.y + radius * Math.sin(angle + step)

            //
            let freeLightning: lightning | null = null

            if (this.availableClearLightnings.length > 0) {
                freeLightning = this.availableClearLightnings[this.availableClearLightnings.length - 1]
                this.availableClearLightnings.splice(this.availableClearLightnings.length - 1, 1)
            }

            if (freeLightning === null) {
                freeLightning = AddLightning(AIController.FREE_LASER_COLOR, false, x1, y1, x2, y2)!
            }

            this.usedClearLightnings.push(freeLightning)
            MoveLightning(freeLightning, false, x1, y1, x2, y2)
        }
    }

    private HideAllLightnings() {
        for (let i: number = 0; i < this.usedBlockedLightnings.length; i++) {
            let lightning = this.usedBlockedLightnings[i]
            MoveLightning(lightning, false, 0.0, 0.0, 0.0, 0.0)
            this.availableBlockedLightnings.push(lightning)
        }

        this.usedBlockedLightnings = []
    }

    private HideAllFreeLightnings() {
        for (let i: number = 0; i < this.usedClearLightnings.length; i++) {
            let lightning = this.usedClearLightnings[i]
            MoveLightning(lightning, false, 0.0, 0.0, 0.0, 0.0)
            this.availableClearLightnings.push(lightning)
        }

        this.usedClearLightnings = []
    }

    /// <summary>
    /// Normalizes an angle (in radians) to the range [0, 2π).
    /// </summary>
    private NormalizeAngle(angle: number) {
        while (angle < 0) angle += 2 * Math.PI
        while (angle >= 2 * Math.PI) angle -= 2 * Math.PI
        return angle
    }

    /// <summary>
    /// Returns the smallest difference (in radians) between two angles.
    /// </summary>
    private AngleDifference(a: number, b: number) {
        let diff: number = ((a - b + Math.PI) % (2 * Math.PI)) - Math.PI
        return Math.abs(diff)
    }

    private SortAngleIntervals(intervals: AngleInterval[]) {
        for (let i: number = 0; i < intervals.length - 1; i++) {
            for (let j: number = 0; j < intervals.length - i - 1; j++) {
                if (intervals[j].Start > intervals[j + 1].Start) {
                    // Swap intervals[j] and intervals[j + 1]
                    let temp = intervals[j]
                    intervals[j] = intervals[j + 1]
                    intervals[j + 1] = temp
                }
            }
        }
    }

    /// <summary>
    /// Merges overlapping angular intervals.
    /// </summary>
    private MergeIntervals(intervals: AngleInterval[]) {
        this.SortAngleIntervals(intervals)

        let current: AngleInterval = intervals[0]

        for (let i: number = 1; i < intervals.length; i++) {
            if (this.IsAngleInInterval(intervals[i].Start, current)) {
                // Extend the current interval if needed.
                current.End = Math.max(current.End, intervals[i].End)
            } else {
                this.mergedIntervals.push(current)
                current = intervals[i]
            }
        }

        this.mergedIntervals.push(current)
    }

    private IsWithinRadius(x1: number, y1: number, x2: number, y2: number, radius: number) {
        let distance = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1))
        return distance <= radius
    }

    private PollMovement() {
        if (!this.enabled) return
        this.elapsedTime += this.timerInterval
        this.LearnSkills()
        this.UseWindWalkIfAvailable()
        this.MoveKittyToPosition()
    }

    private LearnSkills() {
        if (this.kitty.Unit.skillPoints > 0) {
            this.kitty.Unit.selectSkill(Constants.ABILITY_WIND_WALK)
            this.kitty.Unit.selectSkill(Constants.ABILITY_AGILITY_AURA)
            this.kitty.Unit.selectSkill(Constants.ABILITY_ENERGY_AURA)
        }
    }

    private UseWindWalkIfAvailable() {
        let wwLvl = GetUnitAbilityLevel(this.kitty.Unit.handle, Constants.ABILITY_WIND_WALK)

        if (
            wwLvl === 0 ||
            (wwLvl === 1 && this.kitty.Unit.mana < 75) ||
            (wwLvl === 2 && this.kitty.Unit.mana < 60) ||
            (wwLvl === 3 && this.kitty.Unit.mana < 45)
        ) {
            return
        }

        if (UnitHasBuffBJ(this.kitty.Unit.handle, AIController.WindwalkID)) return

        this.IssueOrderBasic('windwalk')
    }
}

/// <summary>
/// Helper class representing an angular interval [Start, End] in radians.
/// </summary>
export class AngleInterval extends IDisposable {
    public Start = 0
    public End = 0

    public constructor() {
        super()
    }

    public dispose() {
        MemoryHandler.destroyObject(this)
    }
}

export class Point extends IDisposable {
    public x = 0
    public y = 0

    public constructor() {
        super()
    }

    public dispose() {
        MemoryHandler.destroyObject(this)
    }
}
