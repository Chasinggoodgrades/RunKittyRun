import { Constants } from 'src/AutoGenerated/Constants'
import { Logger } from 'src/Events/Logger/Logger'
import { Wolf } from 'src/Game/Entities/Wolf'
import { Globals } from 'src/Global/Globals'
import { RegionList } from 'src/Global/RegionList'
import { Colors } from 'src/Utility/Colors/Colors'
import { FilterList } from 'src/Utility/FilterList'
import { GC } from 'src/Utility/GC'
import { AchesTimers, createAchesTimer } from 'src/Utility/MemoryHandler/AchesTimers'
import { distanceBetweenXYPoints, TargetTypes } from 'src/Utility/Utility'
import { getTriggerUnit } from 'src/Utility/w3tsUtils'
import { Effect, Group, Trigger, Unit } from 'w3ts'
import { Affix } from './Affix'

export class Fixation extends Affix {
    private FIXATION_RADIUS = 500.0
    private FIXATION_MS = 325.0
    private FIXATION_MAX_MS = 410.0
    private FIXATION_TARGET_EFFECT: string = 'Abilities\\Spells\\Undead\\DeathCoil\\DeathCoilMissile.mdl'

    private static readonly IsFixation = (r: Affix): r is Fixation => {
        return r instanceof Fixation
    }

    private AFFIX_ABILITY = Constants.ABILITY_FIXATION
    private InRangeTrigger: Trigger
    private PeriodicSpeed: Trigger
    private ChaseTimer: AchesTimers
    private UnitsInRange: Group
    private Target: Unit
    private Type = 0
    private IsChasing: boolean = false
    private TargetEffect: Effect

    public constructor(unit: Wolf) {
        super(unit)
        this.InRangeTrigger ??= Trigger.create()!
        this.PeriodicSpeed ??= Trigger.create()!
        this.ChaseTimer = createAchesTimer()
        this.name = `${Colors.COLOR_RED}Fixation|r`
    }

    public override Apply = () => {
        this.Type = this.RandomType()
        this.Unit.Unit.moveSpeed = this.FIXATION_MS
        this.Unit.Unit.setVertexColor(255, 0, 0, 255)
        this.Unit.Unit.addAbility(this.AFFIX_ABILITY)
        this.Unit.Unit.setField(UNIT_IF_TARGETED_AS, TargetTypes.Ward)
        this.RegisterEvents()
        this.Unit.WolfArea.FixationCount += 1
    }

    public override Remove = () => {
        this.Unit.Unit.moveSpeed = this.Unit.Unit.defaultMoveSpeed
        this.Unit.Unit.removeAbility(this.AFFIX_ABILITY)
        this.Unit.Unit.setField(UNIT_IF_TARGETED_AS, TargetTypes.Ground)
        this.Unit.Unit.setVertexColor(150, 120, 255, 255)
        this.IsChasing = false

        GC.RemoveTrigger(this.InRangeTrigger) // TODO; Cleanup:         GC.RemoveTrigger(ref InRangeTrigger);
        GC.RemoveTrigger(this.PeriodicSpeed) // TODO; Cleanup:         GC.RemoveTrigger(ref PeriodicSpeed);
        this.ChaseTimer?.dispose()
        this.ChaseTimer = null as never
        GC.RemoveGroup(this.UnitsInRange) // TODO; Cleanup:         GC.RemoveGroup(ref UnitsInRange);
        GC.RemoveEffect(this.TargetEffect) // TODO; Cleanup:         GC.RemoveEffect(ref TargetEffect);
        if (this.Unit.WolfArea.FixationCount > 0) this.Unit.WolfArea.FixationCount -= 1
        this.Unit.WanderTimer?.resume()
    }

    /// <summary>
    /// Type for the fixation...
    /// #0 being pick a player and chase them
    /// #1 being pick player in shortest range and chase them
    /// </summary>
    /// <returns></returns>
    private RandomType(): number {
        return GetRandomInt(0, 1)
    }

    private RegisterEvents = () => {
        if (this.Type === 1) this.UnitsInRange ??= Group.create()!
        this.InRangeTrigger.registerUnitInRage(this.Unit.Unit.handle, this.FIXATION_RADIUS, FilterList.KittyFilter)
        this.PeriodicSpeed.registerTimerEvent(0.1, true)
        this.PeriodicSpeed.addAction(() => this.UpdateChaseSpeed())
        this.InRangeTrigger.addAction(() => {
            try {
                const target = getTriggerUnit()
                const Region = RegionList.WolfRegions[this.Unit.RegionIndex]
                if (!Region.includes(target.x, target.y)) return
                if (this.Unit.paused) return
                if (target !== this.Unit.Unit && !this.IsChasing) {
                    this.Target = target
                    this.ChasingEvent()
                }
            } catch (e: any) {
                Logger.Warning(`Error in Fixation.InRangeTrigger: ${e}`)
            }
        })
    }

    private ChasingEvent = () => {
        const Region = RegionList.WolfRegions[this.Unit.RegionIndex]
        this.IsChasing = true
        this.Unit.WanderTimer?.pause()
        this.TargetEffect = Effect.createAttachment(this.FIXATION_TARGET_EFFECT, this.Target, 'overhead')!
        this.ChaseTimer.start(0.1, true, () => {
            if (!this.Target.isAlive() || !Region.includes(this.Target.x, this.Target.y)) {
                this.IsChasing = false
                this.Unit.WolfMove()
                GC.RemoveEffect(this.TargetEffect) // TODO; Cleanup:                 GC.RemoveEffect(ref TargetEffect);
                this.Unit.WanderTimer.resume()
                this.ChaseTimer.pause()
                return
            }
            if (this.Type === 1) this.GetClosestTarget()
            this.Unit.Unit.issueOrderAt('move', this.Target.x, this.Target.y)
        })
    }

    private GetClosestTarget = () => {
        this.UnitsInRange.clear()
        this.UnitsInRange.enumUnitsInRange(
            this.Unit.Unit.x,
            this.Unit.Unit.y,
            this.FIXATION_RADIUS,
            FilterList.KittyFilter
        )
        if (this.UnitsInRange.size <= 0) return
        const newTarget = this.GetClosestUnitInRange()
        if (newTarget !== this.Target) {
            this.Target = newTarget
            GC.RemoveEffect(this.TargetEffect) // TODO; Cleanup:             GC.RemoveEffect(ref TargetEffect);
            this.TargetEffect = Effect.createAttachment(this.FIXATION_TARGET_EFFECT, this.Target, 'overhead')!
        }
    }

    private GetClosestUnitInRange(): Unit {
        const unitX = this.Unit.Unit.x
        const unitY = this.Unit.Unit.y

        // Determine closest unit in list
        let closestUnit = this.UnitsInRange.first!
        let closestDistance = distanceBetweenXYPoints(unitX, unitY, closestUnit.x, closestUnit.y)
        if (closestDistance > 0) {
            while (true) {
                const unit = this.UnitsInRange.first
                if (!unit) break
                this.UnitsInRange.removeUnit(unit)
                const distance = distanceBetweenXYPoints(unitX, unitY, unit.x, unit.y)
                if (distance < closestDistance) {
                    closestUnit = unit
                    closestDistance = distance
                }
            }
        }
        return closestUnit
    }

    private UpdateChaseSpeed = () => {
        const currentMS = this.Unit.Unit.moveSpeed
        const speedIncrementer = 0.4 // 4 movespeed every second

        if (this.IsChasing) {
            if (currentMS <= 300) this.Unit.Unit.moveSpeed = this.FIXATION_MS
            if (currentMS >= this.FIXATION_MAX_MS) return

            const newSpeed = currentMS + speedIncrementer

            this.Unit.Unit.moveSpeed = Math.min(newSpeed, this.FIXATION_MAX_MS)
        } else {
            if (currentMS <= this.FIXATION_MS) return

            const newSpeed = currentMS - speedIncrementer / 2 // Decrease by half the rate
            this.Unit.Unit.moveSpeed = Math.max(newSpeed, this.FIXATION_MS)
        }
    }

    public static GetFixation(Unit: Unit): Fixation {
        if (Unit === null) return null as never
        const affix = Globals.ALL_WOLVES.get(Unit)!.Affixes.find(Fixation.IsFixation)
        return affix instanceof Fixation ? affix : (null as never)
    }

    public override pause(pause: boolean) {
        if (pause) {
            BlzUnitClearOrders(this.Unit.Unit.handle, false)
            this.ChaseTimer.pause()
            this.InRangeTrigger.enabled = false
            this.IsChasing = false
            GC.RemoveEffect(this.TargetEffect) // TODO; Cleanup:             GC.RemoveEffect(ref TargetEffect);
        } else {
            this.InRangeTrigger.enabled = true
            this.ChaseTimer.resume()
        }
    }
}
