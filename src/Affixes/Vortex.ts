import { Constants } from 'src/AutoGenerated/Constants'
import { Wolf } from 'src/Game/Entities/Wolf'
import { safeArraySplice } from 'src/Utility/ArrayUtils'
import { Colors } from 'src/Utility/Colors/Colors'
import { ErrorHandler } from 'src/Utility/ErrorHandler'
import { FilterList } from 'src/Utility/FilterList'
import { GC } from 'src/Utility/GC'
import { getTriggerUnit } from 'src/Utility/w3tsUtils'
import { Timer, Trigger, Unit } from 'w3ts'
import { angleBetweenPoints } from '../Utility/Utility'
import { Affix } from './Affix'

/// <summary>
/// -- Periodic
/// -- Pulls Every 30 seconds
/// -- 500 Yd Range..
///
/// -- Have to figure out a way to simulate the gravity effect smoothly..
/// </summary>

export class Vortex extends Affix {
    private AFFIX_ABILITY = Constants.ABILITY_UNPREDICTABLE
    private VORTEX_RADIUS = 500.0 // triggers witihn 500 yds
    private VORTEX_PULL_SPEED = 40.0 // pulls 2 yds per second.
    private VORTEX_PULSE_RATE = 0.4 // every second.
    private VORTEX_PERIODIC_PULL = 30.0 // every 30 seconds
    private VORTEX_LENGTH = 10.0 // lasts 10 seconds.
    private EntersRange: Trigger = Trigger.create()!
    private LeavesRange: Trigger = Trigger.create()!
    private PullingInTimer = Timer.create()
    private PeriodicPull = Timer.create()
    private PullStart = Timer.create()
    private Counter = 0
    private UnitsInRange: Unit[] = []

    public constructor(unit: Wolf) {
        super(unit)
        this.name = `${Colors.COLOR_PURPLE}Vortex|r`
    }

    public override Apply() {
        this.Unit.Unit.addAbility(this.AFFIX_ABILITY)
        this.RegisterEvents()
        super.Apply()
    }

    public override Remove() {
        this.Unit.Unit.removeAbility(this.AFFIX_ABILITY)
        this.Unit.Unit.setVertexColor(150, 120, 255, 255)

        GC.RemoveTimer(this.PullingInTimer) // TODO; Cleanup:         GC.RemoveTimer(ref PullingInTimer);
        GC.RemoveTimer(this.PeriodicPull) // TODO; Cleanup:         GC.RemoveTimer(ref PeriodicPull);
        GC.RemoveTimer(this.PullStart) // TODO; Cleanup:         GC.RemoveTimer(ref PullStart);
        GC.RemoveTrigger(this.EntersRange) // TODO; Cleanup:         GC.RemoveTrigger(ref EntersRange);
        GC.RemoveTrigger(this.LeavesRange) // TODO; Cleanup:         GC.RemoveTrigger(ref LeavesRange);
        GC.RemoveList(this.UnitsInRange) // TODO; Cleanup:         GC.RemoveList(ref UnitsInRange);
        super.Remove()
    }

    public override pause(pause: boolean) {}

    private RegisterEvents() {
        this.EntersRange.registerUnitInRage(this.Unit.Unit.handle, this.VORTEX_RADIUS, FilterList.KittyFilter)
        this.EntersRange.addAction(() => this.EnterRegionActions())
        this.LeavesRange.registerUnitInRage(this.Unit.Unit.handle, this.VORTEX_RADIUS, FilterList.KittyFilter)

        this.PeriodicPull.start(
            this.VORTEX_PERIODIC_PULL,
            true,
            ErrorHandler.Wrap(() => this.PullBegin())
        )
    }

    private EnterRegionActions() {
        const enteringUnit = getTriggerUnit()
        if (this.UnitsInRange.includes(enteringUnit)) return
        this.UnitsInRange.push(enteringUnit)
    }

    private LeavesRegionActions() {
        const leavingUnit = getTriggerUnit()
        if (!this.UnitsInRange.includes(leavingUnit)) return
        safeArraySplice(this.UnitsInRange, p => p === leavingUnit)
    }

    private PullBegin() {
        this.PullStart.start(
            this.VORTEX_PULSE_RATE,
            true,
            ErrorHandler.Wrap(() => this.PullActions())
        )
        this.Unit.Unit.setVertexColor(255, 0, 255, 255)
    }

    private PullActions() {
        if (this.Counter >= this.VORTEX_LENGTH / this.VORTEX_PULSE_RATE) {
            this.ResetVortex()
            return // Exit early if the vortex is reset
        }
        const distance = this.VORTEX_PULL_SPEED * this.VORTEX_PULSE_RATE
        for (const unit of this.UnitsInRange) {
            if (!IsUnitInRange(unit.handle, this.Unit.Unit.handle, this.VORTEX_RADIUS)) continue
            const x = unit.x
            const y = unit.y
            const angle = angleBetweenPoints(this.Unit.Unit.x, this.Unit.Unit.y, x, y)
            const newX = x + distance * Cos(angle)
            const newY = y + distance * Sin(angle)
            unit.setPosition(newX, newY)
            unit.setFacingEx(angle)
            //let lastOrder = UnitOrders.GetLastOrderLocation(unit);
            //unit.IssueOrder("move", lastOrder.x, lastOrder.y);
            // We can set position.. but we need to get the units last move order and issue that move order to that x, y immediately after to stimulate the gravity effect.
            // Setup event system to acquire last x,y location of this unit.
        }
        this.Counter += 1
    }

    private ResetVortex() {
        this.PullStart.pause()
        this.Counter = 0
        this.Unit.Unit.setVertexColor(150, 120, 255, 255)
    }
}
