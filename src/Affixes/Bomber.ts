import { Constants } from 'src/AutoGenerated/Constants'
import { Logger } from 'src/Events/Logger/Logger'
import { Wolf } from 'src/Game/Entities/Wolf'
import { Globals } from 'src/Global/Globals'
import { RangeIndicator } from 'src/SpecialEffects/RangeIndicator'
import { Colors } from 'src/Utility/Colors/Colors'
import { FilterList } from 'src/Utility/FilterList'
import { AchesTimers, createAchesTimer } from 'src/Utility/MemoryHandler/AchesTimers'
import { MemoryHandler } from 'src/Utility/MemoryHandler/MemoryHandler'
import { Utility } from 'src/Utility/Utility'
import { Effect, Group } from 'w3ts'
import { Affix } from './Affix'

export class Bomber extends Affix {
    private AFFIX_ABILITY = Constants.ABILITY_BOMBER // replace with bomber ability in WE later after i make it.
    private EXPLOSION_RANGE = 250.0

    private static readonly IsBomber = (r: Affix): r is Bomber => {
        return r instanceof Bomber
    }

    private static BLOOD_EFFECT_PATH: string = 'war3mapImported\\Bloodstrike.mdx'
    private static RING_TIMER_INDICATOR: string = 'war3mapImported\\RingProgress.mdx'

    private static MIN_EXPLODE_INTERVAL = 10.0
    private static MAX_EXPLODE_INTERVAL = 15.0
    private ExplodeTimer: AchesTimers = createAchesTimer()
    private ReviveAlphaTimer: AchesTimers = createAchesTimer()
    private ExplodeGroup: Group = Group.create()!
    private ReviveAlpha = 1
    private RangeIndicator: RangeIndicator
    private TimerIndicator: Effect

    public constructor(unit: Wolf) {
        super(unit)
        this.name = `${Colors.COLOR_ORANGE}Bomber|r`
    }

    public override Apply = () => {
        try {
            this.Unit.Unit.addAbility(this.AFFIX_ABILITY)
            this.Unit.Unit.setVertexColor(204, 102, 0, 255)
            this.RangeIndicator = MemoryHandler.getEmptyClass(RangeIndicator)
            this.RegisterTimers()
        } catch (e) {
            Logger.Warning(`Error in Bomber.Apply: ${e}`)
        }
    }

    public override Remove = () => {
        this.Unit.Unit.removeAbility(this.AFFIX_ABILITY)
        this.Unit.Unit.setVertexColor(150, 120, 255, 255)

        this.ExplodeTimer?.dispose()
        this.ReviveAlphaTimer?.dispose()
        this.ExplodeTimer = null as never // These two timers are needed as it prevents the start explosion from continuing
        this.ReviveAlphaTimer = null as never
        this.RangeIndicator?.dispose()
        this.RangeIndicator = null as never
        this.TimerIndicator?.destroy()
        this.TimerIndicator = null as never

        if (this.Unit.paused) this.Unit?.PauseSelf(false)
        this.Unit.IsReviving = false
        this.Unit.paused = false
    }

    private RegisterTimers = () => {
        this.ExplodeTimer.Timer.start(Bomber.ExplosionInterval(), false, () => this.StartExplosion())
    }

    private StartExplosion = () => {
        // Temporary for testing, will add an actual graphic ticker later
        try {
            if (this.Unit?.paused) {
                this.ExplodeTimer?.Timer.start(Bomber.ExplosionInterval(), false, () => this.StartExplosion())
                return
            }
            if (!this.RangeIndicator) return
            if (!this.Unit.Unit) return
            this.Unit.PauseSelf(true)
            if (this.Unit.WolfArea.IsEnabled) {
                this.RangeIndicator.CreateIndicator(this.Unit.Unit, this.EXPLOSION_RANGE, 20, 'FINL') // "FINL" is an orange indicator.
                Utility.SimpleTimer(1.0, () =>
                    Utility.CreateSimpleTextTag('3...', 1.0, this.Unit.Unit, 0.025, 255, 0, 0)
                ) // This approach needs to be changed into a class object or something.. This is garbage. 3 lambdas per timer too .. christ.
                Utility.SimpleTimer(2.0, () =>
                    Utility.CreateSimpleTextTag('2...', 1.0, this.Unit.Unit, 0.025, 255, 0, 0)
                )
                Utility.SimpleTimer(3.0, () =>
                    Utility.CreateSimpleTextTag('1...', 1.0, this.Unit.Unit, 0.025, 255, 0, 0)
                )
            }

            Utility.SimpleTimer(4.0, () => this.Explode())
        } catch (e) {
            Logger.Warning(`Error in Bomber.StartExplosion: ${e}`)
        }
    }

    private Explode = () => {
        try {
            if (!this.RangeIndicator) return
            this.RangeIndicator.DestroyIndicator()
            Utility.CreateEffectAndDisposeAttach(Bomber.BLOOD_EFFECT_PATH, this.Unit.Unit, 'origin')
            this.ExplodeGroup.enumUnitsInRange(
                this.Unit.Unit.x,
                this.Unit.Unit.y,
                this.EXPLOSION_RANGE,
                FilterList.KittyFilter
            )

            while (true) {
                const u = this.ExplodeGroup.first
                if (!u) break
                this.ExplodeGroup.removeUnit(u)

                if (!this.Unit.WolfArea.Rectangle.includes(u.x, u.y)) continue // has to be in wolf lane.
                if (!Globals.ALL_KITTIES.get(u.owner)!.isAlive()) continue // ignore if they're dead lol
                Utility.CreateEffectAndDisposeAttach(Bomber.BLOOD_EFFECT_PATH, u, 'origin')
                Globals.ALL_KITTIES.get(u.owner)!.KillKitty()
            }
            this.Revive()
            this.Unit.Unit.setVertexColor(204, 102, 0, 25)
        } catch (e) {
            Logger.Warning(`Error in Bomber.Explode: ${e}`)
            this.ReviveAlphaTimer.pause()
            this.Unit?.PauseSelf(false)
            this.Unit.IsReviving = false
        }
    }

    private static ExplosionInterval(): number {
        return GetRandomReal(Bomber.MIN_EXPLODE_INTERVAL, Bomber.MAX_EXPLODE_INTERVAL)
    }

    private Revive = () => {
        this.Unit.IsReviving = true
        if (this.Unit.WolfArea.IsEnabled) {
            this.TimerIndicator ??= Effect.create(Bomber.RING_TIMER_INDICATOR, this.Unit.Unit.x, this.Unit.Unit.y)!
            this.TimerIndicator.setTime(0)
            this.TimerIndicator.playAnimation(ANIM_TYPE_BIRTH)
            this.TimerIndicator.x = this.Unit.Unit.x
            this.TimerIndicator.y = this.Unit.Unit.y
        }
        this.ReviveAlphaTimer?.Timer?.start(1.0, true, () => this.ReviveActions())
    }

    private ReviveActions = () => {
        if (this.ReviveAlpha < 10) {
            this.ReviveAlpha++
            this.Unit.Unit.setVertexColor(204, 102, 0, 25)
        } else {
            this.ReviveAlpha = 1
            this.ReviveAlphaTimer?.pause()
            this.Unit.PauseSelf(false)
            this.Unit.IsReviving = false
            this.TimerIndicator?.playAnimation(ANIM_TYPE_DEATH)
            this.Unit.Unit.setVertexColor(204, 102, 0, 255)
            this.ExplodeTimer?.Timer?.start(Bomber.ExplosionInterval(), false, () => this.StartExplosion())
        }
    }

    public override pause(pause: boolean) {
        // For now.. Bomber wolves cannot really be frozen once the explosion timer starts..
        // But in the future.. Need to move the explosion timers to be 1 timer instead of 4 Utility.SimpleTimers.
        this.RangeIndicator?.DestroyIndicator()
    }
}
