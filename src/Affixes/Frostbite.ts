import { Constants } from 'src/AutoGenerated/Constants'
import { Logger } from 'src/Events/Logger/Logger'
import { Kitty } from 'src/Game/Entities/Kitty/Kitty'
import { Wolf } from 'src/Game/Entities/Wolf'
import { Globals } from 'src/Global/Globals'
import { RegionList } from 'src/Global/RegionList'
import { IDisposable } from 'src/Utility/CSUtils'
import { FilterList } from 'src/Utility/FilterList'
import { GC } from 'src/Utility/GC'
import { MemoryHandler } from 'src/Utility/MemoryHandler/MemoryHandler'
import { Utility } from 'src/Utility/Utility'
import { getTriggerUnit } from 'src/Utility/w3tsUtils'
import { Effect, Trigger, Unit } from 'w3ts'
import { Affix } from './Affix'

export class Frostbite extends Affix {
    private FROSTBITE_RADIUS: number = 500.0
    private FROSTBITE_SPEED_REDUCTION: number = 0.83
    private AFFIX_ABILITY: number = Constants.ABILITY_FROSTBITE
    private static ADRENALINE_POTION_ABILITY: number = FourCC('Bspe')
    private FROSTBITE_TARGET_EFFECT: string = 'Abilities\\Spells\\Undead\\FrostArmor\\FrostArmorTarget.mdl'
    private InRangeTrigger: Trigger
    private PeriodicRangeTrigger: Trigger
    private FrostbittenKitties: Frostbitten[] = []

    public constructor(unit: Wolf) {
        super(unit)
        this.name = '{Colors.COLOR_LIGHTBLUE}Frostbite|r'
        this.InRangeTrigger ??= Trigger.create()!
        this.PeriodicRangeTrigger ??= Trigger.create()!
    }

    public override Apply() {
        this.Unit.Unit.setVertexColor(80, 140, 250, 255)
        this.Unit.Unit.addAbility(this.AFFIX_ABILITY)
        this.RegisterEvents()
        super.Apply()
    }

    public override Remove() {
        try {
            this.Unit.Unit.setVertexColor(150, 120, 255, 255)
            this.Unit.Unit.removeAbility(this.AFFIX_ABILITY)
            GC.RemoveTrigger(this.InRangeTrigger) // TODO; Cleanup:             GC.RemoveTrigger(ref InRangeTrigger);
            GC.RemoveTrigger(this.PeriodicRangeTrigger) // TODO; Cleanup:             GC.RemoveTrigger(ref PeriodicRangeTrigger);
            this.RemoveAllEffects()
            GC.RemoveList(this.FrostbittenKitties) // TODO; Cleanup:             GC.RemoveList(ref FrostbittenKitties);
            super.Remove()
        } catch (e: any) {
            Logger.Warning('Error in Frostbite.Remove: {e.Message}')
            throw e
        }
    }

    private RemoveAllEffects() {
        if (this.FrostbittenKitties == null || this.FrostbittenKitties.length == 0) return
        try {
            for (let i: number = 0; i < this.FrostbittenKitties.length; i++) {
                let frostbitten = this.FrostbittenKitties[i]
                frostbitten.dispose()
            }
            this.FrostbittenKitties.length = 0
        } catch (e: any) {
            Logger.Warning('Error in Frostbite.RemoveAllEffects: {e.Message}')
            throw e
        }
    }

    private RegisterEvents() {
        this.PeriodicRangeTrigger.registerTimerEvent(0.3, true)
        this.PeriodicRangeTrigger.addAction(this.PeriodicRangeCheck)
        this.InRangeTrigger.registerUnitInRage(this.Unit.Unit.handle, this.FROSTBITE_RADIUS, FilterList.KittyFilter)
        this.InRangeTrigger.addAction(() => {
            let target = getTriggerUnit()
            if (!target.isAlive()) return // must be alive
            if (!RegionList.WolfRegions[this.Unit.RegionIndex].includes(target.x, target.y)) return // must be in same lane
            this.SlowEffect(target)
        })
    }

    private PeriodicRangeCheck() {
        if (this.FrostbittenKitties == null || this.FrostbittenKitties.length == 0) return
        try {
            for (
                let i: number = this.FrostbittenKitties.length - 1;
                i >= 0;
                i-- // if go backwards, can avoid loop index issues
            ) {
                let frostbitten = this.FrostbittenKitties[i]

                if (IsUnitInRange(frostbitten.Kitty.Unit.handle, this.Unit.Unit.handle, this.FROSTBITE_RADIUS)) continue

                frostbitten.dispose()
                this.FrostbittenKitties.splice(i, 1)
            }
        } catch (e: any) {
            Logger.Warning('Error in Frostbite.PeriodicRangeCheck: {e.Message}')
        }
    }

    private SlowEffect(target: Unit) {
        if (target.getAbilityLevel(Frostbite.ADRENALINE_POTION_ABILITY) > 0) return // Adrenaline Potion
        if (Utility.UnitHasItem(target, Constants.ITEM_FROSTBITE_RING)) return // Frostbite ring
        let k: Kitty = Globals.ALL_KITTIES.get(target.owner)!
        if (k.KittyMiscInfo.FrostBitten != null) return // already bitten.
        let frostBittenObject: Frostbitten = (k.KittyMiscInfo.FrostBitten = MemoryHandler.getEmptyObject<Frostbitten>())
        frostBittenObject.OriginalSpeed = target.defaultMoveSpeed
        frostBittenObject.Effect = Effect.createAttachment(this.FROSTBITE_TARGET_EFFECT, target, 'chest')!
        frostBittenObject.Kitty = k
        target.moveSpeed = target.defaultMoveSpeed * this.FROSTBITE_SPEED_REDUCTION
        this.FrostbittenKitties.push(frostBittenObject)
    }

    public override pause(pause: boolean) {
        // no logic needed atm.
    }
}

export class Frostbitten extends IDisposable {
    public Effect: Effect
    public OriginalSpeed: number
    public Kitty: Kitty

    constructor() {
        super()
        this.Effect = null as never
        this.OriginalSpeed = 0.0
    }

    public dispose() {
        this.Kitty.Unit.moveSpeed = this.OriginalSpeed != 0 ? this.OriginalSpeed : this.Kitty.Unit.defaultMoveSpeed
        this.Effect?.destroy()
        this.Effect = null as never
        this.OriginalSpeed = 0.0
        this.Kitty.KittyMiscInfo.FrostBitten = null as never
        MemoryHandler.destroyObject(this)
    }
}
