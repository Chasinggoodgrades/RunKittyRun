import { Constants } from 'src/AutoGenerated/Constants'
import { Logger } from 'src/Events/Logger/Logger'
import { Wolf } from 'src/Game/Entities/Wolf'
import { DEFAULT_OVERHEAD_EFFECT, DEFAULT_WOLF_COLLISION_RADIUS, Globals } from 'src/Global/Globals'
import { Colors } from 'src/Utility/Colors/Colors'
import { GC } from 'src/Utility/GC'
import { AchesTimers, createAchesTimer } from 'src/Utility/MemoryHandler/AchesTimers'
import { distanceBetweenXYPoints } from 'src/Utility/Utility'
import { Effect, Unit } from 'w3ts'
import { Affix } from './Affix'

export class Blitzer extends Affix {
    private static readonly GHOST_VISIBLE: number = FourCC('Aeth')

    private static readonly IsBlitzer = (r: Affix): r is Blitzer => {
        return r instanceof Blitzer
    }

    private AFFIX_ABILITY = Constants.ABILITY_BLITZER
    private BLITZER_EFFECT: string = 'war3mapImported\\ChargerCasterArt.mdx'
    private BLITZER_SPEED = 650.0
    private BLITZER_OVERHEAD_DELAY = 1.5
    private BLITZER_LOWEND = 6.0
    private BLITZER_HIGHEND = 11.0
    private TargetX = 0
    private TargetY = 0
    private MoveTimer: AchesTimers | null
    private BlitzerTimer: AchesTimers | null
    private PreBlitzerTimer: AchesTimers | null
    private Effect: Effect
    private WanderEffect: Effect

    public constructor(unit: Wolf) {
        super(unit)
        this.name = `${Colors.COLOR_YELLOW}Blitzer|r`
    }

    public override Apply = () => {
        this.Unit.Unit.addAbility(this.AFFIX_ABILITY)
        this.Unit.WanderTimer?.pause()
        this.Unit.OVERHEAD_EFFECT_PATH = ''
        this.Unit.Unit.setVertexColor(224, 224, 120, 255)
        this.RegisterMoveTimer()
    }

    public override Remove = () => {
        this.Unit.Unit.removeAbility(this.AFFIX_ABILITY)
        this.Unit.WanderTimer?.resume()
        this.Unit.OVERHEAD_EFFECT_PATH = DEFAULT_OVERHEAD_EFFECT

        GC.RemoveEffect(this.WanderEffect) // TODO; Cleanup:         GC.RemoveEffect(ref WanderEffect);
        this.BlitzerTimer?.dispose()
        this.MoveTimer?.dispose()
        this.PreBlitzerTimer?.dispose()
        this.BlitzerTimer = null
        this.MoveTimer = null
        this.PreBlitzerTimer = null
        GC.RemoveEffect(this.Effect) // TODO; Cleanup:         GC.RemoveEffect(ref Effec`t);
        this.EndBlitz()
        this.Unit.Unit.setVertexColor(150, 120, 255, 255)
        this.Unit.Unit.color = PLAYER_COLOR_BROWN
    }

    private RegisterMoveTimer = () => {
        this.MoveTimer = createAchesTimer()
        this.PreBlitzerTimer = createAchesTimer()
        const randomFlyTime = GetRandomReal(4.0, 10.0) // random time to move before blitzing
        this.MoveTimer?.Timer.start(randomFlyTime, false, () => this.PreBlitzerMove()) // initial move
        this.BlitzerTimer = createAchesTimer()
    }

    private PreBlitzerMove = () => {
        try {
            if (this.Unit?.paused) {
                this.MoveTimer?.Timer.start(GetRandomReal(3.0, 10.0), false, () => this.PreBlitzerMove())
                return
            }
            this.WanderEffect ??= Effect.createAttachment(DEFAULT_OVERHEAD_EFFECT, this.Unit.Unit, 'overhead')!
            this.WanderEffect.playAnimation(ANIM_TYPE_STAND)
            this.Unit.Unit.setVertexColor(255, 255, 0, 255)
            this.Unit.Unit.color = PLAYER_COLOR_YELLOW
            this.PreBlitzerTimer?.Timer.start(this.BLITZER_OVERHEAD_DELAY, false, () => this.BeginBlitz())
        } catch (e) {
            Logger.Warning(`Error in PreBlitzerMove: ${e}`)
            throw e
        }
    }

    private BeginBlitz = () => {
        try {
            const randomTime = GetRandomReal(this.BLITZER_LOWEND, this.BLITZER_HIGHEND) // blitz randomly between this time interval
            this.TargetX = GetRandomReal(this.Unit.WolfArea.Rectangle.minX, this.Unit.WolfArea.Rectangle.maxX)
            this.TargetY = GetRandomReal(this.Unit.WolfArea.Rectangle.minY, this.Unit.WolfArea.Rectangle.maxY)
            this.WanderEffect?.playAnimation(ANIM_TYPE_DEATH)
            this.BlitzerMove()
            this.Unit.Unit.removeAbility(Blitzer.GHOST_VISIBLE) // ghost visible
            this.Effect ??= Effect.createAttachment(this.BLITZER_EFFECT, this.Unit.Unit, 'origin')!
            this.Effect?.playAnimation(ANIM_TYPE_STAND)
            this.Unit.IsWalking = true
            this.MoveTimer?.Timer.start(randomTime, false, () => this.PreBlitzerMove())
        } catch (e) {
            Logger.Warning(`Error in BeginBlitz: ${e}`)
            throw e
        }
    }

    private BlitzerMove = () => {
        const speed = this.BLITZER_SPEED // speed in yards per second
        const currentX: number = this.Unit.Unit.x
        const currentY: number = this.Unit.Unit.y

        // Distance between current and target pos
        const distance: number = distanceBetweenXYPoints(currentX, currentY, this.TargetX, this.TargetY)

        // stop if its within range of the target / collision thingy
        if (distance <= DEFAULT_WOLF_COLLISION_RADIUS) {
            this.EndBlitz()
            return
        }

        // determine direction
        const directionX: number = (this.TargetX - currentX) / distance
        const directionY: number = (this.TargetY - currentY) / distance

        // 60 fps for smooth movement, step distance
        const stepDistance: number = speed / 50.0 // Assuming 60 calls per second
        const nextX: number = currentX + directionX * stepDistance
        const nextY: number = currentY + directionY * stepDistance

        // Move the unit one step
        this.Unit.Unit.setPathing(false)
        this.Unit.Unit.setPosition(nextX, nextY)
        this.Unit.Unit.setPathing(true)

        this.Unit.Unit.setFacingEx((Math.atan2(directionY, directionX) * 180.0) / Math.PI)
        this.Unit.Unit.setAnimation(2) // running animation: ;

        const stepTime = 1.0 / 50.0

        // Set a timer to call this method again after a short delay
        this.BlitzerTimer?.Timer.start(stepTime, false, () => this.BlitzerMove())
    }

    private EndBlitz = () => {
        this.BlitzerTimer?.pause()
        this.Effect?.playAnimation(ANIM_TYPE_DEATH)
        this.Unit.Unit.setAnimation(0)
        this.Unit.Unit.setVertexColor(224, 224, 120, 255)
        this.Unit.Unit.color = PLAYER_COLOR_BROWN
        this.Unit.IsWalking = false
        this.Unit.Unit.addAbility(Blitzer.GHOST_VISIBLE)
    }

    public static GetBlitzer(unit: Unit): Blitzer {
        if (!unit) return null as never
        const affix = Globals.ALL_WOLVES.get(unit)!.Affixes.find(Blitzer.IsBlitzer)
        return affix instanceof Blitzer ? affix : (null as never)
    }

    public override pause(pause: boolean) {
        if (pause) {
            this.BlitzerTimer?.pause()
            this.PreBlitzerTimer?.pause()
            this.WanderEffect?.playAnimation(ANIM_TYPE_DEATH)
            this.MoveTimer?.pause()
            this.Unit.IsWalking = !pause
        } else {
            this.BlitzerTimer?.resume()
            this.PreBlitzerTimer?.resume()
            this.MoveTimer?.resume()
            this.Unit.IsWalking = !pause
        }
    }
}
