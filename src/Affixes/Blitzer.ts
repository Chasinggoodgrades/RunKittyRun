import { Constants } from 'src/AutoGenerated/Constants'
import { Logger } from 'src/Events/Logger/Logger'
import { CollisionDetection } from 'src/Game/CollisionDetection'
import { Wolf } from 'src/Game/Entities/Wolf'
import { Globals } from 'src/Global/Globals'
import { GC } from 'src/Utility/GC'
import { AchesTimers } from 'src/Utility/MemoryHandler/AchesTimers'
import { MemoryHandler } from 'src/Utility/MemoryHandler/MemoryHandler'
import { Effect, Unit } from 'w3ts'
import { Affix } from './Affix'

export class Blitzer extends Affix {
    private static readonly GHOST_VISIBLE: number = FourCC('Aeth')

    private static readonly IsBlitzer = (r: Affix): r is Blitzer => {
        return r instanceof Blitzer
    }

    private AFFIX_ABILITY: number = Constants.ABILITY_BLITZER
    private BLITZER_EFFECT: string = 'war3mapImported\\ChargerCasterArt.mdx'
    private BLITZER_SPEED: number = 650.0
    private BLITZER_OVERHEAD_DELAY: number = 1.5
    private BLITZER_LOWEND: number = 6.0
    private BLITZER_HIGHEND: number = 11.0
    private TargetX: number
    private TargetY: number
    private MoveTimer: AchesTimers | null
    private BlitzerTimer: AchesTimers | null
    private PreBlitzerTimer: AchesTimers | null
    private Effect: Effect
    private WanderEffect: Effect

    public constructor(unit: Wolf) {
        super(unit)
        this.name = '{Colors.COLOR_YELLOW}Blitzer|r'
    }

    public override Apply() {
        this.Unit.Unit.addAbility(this.AFFIX_ABILITY)
        this.Unit.WanderTimer?.pause()
        this.Unit.OVERHEAD_EFFECT_PATH = ''
        this.Unit.Unit.setVertexColor(224, 224, 120, 255)
        this.RegisterMoveTimer()
        super.Apply()
    }

    public override Remove() {
        this.Unit.Unit.removeAbility(this.AFFIX_ABILITY)
        this.Unit.WanderTimer?.resume()
        this.Unit.OVERHEAD_EFFECT_PATH = Wolf.DEFAULT_OVERHEAD_EFFECT

        GC.RemoveEffect(this.WanderEffect) // TODO; Cleanup:         GC.RemoveEffect(ref WanderEffect);
        this.BlitzerTimer?.dispose()
        this.MoveTimer?.dispose()
        this.PreBlitzerTimer?.dispose()
        this.BlitzerTimer = null
        this.MoveTimer = null
        this.PreBlitzerTimer = null
        GC.RemoveEffect(this.Effect) // TODO; Cleanup:         GC.RemoveEffect(ref Effect);
        this.EndBlitz()
        this.Unit.Unit.setVertexColor(150, 120, 255, 255)
        this.Unit.Unit.setColor(PLAYER_COLOR_BROWN)
        super.Remove()
    }

    private RegisterMoveTimer() {
        this.MoveTimer = MemoryHandler.getEmptyObject<AchesTimers>()
        this.PreBlitzerTimer = MemoryHandler.getEmptyObject<AchesTimers>()
        let randomFlyTime = GetRandomReal(4.0, 10.0) // random time to move before blitzing
        this.MoveTimer?.Timer.start(randomFlyTime, false, this.PreBlitzerMove) // initial move
        this.BlitzerTimer = MemoryHandler.getEmptyObject<AchesTimers>()
    }

    private PreBlitzerMove() {
        try {
            if (this.Unit.paused) {
                this.MoveTimer?.Timer.start(GetRandomReal(3.0, 10.0), false, this.PreBlitzerMove)
                return
            }
            this.WanderEffect ??= this.Effect.createAttachment(
                Wolf.DEFAULT_OVERHEAD_EFFECT,
                this.Unit.Unit,
                'overhead'
            )!
            this.WanderEffect.playAnimation(ANIM_TYPE_STAND)
            this.Unit.Unit.setVertexColor(255, 255, 0, 255)
            this.Unit.Unit.setColor(PLAYER_COLOR_YELLOW)
            this.PreBlitzerTimer?.Timer.start(this.BLITZER_OVERHEAD_DELAY, false, this.BeginBlitz)
        } catch (e: any) {
            Logger.Warning('Error in PreBlitzerMove: {e.Message}')
            throw e
        }
    }

    private BeginBlitz() {
        try {
            let randomTime = GetRandomReal(this.BLITZER_LOWEND, this.BLITZER_HIGHEND) // blitz randomly between this time interval
            this.TargetX = GetRandomReal(this.Unit.WolfArea.Rect.minX, this.Unit.WolfArea.Rect.maxX)
            this.TargetY = GetRandomReal(this.Unit.WolfArea.Rect.minY, this.Unit.WolfArea.Rect.maxY)
            this.WanderEffect?.playAnimation(ANIM_TYPE_DEATH)
            this.BlitzerMove()
            this.Unit.Unit.removeAbility(Blitzer.GHOST_VISIBLE) // ghost visible
            this.Effect ??= this.Effect.create(this.BLITZER_EFFECT, this.Unit.Unit, 'origin')!
            this.Effect?.playAnimation(ANIM_TYPE_STAND)
            this.Unit.IsWalking = true
            this.MoveTimer?.Timer.start(randomTime, false, this.PreBlitzerMove)
        } catch (e: any) {
            Logger.Warning('Error in BeginBlitz: {e.Message}')
            throw e
        }
    }

    private BlitzerMove() {
        let speed = this.BLITZER_SPEED // speed in yards per second
        let currentX: number = this.Unit.Unit.x
        let currentY: number = this.Unit.Unit.y

        // Distance between current and target pos
        let distance: number = WCSharp.Shared.FastUtil.DistanceBetweenPoints(
            currentX,
            currentY,
            this.TargetX,
            this.TargetY
        )

        // stop if its within range of the target / collision thingy
        if (distance <= CollisionDetection.DEFAULT_WOLF_COLLISION_RADIUS) {
            this.EndBlitz()
            return
        }

        // determine direction
        let directionX: number = (this.TargetX - currentX) / distance
        let directionY: number = (this.TargetY - currentY) / distance

        // 60 fps for smooth movement, step distance
        let stepDistance: number = speed / 50.0 // Assuming 60 calls per second
        let nextX: number = currentX + directionX * stepDistance
        let nextY: number = currentY + directionY * stepDistance

        // Move the unit one step
        this.Unit.Unit.setPathing(false)
        this.Unit.Unit.setPosition(nextX, nextY)
        this.Unit.Unit.setPathing(true)

        this.Unit.Unit.setFacingEx((Math.atan2(directionY, directionX) * 180.0) / Math.PI)
        this.Unit.Unit.setAnimation(2) // running animation: ;

        let stepTime = 1.0 / 50.0

        // Set a timer to call this method again after a short delay
        this.BlitzerTimer?.Timer.start(stepTime, false, this.BlitzerMove)
    }

    private EndBlitz() {
        this.BlitzerTimer?.pause()
        this.Effect?.playAnimation(ANIM_TYPE_DEATH)
        this.Unit.Unit.setAnimation(0)
        this.Unit.Unit.setVertexColor(224, 224, 120, 255)
        this.Unit.Unit.setColor(playercolor.Brown)
        this.Unit.IsWalking = false
        this.Unit.Unit.addAbility(this.GHOST_VISIBLE)
    }

    public static GetBlitzer(unit: Unit): Blitzer {
        if (unit == null) return null
        let affix = Globals.ALL_WOLVES.get(unit)!.Affixes.find(Blitzer.IsBlitzer)
        return affix instanceof Blitzer ? blitzer : null
    }

    public override Pause(pause: boolean) {
        if (pause) {
            this.BlitzerTimer?.pause()
            this.PreBlitzerTimer?.pause()
            this.WanderEffect?.playAnimation(ANIM_TYPE_DEATH)
            this.MoveTimer?.pause()
            this.Unit.IsWalking = !pause
        } else {
            this.BlitzerTimer?.resume()
            this.PreBlitzerTimer?.resume()
            this.MoveTimer?.resume()
            this.Unit.IsWalking = !pause
        }
    }
}
