import { Constants } from 'src/AutoGenerated/Constants'
import { Logger } from 'src/Events/Logger/Logger'
import { UnitWithinRange } from 'src/Events/WithinRange/UnitWithinRange'
import { Gamemode } from 'src/Gamemodes/Gamemode'
import { GameMode } from 'src/Gamemodes/GameModeEnum'
import { TeamsUtil } from 'src/Gamemodes/Teams/TeamsUtil'
import { Globals } from 'src/Global/Globals'
import { getFilterUnit } from 'src/Utility/w3tsUtils'
import { Trigger } from 'w3ts'
import { Kitty } from './Entities/Kitty/Kitty'
import { NamedWolves } from './Entities/NamedWolves'
import { ShadowKitty } from './Entities/ShadowKitty'
import { Relic } from './Items/Relics/Relic'
import { BeaconOfUnitedLifeforce } from './Items/Relics/RelicTypes/BeaconOfUnitedLifeforce'
import { ChronoSphere } from './Items/Relics/RelicTypes/ChronoSphere'
import { OneOfNine } from './Items/Relics/RelicTypes/OneOfNine'

export class CollisionDetection {
    public static DEFAULT_WOLF_COLLISION_RADIUS: number = 74.0
    private static CIRCLE_COLLISION_RADIUS: number = 78.0

    private static IsBeaconOfUnitedLifeforce = (r: Relic): r is BeaconOfUnitedLifeforce => {
        return r instanceof BeaconOfUnitedLifeforce
    }

    private static WolfCollisionFilter(k: Kitty): () => boolean {
        return () => {
            return getFilterUnit().typeId == Constants.UNIT_CUSTOM_DOG && k.isAlive() && getFilterUnit().isAlive() // wolf should be alive too (exploding / stan wolf)
        }
    }

    private static ShadowRelicWolvesFilter(sk: ShadowKitty): () => boolean {
        return () => {
            return getFilterUnit().typeId == Constants.UNIT_CUSTOM_DOG && sk.Unit.isAlive()
        }
    }

    private static ShadowRelicCircleFilter(sk: ShadowKitty): () => boolean {
        return () => {
            return (
                getFilterUnit().typeId == Constants.UNIT_KITTY_CIRCLE &&
                getFilterUnit().owner != sk.Player && // Not Same Player
                sk.Unit.isAlive() && // Has to Be Alive
                Globals.ALL_KITTIES.get(getFilterUnit()!.owner)?.TeamID == Globals.ALL_KITTIES.get(sk.Player)!.TeamID
            ) // Must be same team
        }
    }

    private static CircleCollisionFilter(k: Kitty): () => boolean {
        return () => {
            return (
                getFilterUnit().typeId == Constants.UNIT_KITTY_CIRCLE &&
                getFilterUnit().owner != k.Player && // Not Same Player
                k.isAlive() && // Has to Be Alive
                Globals.ALL_KITTIES.get(getFilterUnit()!.owner)?.TeamID == Globals.ALL_KITTIES.get(k.Player)!.TeamID && // Must be same team
                Gamemode.CurrentGameMode != GameMode.SoloTournament
            ) // Not Solo Mode
        }
    }

    public static KittyRegisterCollisions(k: Kitty) {
        let WOLF_COLL_RADIUS = k.CurrentStats.CollisonRadius
        k.w_Collision ??= Trigger.create()!
        k.c_Collision ??= Trigger.create()!

        UnitWithinRange.RegisterUnitWithinRangeTrigger(
            k.Unit,
            WOLF_COLL_RADIUS,
            this.WolfCollisionFilter(k),
            this.WolfCollisionTrigger(k)
        )
        UnitWithinRange.RegisterUnitWithinRangeTrigger(
            k.Unit,
            CollisionDetection.CIRCLE_COLLISION_RADIUS,
            this.CircleCollisionFilter(k),
            this.CircleCollisionTrigger(k)
        )
    }

    public static ShadowKittyRegisterCollision(sk: ShadowKitty) {
        sk.wCollision ??= Trigger.create()!
        sk.cCollision ??= Trigger.create()!

        UnitWithinRange.RegisterUnitWithinRangeTrigger(
            sk.Unit,
            CollisionDetection.DEFAULT_WOLF_COLLISION_RADIUS,
            this.ShadowRelicWolvesFilter(sk),
            this.WolfCollisionShadowTrigger(sk)
        )
        UnitWithinRange.RegisterUnitWithinRangeTrigger(
            sk.Unit,
            CollisionDetection.CIRCLE_COLLISION_RADIUS,
            this.ShadowRelicCircleFilter(sk),
            this.CircleCollisionShadowTrigger(sk)
        )
    }

    private static WolfCollisionTrigger(k: Kitty): Trigger {
        k.w_Collision.addAction(() => {
            try {
                if (!k.Unit.isAlive()) return
                if (NamedWolves.ExplodingWolfCollision(getFilterUnit(), k)) return
                if (Globals.ALL_WOLVES.get(getFilterUnit())!.IsReviving) return // bomber wolf
                if (ChronoSphere.RewindDeath(k)) return
                if (k.Invulnerable) return
                OneOfNine.OneOfNineEffect(k)
                k.KillKitty()
                TeamsUtil.CheckTeamDead(k)
            } catch (e: any) {
                Logger.Warning('Error: WolfCollisionTrigger: {e.Message}')
                throw e
            }
        })
        return k.w_Collision
    }

    private static CircleCollisionTrigger(k: Kitty): Trigger {
        k.c_Collision.addAction(() => {
            try {
                let circle = Globals.ALL_KITTIES.get(getFilterUnit()!.owner)!
                circle.ReviveKitty(k)
                k.Relics.find(CollisionDetection.IsBeaconOfUnitedLifeforce)?.BeaconOfUnitedLifeforceEffect(k.Player)
            } catch (e: any) {
                Logger.Warning('Error: CircleCollisionTrigger: {e.Message}')
                throw e
            }
        })
        return k.c_Collision
    }

    private static WolfCollisionShadowTrigger(sk: ShadowKitty): Trigger {
        sk.wCollision.addAction(() => {
            if (NamedWolves.ExplodingWolfCollision(getFilterUnit(), sk.Kitty, true)) return // Floating text will appear on kitty instead of SK tho.
            sk.KillShadowKitty()
        })
        return sk.wCollision
    }

    private static CircleCollisionShadowTrigger(sk: ShadowKitty): Trigger {
        sk.cCollision.addAction(() => {
            try {
                let circle = Globals.ALL_KITTIES.get(getFilterUnit().owner)!
                let saviorKitty = Globals.ALL_KITTIES.get(sk.Player)!
                circle.ReviveKitty(saviorKitty)
            } catch (e: any) {
                Logger.Warning('Error: CircleCollisionShadowTrigger: {e.Message}')
                throw e
            }
        })
        return sk.cCollision
    }
}
