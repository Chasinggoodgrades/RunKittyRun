import { Constants } from 'src/AutoGenerated/Constants'
import { Logger } from 'src/Events/Logger/Logger'
import { UnitWithinRange } from 'src/Events/WithinRange/UnitWithinRange'
import { CurrentGameMode } from 'src/Gamemodes/CurrentGameMode'
import { GameMode } from 'src/Gamemodes/GameModeEnum'
import { DEFAULT_WOLF_COLLISION_RADIUS, Globals } from 'src/Global/Globals'
import { getFilterUnit } from 'src/Utility/w3tsUtils'
import { Trigger } from 'w3ts'
import { Kitty } from './Entities/Kitty/Kitty'
import { NamedWolves } from './Entities/NamedWolves'
import { ShadowKitty } from './Entities/ShadowKitty'
import { Relic } from './Items/Relics/Relic'
import { BeaconOfUnitedLifeforce } from './Items/Relics/RelicTypes/BeaconOfUnitedLifeforce'
import { ChronoSphere } from './Items/Relics/RelicTypes/ChronoSphere'
import { OneOfNine } from './Items/Relics/RelicTypes/OneOfNine'

export class CollisionDetection {
    private static CIRCLE_COLLISION_RADIUS = 78.0

    private static IsBeaconOfUnitedLifeforce = (r: Relic): r is BeaconOfUnitedLifeforce => {
        return r instanceof BeaconOfUnitedLifeforce
    }

    private static WolfCollisionFilter(k: Kitty): () => boolean {
        return () => {
            return getFilterUnit().typeId === Constants.UNIT_CUSTOM_DOG && k.isAlive() && getFilterUnit().isAlive() // wolf should be alive too (exploding / stan wolf)
        }
    }

    private static ShadowRelicWolvesFilter(sk: ShadowKitty): () => boolean {
        return () => {
            return getFilterUnit().typeId === Constants.UNIT_CUSTOM_DOG && sk.Unit.isAlive()
        }
    }

    private static ShadowRelicCircleFilter(sk: ShadowKitty): () => boolean {
        return () => {
            return (
                getFilterUnit().typeId === Constants.UNIT_KITTY_CIRCLE &&
                getFilterUnit().owner !== sk.Player && // Not Same Player
                sk.Unit.isAlive() && // Has to Be Alive
                Globals.ALL_KITTIES.get(getFilterUnit()!.owner)?.TeamID === Globals.ALL_KITTIES.get(sk.Player)!.TeamID
            ) // Must be same team
        }
    }

    private static CircleCollisionFilter(k: Kitty): () => boolean {
        return () => {
            return (
                getFilterUnit().typeId === Constants.UNIT_KITTY_CIRCLE &&
                getFilterUnit().owner !== k.Player && // Not Same Player
                k.isAlive() && // Has to Be Alive
                Globals.ALL_KITTIES.get(getFilterUnit()!.owner)?.TeamID === Globals.ALL_KITTIES.get(k.Player)!.TeamID && // Must be same team
                CurrentGameMode.active !== GameMode.SoloTournament
            ) // Not Solo Mode
        }
    }

    public static KittyRegisterCollisions = (k: Kitty) => {
        const WOLF_COLL_RADIUS = k.CurrentStats.CollisonRadius
        k.w_Collision = Trigger.create()!
        k.c_Collision = Trigger.create()!

        UnitWithinRange.RegisterUnitWithinRangeTrigger(
            k.Unit,
            WOLF_COLL_RADIUS,
            CollisionDetection.WolfCollisionFilter(k),
            CollisionDetection.WolfCollisionTrigger(k)
        )
        UnitWithinRange.RegisterUnitWithinRangeTrigger(
            k.Unit,
            CollisionDetection.CIRCLE_COLLISION_RADIUS,
            CollisionDetection.CircleCollisionFilter(k),
            CollisionDetection.CircleCollisionTrigger(k)
        )
    }

    public static ShadowKittyRegisterCollision = (sk: ShadowKitty) => {
        sk.wCollision = Trigger.create()!
        sk.cCollision = Trigger.create()!

        UnitWithinRange.RegisterUnitWithinRangeTrigger(
            sk.Unit,
            DEFAULT_WOLF_COLLISION_RADIUS,
            CollisionDetection.ShadowRelicWolvesFilter(sk),
            CollisionDetection.WolfCollisionShadowTrigger(sk)
        )
        UnitWithinRange.RegisterUnitWithinRangeTrigger(
            sk.Unit,
            CollisionDetection.CIRCLE_COLLISION_RADIUS,
            CollisionDetection.ShadowRelicCircleFilter(sk),
            CollisionDetection.CircleCollisionShadowTrigger(sk)
        )
    }

    private static WolfCollisionTrigger(k: Kitty) {
        k.w_Collision.addAction(() => {
            try {
                if (!k.Unit.isAlive()) return
                if (NamedWolves.ExplodingWolfCollision(getFilterUnit(), k)) return
                if (Globals.ALL_WOLVES.get(getFilterUnit())!.IsReviving) return // bomber wolf
                if (ChronoSphere.RewindDeath(k)) return
                if (k.Invulnerable) return
                OneOfNine.OneOfNineEffect(k)
                k.KillKitty()
                CollisionDetection.CheckTeamDead(k)
            } catch (e) {
                Logger.Warning(`Error WolfCollisionTrigger: ${e}`)
                throw e
            }
        })

        return k.w_Collision
    }

    private static CircleCollisionTrigger(k: Kitty): Trigger {
        k.c_Collision.addAction(() => {
            try {
                const circle = Globals.ALL_KITTIES.get(getFilterUnit()!.owner)!
                circle.ReviveKitty(k)
                k.Relics.find(CollisionDetection.IsBeaconOfUnitedLifeforce)?.BeaconOfUnitedLifeforceEffect(k.Player)
            } catch (e) {
                Logger.Warning(`Error CircleCollisionTrigger: ${e}`)
                throw e
            }
        })
        return k.c_Collision
    }

    private static WolfCollisionShadowTrigger(sk: ShadowKitty): Trigger {
        sk.wCollision.addAction(() => {
            if (NamedWolves.ExplodingWolfCollision(getFilterUnit(), sk.Kitty, true)) return // Floating text will appear on kitty instead of SK tho.
            sk.KillShadowKitty()
        })
        return sk.wCollision
    }

    private static CircleCollisionShadowTrigger(sk: ShadowKitty): Trigger {
        sk.cCollision.addAction(() => {
            try {
                const circle = Globals.ALL_KITTIES.get(getFilterUnit().owner)!
                const saviorKitty = Globals.ALL_KITTIES.get(sk.Player)!
                circle.ReviveKitty(saviorKitty)
            } catch (e) {
                Logger.Warning(`Error CircleCollisionShadowTrigger: ${e}`)
                throw e
            }
        })
        return sk.cCollision
    }

    public static CheckTeamDead = (k: Kitty) => {
        if (CurrentGameMode.active !== GameMode.TeamTournament) return
        const team = Globals.ALL_TEAMS.get(k.TeamID)!
        for (let i = 0; i < team.Teammembers.length; i++) {
            if (Globals.ALL_KITTIES.get(team.Teammembers[i])!.isAlive()) return
        }
        team.TeamIsDeadActions()
    }
}
