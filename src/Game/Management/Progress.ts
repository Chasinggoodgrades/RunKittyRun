import { Regions } from 'src/AutoGenerated/Regions'
import { Logger } from 'src/Events/Logger/Logger'
import { CurrentGameMode } from 'src/Gamemodes/CurrentGameMode'
import { GameMode } from 'src/Gamemodes/GameModeEnum'
import { Team } from 'src/Gamemodes/Teams/Team'
import { Globals } from 'src/Global/Globals'
import { RegionList } from 'src/Global/RegionList'
import { Timer } from 'w3ts'
import { Kitty } from '../Entities/Kitty/Kitty'
import { ProgressPointHelper } from './ProgressPointHelper'

export const Progress = {
    DistancesFromStart: new Map<number, number>(),
    TeamProgTimer: Timer.create(),

    Initialize() {
        this.CalculateTotalDistance()
        if (CurrentGameMode.active !== GameMode.TeamTournament) return
        this.TeamProgTimer.start(0.2, true, this.TeamProgressTracker)
    },

    CalculateProgress(kitty: Kitty) {
        const round = Globals.ROUND
        kitty.TimeProg.SetRoundProgress(round, this.CalculatePlayerProgress(kitty))
    },

    TeamProgressTracker() {
        if (!Globals.GAME_ACTIVE) return
        try {
            for (let i = 0; i < Globals.ALL_TEAMS_LIST.length; i++) {
                const team = Globals.ALL_TEAMS_LIST[i]
                team.UpdateRoundProgress(Globals.ROUND, Progress.CalculateTeamProgress(team))
            }
            // TeamsMultiboard.UpdateTeamStatsMB()
        } catch (e) {
            Logger.Warning(`Error in TeamProgressTracker. ${e}`)
        }
    },

    CalculateTeamProgress(Team: Team) {
        let totalProgress = 0.0

        if (Team.Teammembers.length === 0) return '0.00'

        for (let i = 0; i < Team.Teammembers.length; i++) {
            const player = Team.Teammembers[i]
            totalProgress += Globals.ALL_KITTIES.get(player)!.TimeProg.GetRoundProgress(Globals.ROUND)
        }

        return (totalProgress / Team.Teammembers.length).toFixed(2)
    },

    CalculatePlayerProgress(kitty: Kitty) {
        try {
            const currentSafezone = kitty.ProgressZone
            if (Globals.SAFE_ZONES[Globals.SAFE_ZONES.length - 1].Rectangle.includes(kitty.Unit.x, kitty.Unit.y))
                return 100.0 // if at end.. 100 progress
            if (Regions.Victory_Area.includes(kitty.Unit.x, kitty.Unit.y)) return 100.0 // if in victory area, 100 progress
            if (Globals.SAFE_ZONES[0].Rectangle.includes(kitty.Unit.x, kitty.Unit.y) && !kitty.Finished) return 0.0 // if at start, 0 progress
            if (kitty.isAlive() && kitty.Finished) return 100.0
            const currentProgress = Progress.DistanceBetweenPoints(
                kitty.Unit.x,
                kitty.Unit.y,
                ProgressPointHelper.Points[kitty.ProgressHelper.CurrentPoint].x,
                ProgressPointHelper.Points[kitty.ProgressHelper.CurrentPoint].y
            )
            const totalProgress = (Progress.DistancesFromStart.get(currentSafezone) ?? 0) + currentProgress

            let progress =
                (totalProgress / (Progress.DistancesFromStart.get(RegionList.PathingPoints.length - 1) ?? 1)) * 100
            if (progress > 100) progress = 100.0

            return progress
        } catch (e) {
            Logger.Warning(`Error in CalculatePlayerProgress. ${e}`)
            return 0.0
        }
    },

    CalculateTotalDistance() {
        try {
            if (!RegionList.PathingPoints || RegionList.PathingPoints.length === 0) {
                Logger.Warning('PathingPoints list is null or empty.')
                return
            }

            let totalDistance = 0.0
            let count = 0
            Progress.DistancesFromStart.set(0, 0.0)
            for (const pathPoint of RegionList.PathingPoints) {
                if (count >= RegionList.PathingPoints.length - 1) break
                const nextPathPoint = RegionList.PathingPoints[count + 1]
                totalDistance += Progress.DistanceBetweenPoints(
                    pathPoint.centerX,
                    pathPoint.centerY,
                    nextPathPoint.centerX,
                    nextPathPoint.centerY
                )
                if (!Progress.DistancesFromStart.has(count + 1))
                    Progress.DistancesFromStart.set(count + 1, totalDistance)
                count++
            }
        } catch (e) {
            Logger.Warning(`Error in CalculateTotalDistance. ${e}`)
            throw e
        }
    },

    DistanceBetweenPoints(x1: number, y1: number, x2: number, y2: number) {
        return Math.abs(x1 - x2) > Math.abs(y1 - y2) ? Math.abs(x1 - x2) : Math.abs(y1 - y2)
    },
}
