import { Regions } from 'src/AutoGenerated/Regions'
import { Logger } from 'src/Events/Logger/Logger'
import { Gamemode } from 'src/Gamemodes/Gamemode'
import { GameMode } from 'src/Gamemodes/GameModeEnum'
import { Team } from 'src/Gamemodes/Teams/Team'
import { Globals } from 'src/Global/Globals'
import { RegionList } from 'src/Global/RegionList'
import { TeamsMultiboard } from 'src/UI/Multiboard/TeamsMultiboard'
import { Timer } from 'w3ts'
import { Kitty } from '../Entities/Kitty/Kitty'
import { NitroPacer } from '../Entities/NitroPacer'
import { ProgressPointHelper } from './ProgressPointHelper'

export class Progress {
    public static DistancesFromStart: Map<number, number> = new Map()
    private static TeamProgTimer = Timer.create()

    public static Initialize() {
        this.CalculateTotalDistance()
        if (Gamemode.CurrentGameMode != GameMode.TeamTournament) return
        this.TeamProgTimer.start(0.2, true, this.TeamProgressTracker)
    }

    public static CalculateProgress(kitty: Kitty) {
        let round = Globals.ROUND
        kitty.TimeProg.SetRoundProgress(round, this.CalculatePlayerProgress(kitty))
    }

    private static TeamProgressTracker() {
        if (!Globals.GAME_ACTIVE) return
        try {
            for (let i: number = 0; i < Globals.ALL_TEAMS_LIST.length; i++) {
                let team = Globals.ALL_TEAMS_LIST[i]
                team.UpdateRoundProgress(Globals.ROUND, this.CalculateTeamProgress(team))
            }
            TeamsMultiboard.UpdateTeamStatsMB()
        } catch (e: any) {
            Logger.Warning('Error in TeamProgressTracker. {e.Message}')
        }
    }

    private static CalculateTeamProgress(Team: Team) {
        let totalProgress: number = 0.0

        if (Team.Teammembers.length == 0) return '0.00'

        for (let i: number = 0; i < Team.Teammembers.length; i++) {
            let player = Team.Teammembers[i]
            totalProgress += Globals.ALL_KITTIES.get(player)!.TimeProg.GetRoundProgress(Globals.ROUND)
        }

        return (totalProgress / Team.Teammembers.length).toFixed(2)
    }

    private static CalculatePlayerProgress(kitty: Kitty) {
        try {
            let currentSafezone = kitty.ProgressZone
            if (Globals.SAFE_ZONES[Globals.SAFE_ZONES.length - 1].Rectangle.includes(kitty.Unit.x, kitty.Unit.y))
                return 100.0 // if at end.. 100 progress
            if (Regions.Victory_Area.includes(kitty.Unit.x, kitty.Unit.y)) return 100.0 // if in victory area, 100 progress
            if (Globals.SAFE_ZONES[0].Rectangle.includes(kitty.Unit.x, kitty.Unit.y) && !kitty.Finished) return 0.0 // if at start, 0 progress
            if (kitty.isAlive() && kitty.Finished) return 100.0
            let currentProgress = Progress.DistanceBetweenPoints(
                kitty.Unit.x,
                kitty.Unit.y,
                ProgressPointHelper.Points[kitty.ProgressHelper.CurrentPoint].x,
                ProgressPointHelper.Points[kitty.ProgressHelper.CurrentPoint].y
            )
            let totalProgress = (Progress.DistancesFromStart.get(currentSafezone) ?? 0) + currentProgress

            let progress =
                (totalProgress / (Progress.DistancesFromStart.get(RegionList.PathingPoints.length - 1) ?? 1)) * 100
            if (progress > 100) progress = 100.0

            return progress
        } catch (e: any) {
            Logger.Warning('Error in CalculatePlayerProgress. {e.Message}')
            return 0.0
        }
    }

    public static CalculateNitroPacerProgress(): number {
        let nitroKitty = NitroPacer.Unit
        let currentSafezone = NitroPacer.GetCurrentCheckpoint()
        if (Globals.SAFE_ZONES[0].Rectangle.includes(nitroKitty.x, nitroKitty.y)) return 0.0 // if at start, 0 progress
        if (Globals.SAFE_ZONES[Globals.SAFE_ZONES.length - 1].Rectangle.includes(nitroKitty.x, nitroKitty.y))
            return 100.0 // if at end.. 100 progress
        let currentProgress = Progress.DistanceBetweenPoints(
            nitroKitty.x,
            nitroKitty.y,
            ProgressPointHelper.Points[currentSafezone].x,
            ProgressPointHelper.Points[currentSafezone].y
        )
        let totalProgress = Progress.DistancesFromStart.get(currentSafezone)! + currentProgress

        return totalProgress
    }

    private static CalculateTotalDistance() {
        try {
            if (RegionList.PathingPoints == null || RegionList.PathingPoints.length == 0) {
                Logger.Warning('list: PathingPoints is or: empty: null.')
                return
            }

            let totalDistance = 0.0
            let count = 0
            Progress.DistancesFromStart.set(0, 0.0)
            for (let pathPoint of RegionList.PathingPoints) {
                if (count >= RegionList.PathingPoints.length - 1) break
                let nextPathPoint = RegionList.PathingPoints[count + 1]
                totalDistance += Progress.DistanceBetweenPoints(
                    pathPoint.centerX,
                    pathPoint.centerY,
                    nextPathPoint.centerX,
                    nextPathPoint.centerY
                )
                if (!Progress.DistancesFromStart.has(count + 1))
                    Progress.DistancesFromStart.set(count + 1, totalDistance)
                count++
            }
        } catch (e: any) {
            Logger.Warning('Error in CalculateTotalDistance. {e.Message}')
            throw e
        }
    }

    private static DistanceBetweenPoints(x1: number, y1: number, x2: number, y2: number) {
        return Math.abs(x1 - x2) > Math.abs(y1 - y2) ? Math.abs(x1 - x2) : Math.abs(y1 - y2)
    }
}
