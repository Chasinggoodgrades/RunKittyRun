import { Constants } from 'src/AutoGenerated/Constants'
import { PROD } from 'src/env'
import { Logger } from 'src/Events/Logger/Logger'
import { Kitty } from 'src/Game/Entities/Kitty/Kitty'
import { Globals } from 'src/Global/Globals'
import { TeamDeathless } from 'src/Rewards/Challenges/TeamDeathless'
import { ErrorHandler } from 'src/Utility/ErrorHandler'
import { GC } from 'src/Utility/GC'
import { Utility } from 'src/Utility/Utility'
import { getFilterUnit, getTriggerUnit } from 'src/Utility/w3tsUtils'
import { Group, MapPlayer, Trigger, Unit } from 'w3ts'
import { PlayerUpgrades } from '../PlayerUpgrades'
import { Relic } from '../Relic'
import { RelicUpgrade } from '../RelicUpgrade'
import { RelicUtil } from '../RelicUtil'

export class RingOfSummoning extends Relic {
    public static RelicItemID: number = Constants.ITEM_SACRED_RING_OF_SUMMONING
    public static RelicAbilityID: number = Constants.ABILITY_TAKE_EM_WITH_RING_ULTIMATE
    private static RelicCost: number = 650
    private static SUMMONING_RING_RADIUS: number = 300.0
    private static SUMMONING_COOLDOWN: number = 90.0
    private static UPGRADE_COOLDOWN_REDUCTION: number = 30.0
    private static IconPath: string = 'war3mapImported\\BTNArcaniteNightRing.blp'
    private triggerHandle: Trigger
    private Owner: Unit | null
    private SummonGroup: Group

    public constructor() {
        super(
            '{Colors.COLOR_GREEN}Sacred Ring of Summoning|r',
            'On use, summons a fellow kitty within a {Colors.COLOR_ORANGE}{SUMMONING_RING_RADIUS} targeted AoE. |r Reviving a dead kitty requires them to be ahead of you.' +
                ' {Colors.COLOR_ORANGE}(Active)|r {Colors.COLOR_LIGHTBLUE}(1min 30sec Cooldown)|r',
            RingOfSummoning.RelicAbilityID,
            RingOfSummoning.RelicItemID,
            RingOfSummoning.RelicCost,
            RingOfSummoning.IconPath
        )

        this.Upgrades.push(
            new RelicUpgrade(
                0,
                'Cooldown of summoning ability reduced by {UPGRADE_COOLDOWN_REDUCTION} seconds.',
                15,
                800
            )
        )
        this.Upgrades.push(new RelicUpgrade(1, 'Summons one additional player within your targeted AoE.', 20, 1000))
    }

    private RegisterTriggers(Unit: Unit) {
        this.triggerHandle = Trigger.create()!
        TriggerRegisterUnitEvent(this.triggerHandle.handle, Unit.handle, EVENT_UNIT_SPELL_EFFECT)
        this.triggerHandle.addCondition(Condition(() => GetSpellAbilityId() === this.RelicAbilityID))
        this.triggerHandle.addAction(ErrorHandler.Wrap(this.SacredRingOfSummoning))
    }

    public override ApplyEffect(Unit: Unit) {
        this.RegisterTriggers(Unit)
        this.Owner = Unit
        Unit.disableAbility(this.RelicAbilityID, false, false)
        Utility.SimpleTimer(0.1, () => this.SetAbilityData(Unit))
    }

    public override RemoveEffect(Unit: Unit) {
        GC.RemoveTrigger(this.triggerHandle) // TODO; Cleanup:         GC.RemoveTrigger(ref Trigger);
        GC.RemoveGroup(this.SummonGroup) // TODO; Cleanup:         GC.RemoveGroup(ref SummonGroup);
        this.Owner = null
        Unit.disableAbility(this.RelicAbilityID, false, true)
    }

    /// <summary>
    /// Sets ability cooldown and radius based on upgrade level.
    /// </summary>
    /// <param name="Unit"></param>
    private SetAbilityData(Unit: Unit) {
        let ability = Unit.getAbility(this.RelicAbilityID)!
        let upgradeLevel = PlayerUpgrades.GetPlayerUpgrades(Unit.owner).GetUpgradeLevel(this.name)

        // Summon radius thingy
        BlzSetAbilityRealLevelField(ability, ABILITY_RLF_AREA_OF_EFFECT, 0, RingOfSummoning.SUMMONING_RING_RADIUS)

        let cooldown =
            upgradeLevel >= 1
                ? RingOfSummoning.SUMMONING_COOLDOWN - RingOfSummoning.UPGRADE_COOLDOWN_REDUCTION
                : RingOfSummoning.SUMMONING_COOLDOWN

        // Set cooldown based on the upgrade lvl.
        RelicUtil.SetAbilityCooldown(Unit, RingOfSummoning.RelicItemID, this.RelicAbilityID, cooldown)
    }

    private SacredRingOfSummoning() {
        // Retrieve event details
        let player: MapPlayer = getTriggerUnit().owner
        let targetedPoint: location = GetSpellTargetLoc()!
        let summoningKitty: Kitty = Globals.ALL_KITTIES.get(player)!
        let summoningKittyUnit: Unit = summoningKitty.Unit
        let numberOfSummons: number = this.GetNumberOfSummons(player)

        // Ensure SummonGroup exists
        this.SummonGroup ??= Group.create()!

        // Prepare relic mechanics
        RelicUtil.CloseRelicBookPlayer(player)
        if (!this.Owner) return
        Utility.SimpleTimer(0.1, () =>
            RelicUtil.SetRelicCooldowns(this.Owner!, RingOfSummoning.RelicItemID, this.RelicAbilityID)
        )

        // Filter eligible summon targets
        let filter = Utility.CreateFilterFunc(() => RingOfSummoning.CircleFilter() || RingOfSummoning.KittyFilter())
        this.SummonGroup.enumUnitsInRange(
            GetLocationX(targetedPoint),
            GetLocationY(targetedPoint),
            RingOfSummoning.SUMMONING_RING_RADIUS,
            filter
        )
        this.SummonGroup.removeUnit(summoningKittyUnit) // Ensure self is not included

        // Summon loop
        let count: number = 0
        while (this.SummonGroup.first && count < numberOfSummons) {
            let unit: Unit = this.SummonGroup.first
            this.SummonGroup.removeUnit(unit)

            let kitty: Kitty = Globals.ALL_KITTIES.get(unit.owner)!
            if (
                !this.SummonDeadKitty(summoningKitty, kitty) ||
                !this.DeathlessKitty(summoningKitty, kitty) ||
                !this.ChainedKitty(summoningKitty, kitty)
            )
                continue

            // Position adjustments and revival
            kitty.Unit.setPosition(summoningKittyUnit.x, summoningKittyUnit.y)
            kitty.ProgressZone = summoningKitty.ProgressZone
            Globals.ALL_CIRCLES.get(unit.owner)!.Unit.setPosition(summoningKittyUnit.x, summoningKittyUnit.y)
            kitty.ReviveKitty(summoningKitty)

            // Notify players
            Utility.TimedTextToAllPlayers(
                3.0,
                "{Colors.PlayerNameColored(player)} summoned: has {Colors.PlayerNameColored(kitty.Player)}'kitty: s!"
            )

            count++
        }

        // Cleanup
        RemoveLocation(targetedPoint)
        GC.RemoveFilterFunc(filter) // TODO; Cleanup:         GC.RemoveFilterFunc(ref filter);
    }

    /// <summary>
    /// This function will only return true if the summoned kitty is dead and ahead of the summoner.
    /// </summary>
    /// <param name="summoner"></param>
    /// <param name="summoned"></param>
    /// <returns></returns>
    private SummonDeadKitty(summoner: Kitty, summoned: Kitty) {
        let round = Globals.ROUND
        let summoersProgress = summoner.TimeProg.GetRoundProgress(round)
        let deadProg = summoned.TimeProg.GetRoundProgress(round)

        if (!PROD)
            Logger.Verbose(
                'Summoner: {summoner.Player.name} | Progress: Summoner: {summoersProgress} | Summoned: {summoned.Player.name} | Progress: Summoned: {deadProg}'
            )

        if (summoersProgress > deadProg && !summoned.isAlive()) {
            summoner.Player.DisplayTimedTextTo(
                5.0,
                '{Colors.COLOR_RED}can: only: summon: dead: kitties: that: are: ahead: You of you!{Colors.COLOR_RESET}'
            )
            return false
        }
        return true
    }

    private DeathlessKitty(summonerKitty: Kitty, summonedKittyUnit: Kitty) {
        if (TeamDeathless.CurrentHolder !== summonedKittyUnit) return true

        summonerKitty.Player.DisplayTimedTextTo(
            5.0,
            '{Colors.COLOR_RED}cannot: summon: kitties: holding: the: deathless: orb: You!{Colors.COLOR_RESET}'
        )
        return false
    }

    private ChainedKitty(summonerKitty: Kitty, summonedKittyUnit: Kitty) {
        if (!summonedKittyUnit.IsChained) return true
        summonerKitty.Player.DisplayTimedTextTo(
            5.0,
            '{Colors.COLOR_RED}cannot: summon: kitties: that: are: chained: You!{Colors.COLOR_RESET}'
        )
        return false
    }

    /// <summary>
    /// Returns the number of kitties that can be summoned based on the upgrade level.
    /// </summary>
    /// <param name="player"></param>
    /// <returns></returns>
    private GetNumberOfSummons(player: MapPlayer) {
        let upgradeLevel = PlayerUpgrades.GetPlayerUpgrades(player).GetUpgradeLevel(typeof RingOfSummoning)
        return upgradeLevel >= 2 ? 2 : 1
    }

    private static KittyFilter(): boolean {
        return getFilterUnit().typeId === Constants.UNIT_KITTY
    }

    private static CircleFilter(): boolean {
        return getFilterUnit().typeId === Constants.UNIT_KITTY_CIRCLE
    }
}
