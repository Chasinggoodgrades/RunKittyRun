import { Constants } from 'src/AutoGenerated/Constants'
import { PROD } from 'src/env'
import { Logger } from 'src/Events/Logger/Logger'
import { Kitty } from 'src/Game/Entities/Kitty/Kitty'
import { Globals } from 'src/Global/Globals'
import { TeamDeathless } from 'src/Rewards/Challenges/TeamDeathless'
import { Colors } from 'src/Utility/Colors/Colors'
import { ColorUtils } from 'src/Utility/Colors/ColorUtils'
import { GC } from 'src/Utility/GC'
import { Utility } from 'src/Utility/Utility'
import { getFilterUnit, getTriggerUnit } from 'src/Utility/w3tsUtils'
import { Group, MapPlayer, Trigger, Unit } from 'w3ts'
import { PlayerUpgrades } from '../PlayerUpgrades'
import { Relic } from '../Relic'
import { RelicUpgrade } from '../RelicUpgrade'
import { RelicUtil } from '../RelicUtil'

export class RingOfSummoning extends Relic {
    public static RelicItemID = Constants.ITEM_SACRED_RING_OF_SUMMONING
    public static RelicAbilityID = Constants.ABILITY_TAKE_EM_WITH_RING_ULTIMATE
    private static RelicCost = 650
    private static SUMMONING_RING_RADIUS = 300.0
    private static SUMMONING_COOLDOWN = 90.0
    private static UPGRADE_COOLDOWN_REDUCTION = 30.0
    private static IconPath = 'war3mapImported\\BTNArcaniteNightRing.blp'
    private triggerHandle: Trigger | undefined
    private Owner: Unit | undefined
    private SummonGroup!: Group

    public constructor() {
        super(
            `${Colors.COLOR_GREEN}Sacred Ring of Summoning|r`,
            `On use, summons a fellow kitty within a ${Colors.COLOR_ORANGE}${RingOfSummoning.SUMMONING_RING_RADIUS} targeted AoE. |r Reviving a dead kitty requires them to be ahead of you.` +
                ` ${Colors.COLOR_ORANGE}(Active)|r ${Colors.COLOR_LIGHTBLUE}(1min 30sec Cooldown)|r`,
            RingOfSummoning.RelicAbilityID,
            RingOfSummoning.RelicItemID,
            RingOfSummoning.RelicCost,
            RingOfSummoning.IconPath
        )

        this.Upgrades.push(
            new RelicUpgrade(
                0,
                `Cooldown of summoning ability reduced by ${RingOfSummoning.UPGRADE_COOLDOWN_REDUCTION} seconds.`,
                15,
                800
            )
        )
        this.Upgrades.push(new RelicUpgrade(1, 'Summons one additional player within your targeted AoE.', 20, 1000))
    }

    private RegisterTriggers = (Unit: Unit) => {
        this.triggerHandle = Trigger.create()!
        TriggerRegisterUnitEvent(this.triggerHandle.handle, Unit.handle, EVENT_UNIT_SPELL_EFFECT)
        this.triggerHandle.addCondition(() => GetSpellAbilityId() === this.RelicAbilityID)
        this.triggerHandle.addAction(this.SacredRingOfSummoning)
    }

    public override ApplyEffect(Unit: Unit) {
        this.RegisterTriggers(Unit)
        this.Owner = Unit
        Unit.disableAbility(this.RelicAbilityID, false, false)
        Utility.SimpleTimer(0.1, () => this.SetAbilityData(Unit))
    }

    public override RemoveEffect(Unit: Unit) {
        GC.RemoveTrigger(this.triggerHandle)
        GC.RemoveGroup(this.SummonGroup)
        this.Owner = undefined
        Unit.disableAbility(this.RelicAbilityID, false, true)
    }

    /// <summary>
    /// Sets ability cooldown and radius based on upgrade level.
    /// </summary>
    /// <param name="Unit"></param>
    private SetAbilityData = (Unit: Unit) => {
        const ability = Unit.getAbility(this.RelicAbilityID)!
        const upgradeLevel = PlayerUpgrades.GetPlayerUpgrades(Unit.owner).GetUpgradeLevel(RingOfSummoning.name)

        // Summon radius thingy
        BlzSetAbilityRealLevelField(ability, ABILITY_RLF_AREA_OF_EFFECT, 0, RingOfSummoning.SUMMONING_RING_RADIUS)

        const cooldown =
            upgradeLevel >= 1
                ? RingOfSummoning.SUMMONING_COOLDOWN - RingOfSummoning.UPGRADE_COOLDOWN_REDUCTION
                : RingOfSummoning.SUMMONING_COOLDOWN

        // Set cooldown based on the upgrade lvl.
        RelicUtil.SetAbilityCooldown(Unit, RingOfSummoning.RelicItemID, this.RelicAbilityID, cooldown)
    }

    private SacredRingOfSummoning = () => {
        // Retrieve event details
        const player: MapPlayer = getTriggerUnit().owner
        const targetedPoint: location = GetSpellTargetLoc()!
        const summoningKitty: Kitty = Globals.ALL_KITTIES.get(player)!
        const summoningKittyUnit: Unit = summoningKitty.Unit
        const numberOfSummons = this.GetNumberOfSummons(player)

        // Ensure SummonGroup exists
        this.SummonGroup ??= Group.create()!

        // Prepare relic mechanics
        RelicUtil.CloseRelicBookPlayer(player)
        if (!this.Owner) return
        Utility.SimpleTimer(0.1, () =>
            RelicUtil.SetRelicCooldowns(this.Owner!, RingOfSummoning.RelicItemID, this.RelicAbilityID)
        )

        // Filter eligible summon targets
        const filter = Utility.CreateFilterFunc(() => RingOfSummoning.CircleFilter() || RingOfSummoning.KittyFilter())
        this.SummonGroup.enumUnitsInRange(
            GetLocationX(targetedPoint),
            GetLocationY(targetedPoint),
            RingOfSummoning.SUMMONING_RING_RADIUS,
            filter
        )
        this.SummonGroup.removeUnit(summoningKittyUnit) // Ensure self is not included

        // Summon loop
        let count = 0
        while (this.SummonGroup.first && count < numberOfSummons) {
            const unit: Unit = this.SummonGroup.first
            this.SummonGroup.removeUnit(unit)

            const kitty: Kitty = Globals.ALL_KITTIES.get(unit.owner)!
            if (
                !this.SummonDeadKitty(summoningKitty, kitty) ||
                !this.DeathlessKitty(summoningKitty, kitty) ||
                !this.ChainedKitty(summoningKitty, kitty)
            )
                continue

            // Position adjustments and revival
            kitty.Unit.setPosition(summoningKittyUnit.x, summoningKittyUnit.y)
            kitty.ProgressZone = summoningKitty.ProgressZone
            Globals.ALL_CIRCLES.get(unit.owner)!.Unit.setPosition(summoningKittyUnit.x, summoningKittyUnit.y)
            kitty.ReviveKitty(summoningKitty)

            // Notify players
            Utility.TimedTextToAllPlayers(
                3.0,
                `${ColorUtils.PlayerNameColored(player)} has summoned ${ColorUtils.PlayerNameColored(kitty.Player)}'s kitty!`
            )

            count++
        }

        // Cleanup
        RemoveLocation(targetedPoint)
        GC.RemoveFilterFunc(filter)
    }

    /// <summary>
    /// This function will only return true if the summoned kitty is dead and ahead of the summoner.
    /// </summary>
    /// <param name="summoner"></param>
    /// <param name="summoned"></param>
    /// <returns></returns>
    private SummonDeadKitty = (summoner: Kitty, summoned: Kitty) => {
        const round = Globals.ROUND
        const summoersProgress = summoner.TimeProg.GetRoundProgress(round)
        const deadProg = summoned.TimeProg.GetRoundProgress(round)

        if (!PROD)
            Logger.Verbose(
                `Summoner: ${summoner.Player.name} | Summoner Progress: ${summoersProgress} | Summoned: ${summoned.Player.name} | Summoned Progress: ${deadProg}`
            )

        if (summoersProgress > deadProg && !summoned.isAlive()) {
            summoner.Player.DisplayTimedTextTo(
                5.0,
                `${Colors.COLOR_RED}You can only summon dead kitties that are ahead of you!${Colors.COLOR_RESET}`
            )
            return false
        }
        return true
    }

    private DeathlessKitty = (summonerKitty: Kitty, summonedKittyUnit: Kitty) => {
        if (TeamDeathless.CurrentHolder !== summonedKittyUnit) return true

        summonerKitty.Player.DisplayTimedTextTo(
            5.0,
            `${Colors.COLOR_RED}You cannot summon kitties holding the deathless orb!${Colors.COLOR_RESET}`
        )
        return false
    }

    private ChainedKitty = (summonerKitty: Kitty, summonedKittyUnit: Kitty) => {
        if (!summonedKittyUnit.IsChained) return true
        summonerKitty.Player.DisplayTimedTextTo(
            5.0,
            `${Colors.COLOR_RED}You cannot summon kitties that are chained!${Colors.COLOR_RESET}`
        )
        return false
    }

    /// <summary>
    /// Returns the number of kitties that can be summoned based on the upgrade level.
    /// </summary>
    /// <param name="player"></param>
    /// <returns></returns>
    private GetNumberOfSummons = (player: MapPlayer) => {
        const upgradeLevel = PlayerUpgrades.GetPlayerUpgrades(player).GetUpgradeLevel(RingOfSummoning.name)
        return upgradeLevel >= 2 ? 2 : 1
    }

    private static KittyFilter(): boolean {
        return getFilterUnit().typeId === Constants.UNIT_KITTY
    }

    private static CircleFilter(): boolean {
        return getFilterUnit().typeId === Constants.UNIT_KITTY_CIRCLE
    }
}
