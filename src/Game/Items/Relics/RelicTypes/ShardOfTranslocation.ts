import { Constants } from 'src/AutoGenerated/Constants'
import { Logger } from 'src/Events/Logger/Logger'
import { Globals } from 'src/Global/Globals'
import { RegionList } from 'src/Global/RegionList'
import { Colors } from 'src/Utility/Colors/Colors'
import { GC } from 'src/Utility/GC'
import { distanceBetweenXYPoints, Utility } from 'src/Utility/Utility'
import { getTriggerUnit } from 'src/Utility/w3tsUtils'
import { Trigger, Unit } from 'w3ts'
import { PlayerUpgrades } from '../PlayerUpgrades'
import { Relic } from '../Relic'
import { RelicUpgrade } from '../RelicUpgrade'
import { RelicUtil } from '../RelicUtil'

export class ShardOfTranslocation extends Relic {
    public static RelicItemID: number = Constants.ITEM_SHARD_OF_TRANSLOCATION
    public static RelicAbilityID: number = Constants.ABILITY_TRANSLOCATE
    private static RelicCost = 650
    private static DEFAULT_BLINK_RANGE = 450.0
    private static UPGRADE_BLINK_RANGE = 650.0
    private static DEFAULT_COOLDOWN = 90.0
    private static CooldownReduction = 30.0
    private Owner: Unit
    private static IconPath: string = 'ReplaceableTextures/CommandButtons/BTNShardOfTranslocation.blp'
    private MaxBlinkRange = ShardOfTranslocation.DEFAULT_BLINK_RANGE
    private CastEventTrigger: Trigger

    public constructor() {
        super(
            '|c7eb66ff1Shard of Translocation|r',
            `Teleports the user to a targeted location within ${ShardOfTranslocation.DEFAULT_BLINK_RANGE} range, restricted to lane bounds.${Colors.COLOR_ORANGE}(Active) ${Colors.COLOR_LIGHTBLUE}(1min 30 sec cooldown).|r`,
            ShardOfTranslocation.RelicAbilityID,
            ShardOfTranslocation.RelicItemID,
            ShardOfTranslocation.RelicCost,
            ShardOfTranslocation.IconPath
        )

        this.Upgrades.push(
            new RelicUpgrade(
                0,
                `Extends the teleport range to ${ShardOfTranslocation.UPGRADE_BLINK_RANGE} yrds within lane bounds.`,
                15,
                800
            )
        )
        this.Upgrades.push(
            new RelicUpgrade(1, `Cooldown reduced by ${ShardOfTranslocation.CooldownReduction} seconds.`, 20, 1000)
        )
    }

    public override ApplyEffect(Unit: Unit) {
        this.RegisterTrigger(Unit)
        this.UpdateBlinkRange(Unit)
        this.Owner = Unit
        Unit.disableAbility(Constants.ABILITY_TRANSLOCATE, false, false)
        Utility.SimpleTimer(0.1, () => this.SetAbilityData(Unit))
    }

    public override RemoveEffect(Unit: Unit) {
        GC.RemoveTrigger(this.CastEventTrigger) // TODO; Cleanup:         GC.RemoveTrigger(ref CastEventTrigger);
        Unit.disableAbility(Constants.ABILITY_TRANSLOCATE, false, true)
    }

    private RegisterTrigger = (Unit: Unit) => {
        const player = Unit.owner
        const CastEventTrigger = Trigger.create()!
        CastEventTrigger.registerPlayerUnitEvent(player, EVENT_PLAYER_UNIT_SPELL_CAST, () => true)
        CastEventTrigger.addAction(() => this.TeleportActions())
    }

    private TeleportActions = () => {
        if (!Globals.GAME_ACTIVE) return
        if (GetSpellAbilityId() !== this.RelicAbilityID) return
        const unit = getTriggerUnit()
        const targetLoc = GetSpellTargetLoc()!
        const player = unit.owner
        const currentSafezone = Globals.ALL_KITTIES.get(player)!.CurrentSafeZone
        try {
            if (!ShardOfTranslocation.EligibleLocation(targetLoc, currentSafezone)) {
                player.DisplayTimedTextTo(
                    5.0,
                    `${Colors.COLOR_RED}Invalid location. Must be within safezone bounds.${Colors.COLOR_RESET}`
                )
                Utility.SimpleTimer(0.1, () =>
                    RelicUtil.SetRelicCooldowns(this.Owner, ShardOfTranslocation.RelicItemID, this.RelicAbilityID, 1)
                )
                Utility.SimpleTimer(0.15, () => Utility.UnitAddMana(this.Owner, 200))
                return
            }

            this.TeleportUnit(unit, targetLoc)
            RelicUtil.CloseRelicBook(unit)
            Utility.SimpleTimer(0.1, () =>
                RelicUtil.SetRelicCooldowns(this.Owner, ShardOfTranslocation.RelicItemID, this.RelicAbilityID)
            )
            RemoveLocation(targetLoc)
        } catch (e) {
            Logger.Critical(e as string)
            throw e
        }
    }

    private UpdateBlinkRange = (unit: Unit) => {
        const upgradeLevel = PlayerUpgrades.GetPlayerUpgrades(unit.owner).GetUpgradeLevel(ShardOfTranslocation.name)
        this.MaxBlinkRange =
            upgradeLevel >= 1 ? ShardOfTranslocation.UPGRADE_BLINK_RANGE : ShardOfTranslocation.DEFAULT_BLINK_RANGE
        if (upgradeLevel >= 1) Utility.SimpleTimer(0.1, () => this.SetItemTooltip(unit))
    }

    private SetItemTooltip = (unit: Unit) => {
        const item = Utility.UnitGetItem(unit, ShardOfTranslocation.RelicItemID)!
        BlzSetItemExtendedTooltip(
            item.handle,
            `${Colors.COLOR_YELLOW_ORANGE}The holder of this shard can harness arcane energy to blink to a new location within ${Colors.COLOR_LAVENDER}${this.MaxBlinkRange.toFixed(2)}|r range.|nThe shard recharges over time.|n|cffff8c00Allows the holder to teleport within lane bounds.|r |cffadd8e6(Activate)|r\r`
        )
    }

    /// <summary>
    /// Sets ability cooldown and radius based on upgrade level.
    /// </summary>
    /// <param name="Unit"></param>
    private SetAbilityData = (Unit: Unit) => {
        Unit.getAbility(this.RelicAbilityID)
        const upgradeLevel = PlayerUpgrades.GetPlayerUpgrades(Unit.owner).GetUpgradeLevel(ShardOfTranslocation.name)

        const cooldown =
            upgradeLevel >= 2 // lvl 2 upgrade
                ? ShardOfTranslocation.DEFAULT_COOLDOWN - ShardOfTranslocation.CooldownReduction
                : ShardOfTranslocation.DEFAULT_COOLDOWN

        // Set cooldown based on the upgrade lvl.
        RelicUtil.SetAbilityCooldown(Unit, ShardOfTranslocation.RelicItemID, this.RelicAbilityID, cooldown)
    }

    private TeleportUnit = (unit: Unit, targetLoc: location) => {
        let x = GetLocationX(targetLoc)
        let y = GetLocationY(targetLoc)
        const distance = distanceBetweenXYPoints(unit.x, unit.y, x, y)

        if (distance > this.MaxBlinkRange) {
            const angle = Atan2(y - unit.y, x - unit.x)
            x = unit.x + this.MaxBlinkRange * Cos(angle)
            y = unit.y + this.MaxBlinkRange * Sin(angle)
        }
        unit.setPosition(x, y)
    }

    private static EligibleLocation = (targetLoc: location, currentSafezone: number) => {
        const SAFEZONES = Globals.SAFE_ZONES
        return (
            SAFEZONES[currentSafezone].Rectangle.includes(GetLocationX(targetLoc), GetLocationY(targetLoc)) ||
            (currentSafezone > 0 &&
                SAFEZONES[currentSafezone - 1].Rectangle.includes(GetLocationX(targetLoc), GetLocationY(targetLoc))) ||
            (currentSafezone < SAFEZONES.length - 1 &&
                SAFEZONES[currentSafezone + 1].Rectangle.includes(GetLocationX(targetLoc), GetLocationY(targetLoc)) &&
                currentSafezone < 13) ||
            ShardOfTranslocation.WolfRegionEligible(targetLoc, currentSafezone)
        )
    }

    private static WolfRegionEligible = (targetLoc: location, currentSafezone: number) => {
        const WOLF_AREAS = RegionList.WolfRegions
        if (WOLF_AREAS[currentSafezone].includes(GetLocationX(targetLoc), GetLocationY(targetLoc))) return true
        if (
            currentSafezone > 0 &&
            WOLF_AREAS[currentSafezone - 1].includes(GetLocationX(targetLoc), GetLocationY(targetLoc))
        )
            return true
        if (WOLF_AREAS[currentSafezone + 1].includes(GetLocationX(targetLoc), GetLocationY(targetLoc))) return true
        if (currentSafezone === 13 || currentSafezone === 14) {
            if (WOLF_AREAS[14].includes(GetLocationX(targetLoc), GetLocationY(targetLoc))) return true
            if (WOLF_AREAS[15].includes(GetLocationX(targetLoc), GetLocationY(targetLoc))) return true
            if (WOLF_AREAS[16].includes(GetLocationX(targetLoc), GetLocationY(targetLoc))) return true
        }
        return false
    }
}
