import { Constants } from 'src/AutoGenerated/Constants'
import { Logger } from 'src/Events/Logger/Logger'
import { Globals } from 'src/Global/Globals'
import { RegionList } from 'src/Global/RegionList'
import { KibbleEvent } from 'src/Rewards/EasterEggs/KibbleEvent'
import { HolidaySeasons, SeasonalManager } from 'src/Seasonal/SeasonalManager'
import { SoundManager } from 'src/Sounds/SoundManager'
import { Colors } from 'src/Utility/Colors/Colors'
import { IDisposable } from 'src/Utility/CSUtils'
import { GC } from 'src/Utility/GC'
import { MemoryHandler } from 'src/Utility/MemoryHandler/MemoryHandler'
import { Utility } from 'src/Utility/Utility'
import { getTriggerUnit } from 'src/Utility/w3tsUtils'
import { Effect, Trigger } from 'w3ts'
import { Kitty } from '../Entities/Kitty/Kitty'
import { PersonalBestAwarder } from '../Podium/PersonalBestAwarder'
import { ItemSpatialGrid } from './ItemSpatialGrid'
import { ItemSpawner } from './ItemSpawner'

export class Kibble extends IDisposable {
    public static PickupTrigger: Trigger
    public static SpawningKibble: boolean = true
    private static KibblesColors: number[] = Kibble.KibbleList()
    private static StarfallEffect: string = 'Abilities\\Spells\\NightElf\\Starfall\\StarfallTarget.mdl'
    private static TextTagHeight: number = 0.018
    private static XPMax: number = 350
    private static GoldMax: number = 150
    private static JackpotMin: number = 600
    private static JackpotMax: number = 1500

    public Item: item
    private Type: number
    private JackPotIndex: number
    private StarFallEffect: Effect

    public Kibble() {
        Kibble.PickupTrigger ??= Kibble.KibblePickupEvents()
        this.Type = Kibble.RandomKibbleType()
    }

    public dispose() {
        this.Item?.dispose()
        this.Item = null
        MemoryHandler.destroyObject(this)
    }

    public SpawnKibble() {
        let regionNumber = GetRandomInt(0, RegionList.WolfRegions.length - 1)
        let region = RegionList.WolfRegions[regionNumber]
        let x = GetRandomReal(region.Rect.minX, region.Rect.maxX)
        let y = GetRandomReal(region.Rect.minY, region.Rect.maxY)
        this.StarFallEffect ??= AddSpecialEffect(Kibble.StarfallEffect, x, y)
        this.StarFallEffect.setPos(x, y, 0)
        this.StarFallEffect.playAnimation(ANIM_TYPE_BIRTH)
        this.JackPotIndex = 1
        this.Item = this.Item.create(this.Type, x, y)!
        ItemSpatialGrid.RegisterKibble(this)
    }

    // #region Kibble Initialization

    private static RandomKibbleType(): number {
        return Kibble.KibblesColors[GetRandomInt(0, Kibble.KibblesColors.length - 1)]
    }

    private static KibblePickupEvents(): Trigger {
        let trig = Trigger.create()!
        trig.registerAnyUnitEvent(playerunitevent.PickupItem)
        trig.addAction(() => {
            let item = GetManipulatedItem()
            if (!Kibble.KibblesColors.includes(item.TypeId)) return
            Kibble.KibblePickup(item)
        })
        return trig
    }

    // #endregion Kibble Initialization

    // #region Kibble Pickup Logic

    private static KibblePickup(item: item) {
        try {
            if (item == null) return

            let unit = getTriggerUnit()
            let player = unit.owner
            let kitty = Globals.ALL_KITTIES.get(player)!
            let effect: Effect = null
            let randomChance = GetRandomReal(0, 100)
            let kib = ItemSpawner.TrackKibbles.find(k => k.Item == item)

            if (randomChance <= 30) Kibble.KibbleGoldReward(kitty, kib)
            else if (randomChance <= 60) Kibble.KibbleXP(kitty)
            else Kibble.KibbleNothing(kitty)

            if (randomChance <= 30)
                effect = AddSpecialEffect(
                    'Abilities\\Spells\\Other\\Transmute\\PileofGold.mdl',
                    kitty.Unit.x,
                    kitty.Unit.y
                )
            GC.RemoveEffect(effect) // TODO; Cleanup:             GC.RemoveEffect(ref effect);

            KibbleEvent.StartKibbleEvent(randomChance)
            KibbleEvent.CollectEventKibble()

            Kibble.IncrementKibble(kitty)
            PersonalBestAwarder.BeatKibbleCollection(kitty)

            if (kib != null && kib.Item != null) {
                kib.dispose()
            }
        } catch (e: any) {
            Logger.Warning('Kibble.Error: KibblePickup: {e.Message}')
            throw e
        }
    }

    private static KibbleGoldReward(kitty: Kitty, kib: Kibble) {
        let jackPotChance = GetRandomInt(0, 100)
        let goldAmount: number
        if (jackPotChance <= 3) {
            Kibble.JackpotEffect(kitty, kib)
            return
        } else goldAmount = GetRandomInt(1, Kibble.GoldMax)
        kitty.Player.addGold(goldAmount)
        Utility.CreateSimpleTextTag('+{goldAmount} Gold', 2.0, kitty.Unit, Kibble.TextTagHeight, 255, 215, 0)
    }

    private static KibbleXP(kitty: Kitty) {
        let xpAmount = GetRandomInt(50, Kibble.XPMax)
        kitty.Unit.Experience += xpAmount
        SoundManager.PlayKibbleTomeSound(kitty.Unit)
    }

    private static KibbleNothing(kitty: Kitty) {
        Utility.CreateSimpleTextTag('Nothing!', 2.0, kitty.Unit, Kibble.TextTagHeight, 50, 150, 150)
    }

    private static JackpotEffect(kitty: Kitty, kibble: Kibble) {
        let unitX = kitty.Unit.x
        let unitY = kitty.Unit.y
        let newX = WCSharp.Shared.Util.PositionWithPolarOffsetRadX(unitX, 150.0, kibble.JackPotIndex * 36.0)
        let newY = WCSharp.Shared.Util.PositionWithPolarOffsetRadY(unitY, 150.0, kibble.JackPotIndex * 36.0)

        let effect = AddSpecialEffect('Abilities\\Spells\\Other\\Transmute\\PileofGold.mdl', newX, newY)
        GC.RemoveEffect(effect) // TODO; Cleanup:         GC.RemoveEffect(ref effect);
        kibble.JackPotIndex += 1

        if (kibble.JackPotIndex >= 20) {
            let goldAmount = GetRandomInt(Kibble.JackpotMin, Kibble.JackpotMax)
            let isSuperJackpot = GetRandomInt(1, 10) == 1
            if (isSuperJackpot) goldAmount *= 10

            kitty.Player.Gold += goldAmount

            jackpotString = isSuperJackpot ? `${Colors.COLOR_RED}Super Jackpot${Colors.COLOR_RESET}` : 'jackpot'
            msg = `${Colors.PlayerNameColored(kitty.Player)}${Colors.HighlightString(` has won the ${jackpotString}`)} ${Colors.HighlightString('for')} ${Colors.COLOR_YELLOW_ORANGE}{goldAmount} Gold|r`

            Utility.TimedTextToAllPlayers(3.0, msg) // was too long previously.
            Utility.CreateSimpleTextTag(`+${goldAmount} Gold`, 2.0, kitty.Unit, Kibble.TextTagHeight, 255, 215, 0)
            if (isSuperJackpot) {
                kitty.SaveData.KibbleCurrency.SuperJackpots += 1
                kitty.CurrentStats.CollectedSuperJackpots += 1
            } else {
                kitty.SaveData.KibbleCurrency.Jackpots += 1
                kitty.CurrentStats.CollectedJackpots += 1
            }
        } else Utility.SimpleTimer(0.15, () => Kibble.JackpotEffect(kitty, kibble))
    }

    // #endregion Kibble Pickup Logic

    // #region Utility Methods

    private static IncrementKibble(kibblePicker: Kitty) {
        kibblePicker.CurrentStats.CollectedKibble += 1

        for (let player of Globals.ALL_PLAYERS) player.Lumber += 1

        kibblePicker.SaveData.KibbleCurrency.Collected += 1
    }

    private static KibbleList(): number[] {
        switch (SeasonalManager.Season) {
            case HolidaySeasons.Christmas: {
                return [Constants.ITEM_PRESENT]
            }

            // case HolidaySeasons.Easter: {
            //     return [Constants.ITEM_EASTER_EGG]
            // }

            case HolidaySeasons.Valentines: {
                return [Constants.ITEM_HEART]
            }

            default: {
                return [
                    // Default case
                    Constants.ITEM_KIBBLE,
                    Constants.ITEM_KIBBLE_TEAL,
                    Constants.ITEM_KIBBLE_GREEN,
                    Constants.ITEM_KIBBLE_PURPLE,
                    Constants.ITEM_KIBBLE_RED,
                    Constants.ITEM_KIBBLE_YELLOW,
                ]
            }
        }
    }

    // #endregion Utility Methods
}
