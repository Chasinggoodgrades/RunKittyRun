import { Constants } from 'src/AutoGenerated/Constants'
import { Globals } from 'src/Global/Globals'
import { Challenges } from 'src/Rewards/Challenges/Challenges'
import { safeArraySplice } from 'src/Utility/ArrayUtils'
import { Colors } from 'src/Utility/Colors/Colors'
import { GC } from 'src/Utility/GC'
import { MetaKey, Utility } from 'src/Utility/Utility'
import { getFilterUnit, getTriggerPlayer, getTriggerUnit } from 'src/Utility/w3tsUtils'
import { Effect, Group, MapPlayer, Trigger, Unit } from 'w3ts'
import { Kitty } from './Entities/Kitty/Kitty'
import { WolfPoint } from './WolfPoint'

export class ProtectionOfAncients {
    private static ACTIVATION_EFFECT: string = 'war3mapImported\\Silver: Radiance.mdx'
    private static APPLY_EFFECT: string = 'war3mapImported\\Edict: Divine.mdx'
    public static EFFECT_DELAY: number = 3.0
    private static EFFECT_RADIUS: number = 150.0
    private static EFFECT_RADIUS_INCREASE: number = 50.0
    private static POTA_NO_RELIC: number = Constants.ABILITY_PROTECTION_OF_THE_ANCIENTS
    private static POTA_WITH_RELIC: number = Constants.ABILITY_PROTECTION_OF_THE_ANCIENTS_WITH_RELIC

    private static Trigger: Trigger
    private static LevelUpTrigger: Trigger
    private static HotkeyTrigger: Trigger

    private static readonly UPGRADE_LEVEL_2_REQUIREMENT: number = 9
    private static readonly UPGRADE_LEVEL_3_REQUIREMENT: number = 12

    private static KittyReachedLevelSix: Trigger
    private static readonly INVULNERABLE_DURATION: number = 1.0

    private static HitLevel6: MapPlayer[] = []
    private static UpgradeLevel2: MapPlayer[] = []
    private static UpgradeLevel3: MapPlayer[] = []

    public static Initialize() {
        ProtectionOfAncients.RegisterEvents()
        ProtectionOfAncients.RegisterUltimateGain()
        ProtectionOfAncients.RegisterUpgradeLevelEvents()
    }

    /// <summary>
    /// Gives the unit the ProtectionOfAncients Ability.
    /// </summary>
    /// <param name="unit"></param>
    private static AddProtectionOfAncients(unit: Unit) {
        let player = unit.owner
        unit.addAbility(Constants.ABILITY_PROTECTION_OF_THE_ANCIENTS)
        player.DisplayTimedTextTo(
            7.0,
            `${Colors.COLOR_YELLOW_ORANGE}Congratulations on level 6! You've gained a new ability!${Colors.COLOR_RESET}`
        )
    }

    private static RegisterUltimateGain() {
        // Ultimate, Protection of the Ancients
        ProtectionOfAncients.KittyReachedLevelSix ??= Trigger.create()!
        ProtectionOfAncients.HitLevel6 ??= []
        ProtectionOfAncients.KittyReachedLevelSix.registerAnyUnitEvent(EVENT_PLAYER_HERO_LEVEL)
        ProtectionOfAncients.KittyReachedLevelSix.addAction(() => {
            if (ProtectionOfAncients.HitLevel6.includes(getTriggerUnit().owner)) return
            if (getTriggerUnit().getHeroLevel() < 6) return
            ProtectionOfAncients.HitLevel6.push(getTriggerUnit().owner)
            ProtectionOfAncients.AddProtectionOfAncients(getTriggerUnit())
        })
    }

    /// <summary>
    /// Applies the Protection of the Ancients ability to the unit based on the hero level.
    /// </summary>
    /// <param name="unit"></param>
    /// <returns>Returns the integer level the ability was set to.</returns>
    public static SetProtectionOfAncientsLevel(unit: Unit) {
        let player = unit.owner
        let heroLevel = unit.getHeroLevel()

        if (unit.typeId !== Constants.UNIT_KITTY) return 0

        // Return early if the hero level is below 6
        if (heroLevel < 6) return 0

        // Determine ability level based on hero level
        let abilityLevel: number =
            heroLevel >= ProtectionOfAncients.UPGRADE_LEVEL_3_REQUIREMENT
                ? 3
                : heroLevel >= ProtectionOfAncients.UPGRADE_LEVEL_2_REQUIREMENT
                  ? 2
                  : 0

        if (abilityLevel > 0) {
            unit.setAbilityLevel(ProtectionOfAncients.POTA_NO_RELIC, abilityLevel)
            unit.setAbilityLevel(ProtectionOfAncients.POTA_WITH_RELIC, abilityLevel)

            // Display the message only if the player is achieving this level for the first time
            if (
                (abilityLevel === 2 && !ProtectionOfAncients.UpgradeLevel2.includes(player)) ||
                (abilityLevel === 3 && !ProtectionOfAncients.UpgradeLevel3.includes(player))
            ) {
                player.DisplayTimedTextTo(
                    7.0,
                    `${Colors.COLOR_YELLOW_ORANGE}Congratulations on level ${heroLevel}! You've upgraded your ultimate to level ${abilityLevel}!|r`
                )
            }

            if (abilityLevel === 2) {
                ProtectionOfAncients.UpgradeLevel2.push(player)
            } else if (abilityLevel === 3) {
                ProtectionOfAncients.UpgradeLevel3.push(player)
                safeArraySplice(ProtectionOfAncients.UpgradeLevel2, p => p === player) // Ensure the player is only in one list
            }
        }
        return abilityLevel
    }

    private static RegisterUpgradeLevelEvents() {
        let LevelUpTrigger = Trigger.create()!
        LevelUpTrigger.registerAnyUnitEvent(EVENT_PLAYER_HERO_LEVEL)
        LevelUpTrigger.addCondition(
            Condition(() => getTriggerUnit().getHeroLevel() >= ProtectionOfAncients.UPGRADE_LEVEL_2_REQUIREMENT)
        )
        LevelUpTrigger.addAction(() => ProtectionOfAncients.SetProtectionOfAncientsLevel(getTriggerUnit()))
    }

    private static RegisterEvents() {
        let trg = Trigger.create()!
        trg.registerAnyUnitEvent(EVENT_PLAYER_UNIT_SPELL_CAST)
        trg.addCondition(
            Condition(
                () =>
                    GetSpellAbilityId() === Constants.ABILITY_PROTECTION_OF_THE_ANCIENTS ||
                    GetSpellAbilityId() === Constants.ABILITY_PROTECTION_OF_THE_ANCIENTS_WITH_RELIC
            )
        )
        trg.addAction(ProtectionOfAncients.ActivationEvent)

        ProtectionOfAncients.HotkeyTrigger = Trigger.create()!
        for (let p of Globals.ALL_PLAYERS) {
            ProtectionOfAncients.HotkeyTrigger.registerPlayerKeyEvent(p, OSKEY_RCONTROL, MetaKey.Control, true)
        }
        ProtectionOfAncients.HotkeyTrigger.addAction(ProtectionOfAncients.RegisterHotKeyEvents)
    }

    private static RegisterHotKeyEvents() {
        let p: MapPlayer = getTriggerPlayer()
        let k: Kitty = Globals.ALL_KITTIES.get(p)!

        if (!k.isAlive()) return // cannot cast if dead obviously.
        k.Unit.issueImmediateOrder('divineshield')
        k.Unit.issueOrderAt(WolfPoint.MoveOrderID, k.APMTracker.LastX, k.APMTracker.LastY)
    }

    private static ActivationEvent() {
        let Unit = getTriggerUnit()
        let player = getTriggerPlayer()
        let kitty = Globals.ALL_KITTIES.get(player)!
        let relic = Constants.ABILITY_PROTECTION_OF_THE_ANCIENTS_WITH_RELIC

        Globals.ALL_KITTIES.get(player)!.ProtectionActive = true

        // Short delay to let the ability actually hit cooldown first. Then call.. Give a .03 delay.
        Utility.SimpleTimer(0.03, () =>
            BlzStartUnitAbilityCooldown(Unit.handle, relic, this.GetOneOfNineCooldown(player))
        )

        let actiEffect = Effect.createAttachment(ProtectionOfAncients.ACTIVATION_EFFECT, Unit, 'chest')!

        Utility.SimpleTimer(this.EFFECT_DELAY, () => {
            ProtectionOfAncients.ApplyEffect(Unit)
            GC.RemoveEffect(actiEffect) // TODO; Cleanup:             GC.RemoveEffect(ref actiEffect);
        })
    }

    public static GetOneOfNineCooldown(Player: MapPlayer) {
        let kitty: Unit = Globals.ALL_KITTIES.get(Player)!.Unit
        let noRelic = Constants.ABILITY_PROTECTION_OF_THE_ANCIENTS
        let relic = Constants.ABILITY_PROTECTION_OF_THE_ANCIENTS_WITH_RELIC
        let reduction = this.GetOneOfNineReduction(Player)

        // remaining cooldown depending on relic or no relic
        let cooldown: number =
            kitty.getAbilityCooldownRemaining(noRelic) > 0.0
                ? kitty.getAbilityCooldownRemaining(noRelic)
                : kitty.getAbilityCooldownRemaining(relic)

        cooldown -= reduction

        return Math.max(0.0, cooldown) // gotta make sure its not negative
    }

    public static GetOneOfNineReduction(Player: MapPlayer) {
        return 3.0
        //return PlayerUpgrades.GetPlayerUpgrades(Player).GetUpgradeLevel(typeof OneOfNine) * 3.0
    }

    private static ApplyEffect(Unit: Unit) {
        let owningPlayer = Unit.owner
        let kitty = Globals.ALL_KITTIES.get(owningPlayer)!
        let actiEffect = Effect.create(ProtectionOfAncients.APPLY_EFFECT, Unit.x, Unit.y)!
        if (!kitty.Unit.isAlive()) kitty.Invulnerable = true // unit genuinely dead
        GC.RemoveEffect(actiEffect) // TODO; Cleanup:         GC.RemoveEffect(ref actiEffect);
        ProtectionOfAncients.EndEffectActions(owningPlayer)
    }

    private static AoEEffectFilter(): boolean {
        // Append units only if they're dead and a kitty circle.
        let unit = getFilterUnit()
        let player = unit.owner
        if (unit.typeId !== Constants.UNIT_KITTY_CIRCLE) return false

        let kitty = Globals.ALL_KITTIES.get(player)!.Unit
        return !kitty.isAlive()
    }

    private static EndEffectActions(Player: MapPlayer) {
        // Get all units within range of the player unit (kitty) and revive them
        let tempGroup = Group.create()! // consider changing this to a static group
        let kitty = Globals.ALL_KITTIES.get(Player)!
        let levelOfAbility = kitty.Unit.getAbilityLevel(Constants.ABILITY_PROTECTION_OF_THE_ANCIENTS)
        let levelOfRelic = kitty.Unit.getAbilityLevel(Constants.ABILITY_PROTECTION_OF_THE_ANCIENTS_WITH_RELIC)
        if (levelOfRelic > 0) levelOfAbility = levelOfRelic
        let effectRadius =
            ProtectionOfAncients.EFFECT_RADIUS + levelOfAbility * ProtectionOfAncients.EFFECT_RADIUS_INCREASE
        let reviveCount = 0
        let filter = Utility.CreateFilterFunc(ProtectionOfAncients.AoEEffectFilter)

        kitty.ProtectionActive = false
        tempGroup.enumUnitsInRange(kitty.Unit.x, kitty.Unit.y, effectRadius, filter)

        while (true) {
            let unit = tempGroup.first
            if (!unit) break
            tempGroup.removeUnit(unit)

            let playerToRevive = Globals.ALL_KITTIES.get(unit.owner)!
            // SELF.. Shouldn't get save points for reviving yourself.
            if (kitty.Unit === playerToRevive.Unit) {
                kitty.ReviveKitty()
            } // Other players get revived and then kitty (person casting ult, gets the save points)
            else {
                playerToRevive.Invulnerable = true // players that are dead nearby that get revived will have invul for 1 sec as well.
                Utility.SimpleTimer(
                    ProtectionOfAncients.INVULNERABLE_DURATION,
                    () => (playerToRevive.Invulnerable = false)
                )
                playerToRevive.ReviveKitty(kitty)
            }
            reviveCount++
            // Give Divinity Tendrils if meets challenge requiremnet.
            if (reviveCount >= Challenges.DIVINITY_TENDRILS_COUNT) Challenges.DivinityTendrils(Player)
        }

        Utility.SimpleTimer(ProtectionOfAncients.INVULNERABLE_DURATION, () => (kitty.Invulnerable = false))

        GC.RemoveGroup(tempGroup) // TODO; Cleanup:         GC.RemoveGroup(ref tempGroup);
        GC.RemoveFilterFunc(filter) // TODO; Cleanup:         GC.RemoveFilterFunc(ref filter);
    }
}
