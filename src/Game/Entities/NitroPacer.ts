import { Constants } from 'src/AutoGenerated/Constants'
import { Logger } from 'src/Events/Logger/Logger'
import { CurrentGameMode } from 'src/Gamemodes/CurrentGameMode'
import { GameMode } from 'src/Gamemodes/GameModeEnum'
import { Globals } from 'src/Global/Globals'
import { RegionList } from 'src/Global/RegionList'
import { NitroChallenges } from 'src/Rewards/Challenges/NitroChallenges'
import { Colors } from 'src/Utility/Colors/Colors'
import { AchesTimers, createAchesTimer } from 'src/Utility/MemoryHandler/AchesTimers'
import { Utility } from 'src/Utility/Utility'
import { Effect, Item, MapPlayer, Rectangle, Unit } from 'w3ts'
import { Progress } from '../Management/Progress'
import { ProgressPointHelper } from '../Management/ProgressPointHelper'
import { WolfPoint } from '../WolfPoint'

export class NitroPacer {
    private static instance: NitroPacer | undefined

    public Unit: Unit | undefined
    public currentDistance = 0
    public currentCheckpoint = 0
    public pacerTimer: AchesTimers | undefined
    public nitroEffect: Effect | undefined
    public pathingPoints: Rectangle[] = []
    public ghostBoots: Item | undefined

    private constructor() {}

    public static getInstance(): NitroPacer {
        if (!NitroPacer.instance) {
            NitroPacer.instance = new NitroPacer()
        }
        return NitroPacer.instance
    }

    /// <summary>
    /// Initializes the Nitros Pacer unit and effect, only applies to the standard gamemode.
    /// </summary>
    public static Initialize = () => {
        if (CurrentGameMode.active !== GameMode.Standard) return

        const instance = NitroPacer.getInstance()

        instance.Unit ??= Unit.create(
            MapPlayer.fromIndex(PLAYER_NEUTRAL_PASSIVE!)!,
            Constants.UNIT_NITRO_PACER,
            RegionList.SpawnRegions[5].centerX,
            RegionList.SpawnRegions[5].centerY,
            360
        )!
        Utility.MakeUnitLocust(instance.Unit)
        instance.pathingPoints = RegionList.PathingPoints
        instance.Unit.invulnerable = true
        instance.Unit.name = `${Colors.COLOR_TURQUOISE}Pacer: Nitro${Colors.COLOR_RESET}`
        instance.ghostBoots = instance.Unit.addItemById(Constants.ITEM_GHOST_KITTY_BOOTS)!
        instance.nitroEffect = Effect.createAttachment('war3mapImported\\Nitro.mdx', instance.Unit, 'origin')!
        instance.VisionShare()

        instance.pacerTimer = createAchesTimer()
    }

    /// <summary>
    /// Returns the current distance of the nitro pacer.
    /// </summary>
    /// <returns></returns>
    public static GetCurrentCheckpoint(): number {
        return NitroPacer.getInstance().currentCheckpoint
    }

    /// <summary>
    /// Starts the nitro pacer, resets the pacer and sets the speed of the unit to 0.
    /// </summary>
    public static StartNitroPacer = () => {
        if (CurrentGameMode.active !== GameMode.Standard) return

        const instance = NitroPacer.getInstance()
        NitroPacer.ResetNitroPacer()
        instance.Unit!.useItem(instance.ghostBoots!)
        NitroPacer.NitroPacerQueueOrders()
        instance.pacerTimer!.Timer.start(0.15, true, () => NitroPacer.UpdateNitroPacer())
    }

    /// <summary>
    /// Resets the nitro pacer, sets the unit to the spawn point, and sets the speed of the unit to 0.
    /// </summary>
    public static ResetNitroPacer = () => {
        if (CurrentGameMode.active !== GameMode.Standard) return

        const instance = NitroPacer.getInstance()
        instance.pacerTimer?.pause()
        instance.Unit!.paused = false
        instance.Unit!.setPosition(RegionList.SpawnRegions[5].centerX, RegionList.SpawnRegions[5].centerY)
        instance.currentCheckpoint = 0
        instance.currentDistance = 0
    }

    public static UpdateNitroPacer = () => {
        try {
            const instance = NitroPacer.getInstance()
            instance.currentDistance = NitroPacer.CalculateNitroPacerProgress()
            let remainingDistance = Progress.DistancesFromStart.get(RegionList.PathingPoints.length - 1)
            if (!remainingDistance) {
                Logger.Warning('remainingDistance is undefined in UpdateNitroPacer.')
                return
            }
            remainingDistance -= instance.currentDistance
            const remainingTime: number = NitroChallenges.GetNitroTimeRemaining()
            const speed: number = remainingTime !== 0.0 ? remainingDistance / remainingTime : 350.0
            NitroPacer.SetSpeed(speed)

            if (instance.pathingPoints[instance.currentCheckpoint + 1].includes(instance.Unit!.x, instance.Unit!.y)) {
                instance.currentCheckpoint++
                if (instance.currentCheckpoint >= instance.pathingPoints.length - 1) {
                    instance.pacerTimer?.pause()
                    Utility.SimpleTimer(2.0, () => (instance.Unit!.paused = true)) // this is actually ok since we reset pacer before starting it again
                    return
                }
            }
        } catch (e) {
            Logger.Warning(`Error in UpdateNitroPacer ${e}`)
            throw e
        }
    }

    public static NitroPacerQueueOrders = () => {
        // backwards for pathingpoints, for stack queue order
        const instance = NitroPacer.getInstance()
        if (!instance.Unit) return
        for (
            let i: number = instance.pathingPoints.length - 1;
            i >= 1;
            i-- // exclude starting point
        ) {
            const point: Rectangle = instance.pathingPoints[i]
            BlzQueuePointOrderById(instance.Unit.handle, WolfPoint.MoveOrderID, point.centerX, point.centerY)
        }
    }

    public VisionShare = () => {
        for (const player of Globals.ALL_PLAYERS) {
            const neutralPassive = MapPlayer.fromIndex(PLAYER_NEUTRAL_PASSIVE!)!
            neutralPassive.setAlliance(player, ALLIANCE_SHARED_VISION_FORCED, true)
        }
    }

    public static SetSpeed(speed: number) {
        return (NitroPacer.getInstance().Unit!.moveSpeed = speed)
    }

    public static CalculateNitroPacerProgress(): number {
        const nitroKitty = NitroPacer.getInstance()
        if (nitroKitty.Unit === undefined) return 0.0
        const currentSafezone = NitroPacer.GetCurrentCheckpoint()
        if (Globals.SAFE_ZONES[0].Rectangle.includes(nitroKitty.Unit.x, nitroKitty.Unit.y)) return 0.0 // if at start, 0 progress
        if (Globals.SAFE_ZONES[Globals.SAFE_ZONES.length - 1].Rectangle.includes(nitroKitty.Unit.x, nitroKitty.Unit.y))
            return 100.0 // if at end.. 100 progress
        const currentProgress = Progress.DistanceBetweenPoints(
            nitroKitty.Unit.x,
            nitroKitty.Unit.y,
            ProgressPointHelper.Points[currentSafezone].x,
            ProgressPointHelper.Points[currentSafezone].y
        )
        const totalProgress = Progress.DistancesFromStart.get(currentSafezone)! + currentProgress

        return totalProgress
    }
}
