import { Constants } from 'src/AutoGenerated/Constants'
import { Logger } from 'src/Events/Logger/Logger'
import { CurrentGameMode } from 'src/Gamemodes/CurrentGameMode'
import { GameMode } from 'src/Gamemodes/GameModeEnum'
import { Globals } from 'src/Global/Globals'
import { RegionList } from 'src/Global/RegionList'
import { NitroChallenges } from 'src/Rewards/Challenges/NitroChallenges'
import { Colors } from 'src/Utility/Colors/Colors'
import { AchesTimers, createAchesTimer } from 'src/Utility/MemoryHandler/AchesTimers'
import { Utility } from 'src/Utility/Utility'
import { Effect, Item, MapPlayer, Rectangle, Unit } from 'w3ts'
import { Progress } from '../Management/Progress'
import { WolfPoint } from '../WolfPoint'

export const NitroPacer = {
    Unit: undefined as unknown as Unit,

    currentDistance: 0,
    currentCheckpoint: 0,
    pacerTimer: undefined as AchesTimers | undefined,
    spawnRect: RegionList.SpawnRegions[5],
    pathingPoints: RegionList.PathingPoints,
    nitroEffect: undefined as Effect | undefined,
    ghostBoots: undefined as Item | undefined,

    /// <summary>
    /// Initializes the Nitros Pacer unit and effect, only applies to the standard gamemode.
    /// </summary>
    Initialize() {
        if (CurrentGameMode.active !== GameMode.Standard) return

        this.Unit ??= Unit.create(
            MapPlayer.fromIndex(PLAYER_NEUTRAL_PASSIVE!)!,
            Constants.UNIT_NITRO_PACER,
            this.spawnRect.centerX,
            this.spawnRect.centerY,
            360
        )!
        Utility.MakeUnitLocust(this.Unit)
        this.Unit.invulnerable = true
        this.Unit.name = `${Colors.COLOR_TURQUOISE}Pacer: Nitro${Colors.COLOR_RESET}`
        this.ghostBoots = this.Unit.addItemById(Constants.ITEM_GHOST_KITTY_BOOTS)!
        this.nitroEffect = Effect.createAttachment('war3mapImported\\Nitro.mdx', this.Unit, 'origin')!
        this.VisionShare()

        this.pacerTimer = createAchesTimer()
    },

    /// <summary>
    /// Returns the current distance of the nitro pacer.
    /// </summary>
    /// <returns></returns>
    GetCurrentCheckpoint(): number {
        return this.currentCheckpoint
    },

    /// <summary>
    /// Starts the nitro pacer, resets the pacer and sets the speed of the unit to 0.
    /// </summary>
    StartNitroPacer() {
        if (CurrentGameMode.active !== GameMode.Standard) return

        this.ResetNitroPacer()
        this.Unit!.useItem(this.ghostBoots!)
        this.NitroPacerQueueOrders()
        this.pacerTimer!.Timer.start(0.15, true, this.UpdateNitroPacer.bind(this))
    },

    /// <summary>
    /// Resets the nitro pacer, sets the unit to the spawn point, and sets the speed of the unit to 0.
    /// </summary>
    ResetNitroPacer() {
        if (CurrentGameMode.active !== GameMode.Standard) return

        this.pacerTimer?.pause()
        this.Unit!.paused = false
        this.Unit!.setPosition(this.spawnRect.centerX, this.spawnRect.centerY)
        this.currentCheckpoint = 0
        this.currentDistance = 0
    },

    UpdateNitroPacer() {
        try {
            this.currentDistance = Progress.CalculateNitroPacerProgress()
            let remainingDistance = Progress.DistancesFromStart.get(RegionList.PathingPoints.length - 1)
            if (!remainingDistance) {
                Logger.Warning('remainingDistance is undefined in UpdateNitroPacer.')
                return
            }
            remainingDistance -= this.currentDistance
            let remainingTime: number = NitroChallenges.GetNitroTimeRemaining()
            let speed: number = remainingTime !== 0.0 ? remainingDistance / remainingTime : 350.0
            this.SetSpeed(speed)

            if (this.pathingPoints[this.currentCheckpoint + 1].includes(this.Unit!.x, this.Unit!.y)) {
                this.currentCheckpoint++
                if (this.currentCheckpoint >= this.pathingPoints.length - 1) {
                    this.pacerTimer?.pause()
                    Utility.SimpleTimer(2.0, () => (this.Unit!.paused = true)) // this is actually ok since we reset pacer before starting it again
                    return
                }
            }
        } catch (e: any) {
            Logger.Warning(`Error in UpdateNitroPacer ${e}`)
            throw e
        }
    },

    NitroPacerQueueOrders() {
        // backwards for pathingpoints, for stack queue order
        for (
            let i: number = this.pathingPoints.length - 1;
            i >= 1;
            i-- // exclude starting point
        ) {
            let point: Rectangle = this.pathingPoints[i]
            this.Unit!.issueOrderAt(WolfPoint.MoveOrderID, point.centerX, point.centerY)
        }
    },

    VisionShare() {
        for (let player of Globals.ALL_PLAYERS) {
            let neutralPassive = MapPlayer.fromIndex(PLAYER_NEUTRAL_PASSIVE!)!
            neutralPassive.setAlliance(player, ALLIANCE_SHARED_VISION_FORCED, true)
        }
    },

    SetSpeed(speed: number) {
        return (this.Unit!.moveSpeed = speed)
    },
}
