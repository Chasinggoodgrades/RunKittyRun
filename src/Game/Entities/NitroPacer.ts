import { Rectangle } from "w3ts";
import { Regions } from "src/AutoGenerated/Regions";


class NitroPacer
{
    public static Unit: unit 

    private static currentDistance: number = 0;
    private static currentCheckpoint: number = 0;
    private static pacerTimer: AchesTimers;
    private static spawnRect: rect = RegionList.SpawnRegions[5].Rect;
    private static pathingPoints: Rectangle[] = RegionList.PathingPoints;
    private static _cachedNitroPacerUpdate: Action;
    private static nitroEffect: effect;
    private static ghostBoots: item;

    /// <summary>
    /// Initializes the Nitros Pacer unit and effect, only applies to the standard gamemode.
    /// </summary>
    public static Initialize()
    {
        if (Gamemode.CurrentGameMode != GameMode.Standard) return;

        Unit ??= unit.Create(player.NeutralPassive, Constants.UNIT_NITRO_PACER, spawnRect.CenterX, spawnRect.CenterY, 360);
        Utility.MakeUnitLocust(Unit);
        Unit.IsInvulnerable = true;
        Unit.Name = "{Colors.COLOR_TURQUOISE}Pacer: Nitro{Colors.COLOR_RESET}";
        ghostBoots = Unit.AddItem(Constants.ITEM_GHOST_KITTY_BOOTS);
        nitroEffect = effect.Create("war3mapImported\\Nitro.mdx", Unit, "origin");
        _cachedNitroPacerUpdate = UpdateNitroPacer;
        VisionShare();

        pacerTimer = ObjectPool.GetEmptyObject<AchesTimers>();
    }

    /// <summary>
    /// Returns the current distance of the nitro pacer.
    /// </summary>
    /// <returns></returns>
    public static GetCurrentCheckpoint(): number  { return this.currentCheckpoint; }

    /// <summary>
    /// Starts the nitro pacer, resets the pacer and sets the speed of the unit to 0.
    /// </summary>
    public static StartNitroPacer()
    {
        if (Gamemode.CurrentGameMode != GameMode.Standard) return;

        ResetNitroPacer();
        Unit.UseItem(ghostBoots);
        NitroPacerQueueOrders();
        pacerTimer.Timer.Start(0.15, true, _cachedNitroPacerUpdate);
    }

    /// <summary>
    /// Resets the nitro pacer, sets the unit to the spawn point, and sets the speed of the unit to 0.
    /// </summary>
    public static ResetNitroPacer()
    {
        if (Gamemode.CurrentGameMode != GameMode.Standard) return;

        pacerTimer?.Pause();
        Unit.IsPaused = false;
        Unit.SetPosition(spawnRect.CenterX, spawnRect.CenterY);
        currentCheckpoint = 0;
        currentDistance = 0;
    }

    private static UpdateNitroPacer()
    {
        try
        {
            currentDistance = Progress.CalculateNitroPacerProgress();
            let remainingDistance: number = Progress.DistancesFromStart[RegionList.PathingPoints.Length - 1] - currentDistance;
            let remainingTime: number = NitroChallenges.GetNitroTimeRemaining();
            let speed: number = remainingTime != 0.0 ? remainingDistance / remainingTime : 350.0;
            SetSpeed(speed);

            if (pathingPoints[currentCheckpoint + 1].Contains(Unit.X, GetUnitY(unit)))
            {
                currentCheckpoint++;
                if (currentCheckpoint >= pathingPoints.Length - 1)
                {
                    pacerTimer?.Pause();
                    Utility.SimpleTimer(2.0, () => Unit.IsPaused = true); // this is actually ok since we reset pacer before starting it again
                    return;
                }
            }
        }
        catch (e: Error)
        {
            Logger.Warning("Error in UpdateNitroPacer. {e.Message}");
            throw e
        }
    }

    private static NitroPacerQueueOrders()
    {
        // backwards for pathingpoints, for stack queue order
        for (let i: number = pathingPoints.Length - 1; i >= 1; i--) // exclude starting point
        {
            let point: Rectangle = pathingPoints[i];
            Unit.QueueOrder(WolfPoint.MoveOrderID, point.Center.X, point.Center.Y);
        }
    }

    private static VisionShare()
    {
        for (let player: player in Globals.ALL_PLAYERS)
        {
            player.NeutralPassive.SetAlliance(player, alliancetype.SharedVisionForced, true);
        }
    }

    private static SetSpeed(speed: number)  { return Unit.MovementSpeed = speed; }
}
