import { Constants } from 'src/AutoGenerated/Constants'
import { Logger } from 'src/Events/Logger/Logger'
import { Gamemode } from 'src/Gamemodes/Gamemode'
import { GameMode } from 'src/Gamemodes/GameModeEnum'
import { Globals } from 'src/Global/Globals'
import { RegionList } from 'src/Global/RegionList'
import { NitroChallenges } from 'src/Rewards/Challenges/NitroChallenges'
import { Action } from 'src/Utility/CSUtils'
import { AchesTimers } from 'src/Utility/MemoryHandler/AchesTimers'
import { MemoryHandler } from 'src/Utility/MemoryHandler/MemoryHandler'
import { Utility } from 'src/Utility/Utility'
import { Effect, Item, MapPlayer, Rectangle, Unit } from 'w3ts'
import { Progress } from '../Management/Progress'
import { WolfPoint } from '../WolfPoint'

export class NitroPacer {
    public static Unit: Unit

    private static currentDistance: number = 0
    private static currentCheckpoint: number = 0
    private static pacerTimer: AchesTimers
    private static spawnRect: Rectangle = RegionList.SpawnRegions[5]
    private static pathingPoints: Rectangle[] = RegionList.PathingPoints
    private static nitroEffect: Effect
    private static ghostBoots: Item

    /// <summary>
    /// Initializes the Nitros Pacer unit and effect, only applies to the standard gamemode.
    /// </summary>
    public static Initialize() {
        if (Gamemode.CurrentGameMode != GameMode.Standard) return

        this.Unit ??= Unit.create(
            MapPlayer.fromIndex(PLAYER_NEUTRAL_PASSIVE!)!,
            Constants.UNIT_NITRO_PACER,
            this.spawnRect.centerX,
            this.spawnRect.centerY,
            360
        )!
        Utility.MakeUnitLocust(this.Unit)
        this.Unit.invulnerable = true
        this.Unit.name = '{Colors.COLOR_TURQUOISE}Pacer: Nitro{Colors.COLOR_RESET}'
        this.ghostBoots = this.Unit.addItemById(Constants.ITEM_GHOST_KITTY_BOOTS)!
        this.nitroEffect = Effect.createAttachment('war3mapImported\\Nitro.mdx', this.Unit, 'origin')!
        this.VisionShare()

        this.pacerTimer = MemoryHandler.getEmptyObject<AchesTimers>()
    }

    /// <summary>
    /// Returns the current distance of the nitro pacer.
    /// </summary>
    /// <returns></returns>
    public static GetCurrentCheckpoint(): number {
        return this.currentCheckpoint
    }

    /// <summary>
    /// Starts the nitro pacer, resets the pacer and sets the speed of the unit to 0.
    /// </summary>
    public static StartNitroPacer() {
        if (Gamemode.CurrentGameMode != GameMode.Standard) return

        this.ResetNitroPacer()
        this.Unit.useItem(this.ghostBoots)
        this.NitroPacerQueueOrders()
        this.pacerTimer.Timer.start(0.15, true, this.UpdateNitroPacer)
    }

    /// <summary>
    /// Resets the nitro pacer, sets the unit to the spawn point, and sets the speed of the unit to 0.
    /// </summary>
    public static ResetNitroPacer() {
        if (Gamemode.CurrentGameMode != GameMode.Standard) return

        this.pacerTimer?.pause()
        this.Unit.paused = false
        this.Unit.setPosition(this.spawnRect.centerX, this.spawnRect.centerY)
        this.currentCheckpoint = 0
        this.currentDistance = 0
    }

    private static UpdateNitroPacer() {
        try {
            this.currentDistance = Progress.CalculateNitroPacerProgress()
            let remainingDistance = Progress.DistancesFromStart.get(RegionList.PathingPoints.length - 1)
            if (remainingDistance == null) {
                Logger.Warning('remainingDistance is undefined in UpdateNitroPacer.')
                return
            }
            remainingDistance -= this.currentDistance
            let remainingTime: number = NitroChallenges.GetNitroTimeRemaining()
            let speed: number = remainingTime != 0.0 ? remainingDistance / remainingTime : 350.0
            this.SetSpeed(speed)

            if (this.pathingPoints[this.currentCheckpoint + 1].includes(this.Unit.x, this.Unit.y)) {
                this.currentCheckpoint++
                if (this.currentCheckpoint >= this.pathingPoints.length - 1) {
                    this.pacerTimer?.pause()
                    Utility.SimpleTimer(2.0, () => (this.Unit.paused = true)) // this is actually ok since we reset pacer before starting it again
                    return
                }
            }
        } catch (e: any) {
            Logger.Warning('Error in UpdateNitroPacer. {e.Message}')
            throw e
        }
    }

    private static NitroPacerQueueOrders() {
        // backwards for pathingpoints, for stack queue order
        for (
            let i: number = this.pathingPoints.length - 1;
            i >= 1;
            i-- // exclude starting point
        ) {
            let point: Rectangle = this.pathingPoints[i]
            this.Unit.issueOrderAt(WolfPoint.MoveOrderID, point.centerX, point.centerY)
        }
    }

    private static VisionShare() {
        for (let player of Globals.ALL_PLAYERS) {
            let neutralPassive = MapPlayer.fromIndex(PLAYER_NEUTRAL_PASSIVE!)!
            neutralPassive.setAlliance(player, ALLIANCE_SHARED_VISION_FORCED, true)
        }
    }

    private static SetSpeed(speed: number) {
        return (this.Unit.moveSpeed = speed)
    }
}
