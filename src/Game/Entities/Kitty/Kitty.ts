import { Constants } from 'src/AutoGenerated/Constants'
import { Gameover } from 'src/Events/Gameover'
import { Logger } from 'src/Events/Logger/Logger'
import { APMTracker } from 'src/Events/UnitOrders/APMTracker'
import { MirrorMovementHandler } from 'src/Events/UnitOrders/MirrorMovementHandler'
import { CollisionDetection } from 'src/Game/CollisionDetection'
import { RelicUtil } from 'src/Game/Items/Relics/RelicUtil'
import { KittyTime } from 'src/Game/Management/KittyTime'
import { ProgressPointHelper } from 'src/Game/Management/ProgressPointHelper'
import { PlayerGameData } from 'src/Game/PlayerGameData'
import { Gamemode } from 'src/Gamemodes/Gamemode'
import { GameMode } from 'src/Gamemodes/GameModeEnum'
import { Solo } from 'src/Gamemodes/Solo/Solo'
import { KittyMorphosis } from 'src/Gamemodes/Standard/Kittymorphosis'
import { Globals } from 'src/Global/Globals'
import { RegionList } from 'src/Global/RegionList'
import { Resources } from 'src/Init/Resources'
import { AIController } from 'src/Misc/AIController'
import { Disco } from 'src/Misc/Disco'
import { RTR } from 'src/Misc/RTR'
import { Slider } from 'src/Misc/Slider'
import { SpinCam } from 'src/Misc/SpinCam'
import { ChainedTogether } from 'src/Rewards/Challenges/ChainedTogether'
import { YellowLightning } from 'src/Rewards/Challenges/Challenges'
import { TeamDeathless } from 'src/Rewards/Challenges/TeamDeathless'
import { CrystalOfFire } from 'src/Rewards/EasterEggs/Fieryfox/CrystalOfFire'
import { ActiveAwards } from 'src/Rewards/Rewards/ActiveAwards'
import { AwardManager } from 'src/Rewards/Rewards/AwardManager'
import { KittyData } from 'src/SaveSystem2.0/MAKE REWARDS HERE/KittyData'
import { SaveManager } from 'src/SaveSystem2.0/SaveManager'
import { SoundManager } from 'src/Sounds/SoundManager'
import { FloatingNameTag } from 'src/UI/FloatingNames'
import { MultiboardUtil } from 'src/UI/Multiboard/MultiboardUtil'
import { CameraUtil } from 'src/Utility/CameraUtil'
import { Utility } from 'src/Utility/Utility'
import { MapPlayer, Timer, Trigger, Unit } from 'w3ts'
import { Circle } from '../Circle'
import { ShadowKitty } from '../ShadowKitty'
import { KittyMiscInfo } from './KittyMiscInfo'
import { KittyStatsManager } from './KittyStatsManager'

export class Kitty {
    private KITTY_HERO_TYPE: number = Constants.UNIT_KITTY
    private SPAWN_IN_EFFECT: string = 'Abilities\\Spells\\Undead\\DeathPact\\DeathPactTarget.mdl'
    private MANA_DEATH_PENALTY: number = 65.0
    private InvulDuration: number = 0.3
    public static InvulTest: boolean = false

    public name: string
    public SaveData: KittyData
    public Relics: Relic[]
    public TimeProg: KittyTime
    public ShadowKitty: ShadowKitty
    public CurrentStats: PlayerGameData = new PlayerGameData()
    public ProgressHelper: ProgressPointHelper = new ProgressPointHelper()
    public ActiveAwards: ActiveAwards = new ActiveAwards()
    public KittyMiscInfo: KittyMiscInfo = new KittyMiscInfo()
    public StatsManager: KittyStatsManager
    public NameTag: FloatingNameTag
    public YellowLightning: YellowLightning
    public aiController: AIController
    public SpinCam: SpinCam
    public APMTracker: APMTracker
    public KittyMorphosis: KittyMorphosis
    public Slider: Slider
    public RTR: RTR
    public MirrorHandler: MirrorMovementHandler
    public CurrentSafeZone: number = 0
    public Player: MapPlayer
    public Unit: Unit
    public ProtectionActive: boolean = false
    public Invulnerable: boolean = false
    public Alive: boolean = true
    public Finished: boolean = false
    public TeamID: number = 0
    public ProgressZone: number = 0
    public w_Collision: Trigger = Trigger.create()!
    public c_Collision: Trigger = Trigger.create()!
    public Disco: Disco
    public InvulTimer = Timer.create()
    public IsChained: boolean = false
    public IsMirror: boolean = false
    public CanEarnAwards: boolean = true

    public constructor(player: MapPlayer) {
        this.Player = player
        this.name = player.name.split('#')[0]
        this.InitData()
        this.SpawnEffect()
        this.CreateKitty()
        this.TimeProg = new KittyTime(this)
        this.Slider = new Slider(this)
        this.RTR = new RTR(this)
        this.MirrorHandler = new MirrorMovementHandler(this)
        this.StatsManager = new KittyStatsManager(this)
        this.YellowLightning = new YellowLightning(this)
        this.aiController = new AIController(this)
        this.SpinCam = new SpinCam(this)
        this.APMTracker = new APMTracker(this)
        this.NameTag = new FloatingNameTag(this)
        this.KittyMorphosis = new KittyMorphosis(this)
        this.ShadowKitty = new ShadowKitty(this)
        Globals.ALL_KITTIES_LIST.push(this)
        this.Disco = new Disco(this.Unit)
        this.StartAIController()
    }

    /// <summary>
    /// Initializes all kitty and circle objects for all players.
    /// </summary>
    public static Initialize() {
        try {
            for (let player of Globals.ALL_PLAYERS) {
                new Circle(player)
                new Kitty(player)
            }
        } catch (e: any) {
            Logger.Critical('Error in Kitty.Initalize. {e.StackTrace}')
            throw e
        }
    }

    /// <summary>
    /// Kills this kitty object, and increments death stats. Calls attached circle object.
    /// </summary>
    public KillKitty() {
        try {
            if (Invulnerable || !Alive) return

            let circle: Circle = Globals.ALL_CIRCLES[Player]

            // Pause processes before unit death
            Slider.PauseSlider()
            RTR.PauseRTR()
            aiController.PauseAi()
            Unit.Kill()

            // Update status flags
            if (!ProtectionActive) Alive = false

            // Apply death effects and stat updates
            CrystalOfFire.CrystalOfFireDeath(this)
            circle.SetMana(Unit.mana - MANA_DEATH_PENALTY, Unit.maxMana, Unit.Intelligence * 0.08 + 0.01)
            circle.KittyDied(this)
            Solo.ReviveKittySoloTournament(this)
            Solo.RoundEndCheck()

            // Death Sounds
            SoundManager.PlayKittyDeathSound(this)
            SoundManager.PlayFirstBloodSound()

            // Update stats
            StatsManager.DeathStatUpdate()

            // Handle game mode specific logic
            if (Gamemode.CurrentGameMode == GameMode.Standard) {
                TeamDeathless.DiedWithOrb(this)
                ChainedTogether.LoseEvent(this.name)
                SoundManager.PlayLastManStandingSound()
                Gameover.GameOver()
                MultiboardUtil.RefreshMultiboards()
            }
        } catch (e: any) {
            Logger.Critical('Error in KillKitty: {e.Message}')
        }
    }

    /// <summary>
    /// Revives this object and increments savior's stats if provided.
    /// </summary>
    public ReviveKitty(savior: Kitty = null) {
        try {
            if (Unit.isAlive()) return

            let circle: Circle = Globals.ALL_CIRCLES[Player]

            // Hide visual indicators before revival
            circle.HideCircle()
            InvulnerableKitty()
            Alive = true

            // Revive the unit at its respective position
            Unit.Revive(circle.Unit.x, circle.unit.y, false)
            Unit.mana = circle.Unit.mana

            // Adjust player controls and UI
            Utility.SelectUnitForPlayer(Player, Unit)
            CameraUtil.RelockCamera(Player)

            // Resume processes
            Slider.ResumeSlider(true)
            RTR.ResumeRTR()
            aiController.ResumeAi()

            // Update savior stats if applicable
            if (savior != null) {
                StatsManager.UpdateSaviorStats(savior)
                MultiboardUtil.RefreshMultiboards()
            }
        } catch (e: any) {
            Logger.Critical('Error in ReviveKitty: {e.Message}')
            throw e
        }
    }

    private InvulnerableKitty() {
        if (!InvulTest) return
        Invulnerable = true
        InvulTimer.start(InvulDuration, false, () => {
            Invulnerable = false
            InvulTimer.pause()
        })
    }

    public ToggleMirror() {
        IsMirror = !IsMirror
    }

    private InitData() {
        try {
            // Save Data
            if (Player.controller == MAP_CONTROL_USER && Player.slotState == PLAYER_SLOT_STATE_PLAYING)
                SaveData = SaveManager.GetKittyData(Player)
            else SaveData = new KittyData() // dummy data for comps

            Relics = []
        } catch (e: any) {
            Logger.Critical('Error in InitData {e.Message}')
            throw e
        }
    }

    private SpawnEffect() {
        WCSharp.Shared.Data.spawnCenter = RegionList.SpawnRegions[Player.id].Center
        Utility.CreateEffectAndDispose(SPAWN_IN_EFFECT, spawnCenter.x, spawnCenter.y)
    }

    private CreateKitty() {
        // Spawn Location
        WCSharp.Shared.Data.spawnCenter = RegionList.SpawnRegions[Player.id].Center

        // Creation of Unit
        Unit = Unit.Create(this.Player, this.KITTY_HERO_TYPE, spawnCenter.x, spawnCenter.y, 360)
        Utility.MakeUnitLocust(Unit)
        Utility.SelectUnitForPlayer(Player, Unit)

        // Initialize Kitty
        Globals.ALL_KITTIES.push(Player, this)
        Resources.StartingItems(this)
        RelicUtil.DisableRelicBook(Unit)
        Unit.name = '{Colors.PlayerNameColored(Player)}'
        TrueSightGhostWolves()
        CollisionDetection.KittyRegisterCollisions(this)

        // Set Selected Rewards On Spawn but with a small delay for save data to get set.
        Utility.SimpleTimer(1.0, () => AwardManager.SetPlayerSelectedData(this))
    }

    private StartAIController() {
        if (Player.controller == MAP_CONTROL_COMPUTER && Gamemode.CurrentGameMode == GameMode.Standard) {
            this.aiController?.StartAi()
            Unit.AddItem(FourCC('bspd')) // boots
        }
    }

    public dispose() {
        Alive = false
        w_Collision.dispose()
        c_Collision.dispose()
        YellowLightning.dispose()
        TimeProg.dispose()
        APMTracker.dispose()
        MirrorHandler.dispose()
        InvulTimer.pause()
        InvulTimer.dispose()
        Disco?.dispose()
        aiController.StopAi()
        RTR.StopRTR()
        Unit.dispose()
        ChainedTogether.RegenerateGroup(this.name)
        if (Gameover.WinGame) return
        Globals.ALL_KITTIES_LIST.Remove(this)
        Globals.ALL_KITTIES.Remove(Player)
    }

    private TrueSightGhostWolves() {
        let trueSight: number = FourCC('Atru')
        Unit.AddAbility(trueSight)
        Unit.HideAbility(trueSight, true)
    }

    public isAlive = () => this.Alive
}
