import { Constants } from 'src/AutoGenerated/Constants'
import { Gameover } from 'src/Events/Gameover'
import { Logger } from 'src/Events/Logger/Logger'
import { APMTracker } from 'src/Events/UnitOrders/APMTracker'
import { MirrorMovementHandler } from 'src/Events/UnitOrders/MirrorMovementHandler'
import { CollisionDetection } from 'src/Game/CollisionDetection'
import { Relic } from 'src/Game/Items/Relics/Relic'
import { RelicUtil } from 'src/Game/Items/Relics/RelicUtil'
import { KittyTime } from 'src/Game/Management/KittyTime'
import { ProgressPointHelper } from 'src/Game/Management/ProgressPointHelper'
import { PlayerGameData } from 'src/Game/PlayerGameData'
import { RoundManager } from 'src/Game/Rounds/RoundManager'
import { CurrentGameMode } from 'src/Gamemodes/CurrentGameMode'
import { GameMode } from 'src/Gamemodes/GameModeEnum'
import { Solo } from 'src/Gamemodes/Solo/Solo'
import { KittyMorphosis } from 'src/Gamemodes/Standard/Kittymorphosis'
import { Globals } from 'src/Global/Globals'
import { RegionList } from 'src/Global/RegionList'
import { Resources } from 'src/Init/Resources'
import { AIController } from 'src/Misc/AIController'
import { Disco } from 'src/Misc/Disco'
import { RTR } from 'src/Misc/RTR'
import { Slider } from 'src/Misc/Slider'
import { SpinCam } from 'src/Misc/SpinCam'
import { ChainedTogether } from 'src/Rewards/Challenges/ChainedTogether'
import { YellowLightning } from 'src/Rewards/Challenges/Challenges'
import { TeamDeathless } from 'src/Rewards/Challenges/TeamDeathless'
import { CrystalOfFire } from 'src/Rewards/EasterEggs/Fieryfox/CrystalOfFire'
import { ActiveAwards } from 'src/Rewards/Rewards/ActiveAwards'
import { AwardManager } from 'src/Rewards/Rewards/AwardManager'
import { KittyData } from 'src/SaveSystem2.0/MAKE REWARDS HERE/KittyData'
import { SaveManager } from 'src/SaveSystem2.0/SaveManager'
import { SoundManager } from 'src/Sounds/SoundManager'
import { FloatingNameTag } from 'src/UI/FloatingNames'
import { MultiboardUtil } from 'src/UI/Multiboard/MultiboardUtil'
import { CameraUtil } from 'src/Utility/CameraUtil'
import { ColorUtils } from 'src/Utility/Colors/ColorUtils'
import { Utility } from 'src/Utility/Utility'
import { MapPlayer, Point, Timer, Trigger, Unit } from 'w3ts'
import { Circle } from '../Circle'
import { ShadowKitty } from '../ShadowKitty'
import { KittyMiscInfo } from './KittyMiscInfo'
import { KittyStatsManager } from './KittyStatsManager'

export class Kitty {
    private KITTY_HERO_TYPE = Constants.UNIT_KITTY
    private SPAWN_IN_EFFECT = 'Abilities\\Spells\\Undead\\DeathPact\\DeathPactTarget.mdl'
    private MANA_DEATH_PENALTY = 65.0
    private InvulDuration = 0.3
    public static InvulTest = false

    public name: string
    public SaveData!: KittyData
    public Relics!: Relic[]
    public TimeProg: KittyTime
    public ShadowKitty: ShadowKitty
    public CurrentStats: PlayerGameData = new PlayerGameData()
    public ProgressHelper: ProgressPointHelper = new ProgressPointHelper()
    public ActiveAwards: ActiveAwards = new ActiveAwards()
    public KittyMiscInfo: KittyMiscInfo = new KittyMiscInfo()
    public StatsManager: KittyStatsManager
    public NameTag: FloatingNameTag
    public YellowLightning: YellowLightning
    public aiController: AIController
    public SpinCam: SpinCam
    public APMTracker: APMTracker
    public KittyMorphosis: KittyMorphosis
    public Slider: Slider
    public RTR: RTR
    public MirrorHandler: MirrorMovementHandler
    public CurrentSafeZone = 0
    public Player: MapPlayer
    public Unit!: Unit
    public ProtectionActive = false
    public Invulnerable = false
    public Alive = true
    public Finished = false
    public TeamID = 0
    public ProgressZone = 0
    public w_Collision!: Trigger | null
    public c_Collision!: Trigger | null
    public Disco: Disco
    public InvulTimer = Timer.create()
    public IsChained = false
    public IsMirror = false
    public CanEarnAwards = true

    public constructor(player: MapPlayer) {
        this.Player = player
        this.name = player.name.split('#')[0]
        this.InitData()
        this.SpawnEffect()
        this.CreateKitty()
        this.TimeProg = new KittyTime(this)
        this.Slider = new Slider(this)
        this.RTR = new RTR(this)
        this.MirrorHandler = new MirrorMovementHandler(this)
        this.StatsManager = new KittyStatsManager(this)
        this.YellowLightning = new YellowLightning(this)
        this.aiController = new AIController(this)
        this.SpinCam = new SpinCam(this)
        this.APMTracker = new APMTracker(this)
        this.NameTag = new FloatingNameTag(this)
        this.KittyMorphosis = new KittyMorphosis(this)
        this.ShadowKitty = new ShadowKitty(this)
        Globals.ALL_KITTIES_LIST.push(this)
        this.Disco = new Disco(this.Unit)
        this.StartAIController()
    }

    /// <summary>
    /// Initializes all kitty and circle objects for all players.
    /// </summary>
    public static Initialize = () => {
        try {
            for (const player of Globals.ALL_PLAYERS) {
                new Circle(player)
                new Kitty(player)
            }
        } catch (e) {
            Logger.Critical(`Error in Kitty.Initalize. ${e}`)
            throw e
        }
    }

    /// <summary>
    /// Kills this kitty object, and increments death stats. Calls attached circle object.
    /// </summary>
    public KillKitty = () => {
        try {
            if (this.Invulnerable || !this.Alive) return

            const circle = Globals.ALL_CIRCLES.get(this.Player)
            if (!circle) return

            // Pause processes before unit death
            this.Slider.PauseSlider()
            this.RTR.PauseRTR()
            this.aiController.PauseAi()
            KillUnit(this.Unit.handle)

            // Update status flags
            if (!this.ProtectionActive) this.Alive = false

            // Apply death effects and stat updates
            CrystalOfFire.CrystalOfFireDeath(this)
            circle.SetMana(
                this.Unit.mana - this.MANA_DEATH_PENALTY,
                this.Unit.maxMana,
                this.Unit.intelligence * 0.08 + 0.01
            )
            circle.KittyDied(this)
            Solo.ReviveKittySoloTournament(this)
            RoundManager.RoundEndCheckSolo()

            // Death Sounds
            SoundManager.PlayKittyDeathSound(this)
            SoundManager.PlayFirstBloodSound()

            // Update stats
            this.StatsManager.DeathStatUpdate()

            // Handle game mode specific logic
            if (CurrentGameMode.active === GameMode.Standard) {
                TeamDeathless.DiedWithOrb(this)
                ChainedTogether.LoseEvent(this.name)
                SoundManager.PlayLastManStandingSound()
                Gameover.GameOver()
                MultiboardUtil.RefreshMultiboards()
            }
        } catch (e) {
            Logger.Critical(`Error in KillKitty: ${e}`)
        }
    }

    /// <summary>
    /// Revives this object and increments savior's stats if provided.
    /// </summary>
    public ReviveKitty = (savior?: Kitty) => {
        try {
            if (UnitAlive(this.Unit.handle)) return

            const circle = Globals.ALL_CIRCLES.get(this.Player)

            if (!circle) return

            // Hide visual indicators before revival
            circle.HideCircle()
            this.InvulnerableKitty()
            this.Alive = true

            // Revive the unit at its respective position
            this.Unit.revive(circle.Unit.x, circle.Unit.y, false)
            this.Unit.mana = circle.Unit.mana

            // Adjust player controls and UI
            Utility.SelectUnitForPlayer(this.Player, this.Unit)
            CameraUtil.RelockCamera(this.Player)

            // Resume processes
            this.Slider.ResumeSlider(true)
            this.RTR.ResumeRTR()
            this.aiController.ResumeAi()

            // Update savior stats if applicable
            if (savior) {
                this.StatsManager.UpdateSaviorStats(savior)
                MultiboardUtil.RefreshMultiboards()
            }
        } catch (e) {
            Logger.Critical(`Error in ReviveKitty: ${e}`)
            throw e
        }
    }

    private InvulnerableKitty = () => {
        if (!Kitty.InvulTest) return
        this.Invulnerable = true
        this.InvulTimer.start(this.InvulDuration, false, () => {
            this.Invulnerable = false
            this.InvulTimer.pause()
        })
    }

    public ToggleMirror = () => {
        this.IsMirror = !this.IsMirror
    }

    private InitData = () => {
        try {
            // Save Data
            if (this.Player.controller === MAP_CONTROL_USER && this.Player.slotState === PLAYER_SLOT_STATE_PLAYING) {
                const data = SaveManager.GetKittyData(this.Player)
                this.SaveData = data ? data : new KittyData()
            } else {
                this.SaveData = new KittyData() // dummy data for comps
            }

            this.Relics = []
        } catch (e) {
            Logger.Critical(`Error in InitData: ${e}`)
            throw e
        }
    }

    private SpawnEffect = () => {
        const spawncenter = Point.create(
            RegionList.SpawnRegions[this.Player.id].centerX,
            RegionList.SpawnRegions[this.Player.id].centerY
        )
        Utility.CreateEffectAndDispose(this.SPAWN_IN_EFFECT, spawncenter.x, spawncenter.y)
    }

    private CreateKitty = () => {
        // Spawn Location
        const spawncenter = Point.create(
            RegionList.SpawnRegions[this.Player.id].centerX,
            RegionList.SpawnRegions[this.Player.id].centerY
        )

        // Creation of Unit
        this.Unit = Unit.create(this.Player, this.KITTY_HERO_TYPE, spawncenter.x, spawncenter.y, 360)!
        Utility.MakeUnitLocust(this.Unit)
        Utility.SelectUnitForPlayer(this.Player, this.Unit)

        // Initialize Kitty
        Globals.ALL_KITTIES.set(this.Player, this)
        Resources.StartingItems(this)
        RelicUtil.DisableRelicBook(this.Unit)
        this.Unit.name = `${ColorUtils.PlayerNameColored(this.Player)}`
        this.TrueSightGhostWolves()
        CollisionDetection.KittyRegisterCollisions(this)

        // Set Selected Rewards On Spawn but with a small delay for save data to get set.
        Utility.SimpleTimer(1.0, () => AwardManager.SetPlayerSelectedData(this))
    }

    private StartAIController = () => {
        if (this.Player.controller === MAP_CONTROL_COMPUTER && CurrentGameMode.active === GameMode.Standard) {
            this.aiController?.StartAi()
            this.Unit.addItemById(FourCC('bspd')) // boots
        }
    }

    public dispose = () => {
        this.Alive = false
        this.w_Collision?.destroy()
        this.c_Collision?.destroy()
        this.YellowLightning.dispose()
        this.TimeProg.dispose()
        this.APMTracker.dispose()
        this.MirrorHandler.dispose()
        this.InvulTimer.pause()
        this.InvulTimer.destroy()
        this.Disco?.dispose()
        this.aiController.StopAi()
        this.RTR.StopRTR()
        this.Unit.destroy()
        ChainedTogether.RegenerateGroup(this.name)
        if (Globals.WinGame) return
        Globals.ALL_KITTIES_LIST.splice(Globals.ALL_KITTIES_LIST.indexOf(this), 1)
        Globals.ALL_KITTIES.delete(this.Player)
    }

    private TrueSightGhostWolves = () => {
        const trueSight = FourCC('Atru')
        this.Unit.addAbility(trueSight)
        this.Unit.hideAbility(trueSight, true)
    }

    public isAlive = () => this.Alive
}
