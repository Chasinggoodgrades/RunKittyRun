import { Affix } from 'src/Affixes/Affix'
import { AffixFactory } from 'src/Affixes/AffixFactory'
import { Constants } from 'src/AutoGenerated/Constants'
import { Logger } from 'src/Events/Logger/Logger'
import { Gamemode } from 'src/Gamemodes/Gamemode'
import { GameMode } from 'src/Gamemodes/GameModeEnum'
import { Globals } from 'src/Global/Globals'
import { Difficulty } from 'src/Init/Difficulty/Difficulty'
import { Setup } from 'src/Init/Setup'
import { Disco } from 'src/Misc/Disco'
import { Program } from 'src/Program'
import { FandF } from 'src/Rewards/EasterEggs/F&F/FandF'
import { Action } from 'src/Utility/CSUtils'
import { AchesTimers } from 'src/Utility/MemoryHandler/AchesTimers'
import { MemoryHandler } from 'src/Utility/MemoryHandler/MemoryHandler'
import { Utility } from 'src/Utility/Utility'
import { Effect, MapPlayer, TextTag, Unit } from 'w3ts'
import { WolfArea } from '../WolfArea'
import { WolfPoint } from '../WolfPoint'
import { NamedWolves } from './NamedWolves'

export class Wolf {
    public static DEFAULT_OVERHEAD_EFFECT: string = 'TalkToMe.mdx'
    public static WOLF_MODEL: number = Constants.UNIT_CUSTOM_DOG
    public static DisableEffects: boolean = false
    private WANDER_LOWER_BOUND: number = 0.7 // reaction time lower bound
    private WANDER_UPPER_BOUND: number = 0.83 // reaction time upper bound
    private NEXT_WANDER_DELAY: number = 1.9 // time before wolf can move again

    private readonly _cachedWander: Action
    private readonly _cachedEffect: Action

    public RegionIndex: number
    public OVERHEAD_EFFECT_PATH: string
    public WanderTimer: AchesTimers = MemoryHandler.getEmptyObject<AchesTimers>()

    public EffectTimer: AchesTimers

    public Texttag: TextTag
    public Disco: Disco
    public WolfArea: WolfArea
    public Unit: Unit
    public Affixes: Affix[]
    private OverheadEffect: Effect
    // private effect RandomEffect // some random cool event - can do later on (roar, stomps, whatever)
    public WolfPoint: WolfPoint
    public paused: boolean = false
    public IsReviving: boolean = false
    public IsWalking: boolean = false

    public constructor(regionIndex: number) {
        this.RegionIndex = regionIndex
        this.WolfArea = WolfArea.WolfAreas.get(regionIndex)!
        let Affixes: Affix[] = [] // Consider creating a new object that contains Affix[] so we're not making a new one each wolf.
        this.OVERHEAD_EFFECT_PATH = Wolf.DEFAULT_OVERHEAD_EFFECT
        this.WolfPoint = new WolfPoint(this) // Consider changing this to be a part of the memory handler. Remove the parameter

        this._cachedWander = () => this.StartWandering()
        this._cachedEffect = () => this.WolfMoveCancelEffect()

        this.InitializeWolf()
        this.WanderTimer.Timer.start(GetRandomReal(2.0, 4.5), false, this._cachedWander)
        Globals.ALL_WOLVES.set(this.Unit, this)

        this.WolfArea.Wolves.push(this)
    }

    /// <summary>
    /// Spawns wolves based on round and lane according to the Globals.WolvesPerRound dictionary.
    /// </summary>
    public static SpawnWolves() {
        try {
            let wolvesInRound = Globals.WolvesPerRound.get(Globals.ROUND)
            if (wolvesInRound) {
                for (const [laneStr, numberOfWolves] of Object.entries(wolvesInRound)) {
                    const lane = Number(laneStr)
                    for (let i: number = 0; i < numberOfWolves; i++) new Wolf(lane)
                }
                FandF.CreateBloodWolf()
                NamedWolves.CreateNamedWolves()
            }
        } catch (e: any) {
            Logger.Critical('Error in Wolf.SpawnWolves: {e.Message}')
            throw e
        }
    }

    public StartWandering(forced: boolean = false) {
        let realTime = GetRandomReal(1.0, 1.12)
        if ((this.ShouldStartEffect() || forced) && !this.paused && !this.IsReviving && this !== NamedWolves.StanWolf) {
            this.ApplyEffect()
            realTime = this.NEXT_WANDER_DELAY // Gives a brief delay before the wolf has a chance to move again.
        }
        this.WanderTimer?.Timer?.start(realTime, false, this._cachedWander)
    }

    /// <summary>
    /// Wolf moves to a random location within its lane.
    /// </summary>
    public WolfMove(forced: boolean = false) {
        if (this.paused || this.IsReviving) return
        if (this.HasAffix('Blitzer')) return
        if (this.paused && this.HasAffix('Bomber')) return
        this.WolfPoint.DiagonalRegionCreate(
            this.Unit.x,
            this.Unit.y,
            GetRandomReal(this.WolfArea.Rectangle.minX, this.WolfArea.Rectangle.maxX),
            GetRandomReal(this.WolfArea.Rectangle.minY, this.WolfArea.Rectangle.maxY)
        )
    }

    public dispose() {
        this.RemoveAllWolfAffixes()
        this.EffectTimer?.dispose()
        this.OverheadEffect?.destroy()
        this.WanderTimer?.dispose()
        this.Texttag?.destroy()
        this.WolfArea.Wolves.splice(this.WolfArea.Wolves.indexOf(this), 1)
        this.Disco?.dispose()
        this.WolfPoint?.dispose()
        this.Unit?.destroy()
    }

    /// <summary>
    /// Removes all wolves from the game and clears wolf list.
    /// </summary>
    public static RemoveAllWolves() {
        for (let [_, wolf] of Globals.ALL_WOLVES) {
            wolf.dispose()
        }
        Globals.ALL_WOLVES.clear()
    }

    /// <summary>
    /// Pauses or resumes all wolves in the game.
    /// </summary>
    /// <param name="pause"></param>
    public static PauseAllWolves(pause: boolean) {
        for (let [_, wolf] of Globals.ALL_WOLVES) {
            wolf.PauseSelf(pause)
        }
    }

    public static PauseSelectedWolf(selectedUnit: Unit, pause: boolean) {
        let wolf = Globals.ALL_WOLVES.get(selectedUnit)
        if (!wolf) return
        wolf.PauseSelf(pause)
    }

    public PauseSelf(pause: boolean) {
        try {
            if (pause) {
                this.WanderTimer?.pause()
                this.EffectTimer?.pause()
                for (let i: number = 0; i < this.Affixes.length; i++) {
                    this.Affixes[i].pause(true)
                }
                BlzUnitClearOrders(this.Unit.handle, false)
                this.IsWalking = false
                this.paused = true
                this.Unit.paused = true // Wander Wolf
            } else {
                for (let i: number = 0; i < this.Affixes.length; i++) {
                    this.Affixes[i].pause(false)
                }
                this.WanderTimer?.resume()
                if (this.EffectTimer !== null && this.EffectTimer.Timer.remaining > 0) this.EffectTimer.resume()
                this.IsWalking = true
                this.paused = false
                this.Unit.paused = false
            }
        } catch (e: any) {
            Logger.Warning('Error in Wolf.PauseSelf: {e.Message}')
        }
    }

    private InitializeWolf() {
        let selectedPlayer = Setup.getNextWolfPlayer()

        let randomX = GetRandomReal(this.WolfArea.Rectangle.minX, this.WolfArea.Rectangle.maxX)
        let randomY = GetRandomReal(this.WolfArea.Rectangle.minY, this.WolfArea.Rectangle.maxY)
        let facing = GetRandomReal(0, 360)

        this.Unit ??= Unit.create(selectedPlayer, Wolf.WOLF_MODEL, randomX, randomY, facing)!
        Utility.MakeUnitLocust(this.Unit)
        this.Unit.name = 'Lane: {RegionIndex + 1}'
        this.Unit.invulnerable = true
        this.Unit.color = ConvertPlayerColor(24)!

        if (Program.Debug) selectedPlayer.setAlliance(MapPlayer.fromIndex(0)!, ALLIANCE_SHARED_CONTROL, true)
    }

    private ShouldStartEffect(): boolean {
        return Gamemode.CurrentGameMode !== GameMode.Standard
            ? this.TournamentChance()
            : GetRandomInt(1, 18 - (Difficulty.DifficultyValue + Globals.ROUND)) === 1
    }

    private TournamentChance(): boolean {
        let baseChance = 14.0
        let increasePerRound = 2.0
        let maxProbability = 22.5

        let currentRound = Globals.ROUND
        if (currentRound < 1 || currentRound > 5) return false

        let linearProbability = baseChance + increasePerRound * (currentRound - 1)
        let randomAdjustment = GetRandomReal(0, 4) // Random adjustment between 0 and 4%
        let totalProbability = linearProbability + randomAdjustment

        // Cap the probability to the maximum limit
        totalProbability = Math.min(totalProbability, maxProbability)
        return GetRandomReal(0, 100) <= totalProbability
    }

    private ApplyEffect() {
        let effectDuration = GetRandomReal(this.WANDER_LOWER_BOUND, this.WANDER_UPPER_BOUND)

        this.OverheadEffect ??= Effect.createAttachment(this.OVERHEAD_EFFECT_PATH, this.Unit, 'overhead')!
        BlzPlaySpecialEffect(this.OverheadEffect.handle, ANIM_TYPE_STAND)

        this.EffectTimer ??= MemoryHandler.getEmptyObject<AchesTimers>()
        this.EffectTimer?.Timer?.start(effectDuration, false, this._cachedEffect)
    }

    private WolfMoveCancelEffect() {
        this.WolfMove()
        BlzPlaySpecialEffect(this.OverheadEffect.handle, ANIM_TYPE_DEATH)
        if (this.IsAffixed()) {
            this.OverheadEffect.destroy()
        }
    }

    // #region AFFIXES

    public AddAffix(affix: Affix) {
        this.Affixes.push(affix)
        AffixFactory.AllAffixes.push(affix)
        affix.Apply()
    }

    public RemoveAffix(affix: Affix): void
    public RemoveAffix(affixName: string): void
    public RemoveAffix(arg: Affix | string): void {
        if (typeof arg === 'string') {
            for (let i = 0; i < this.Affixes.length; i++) {
                if (this.Affixes[i].constructor.name === arg) {
                    this.RemoveAffix(this.Affixes[i])
                    break
                }
            }
        } else {
            this.Affixes.splice(this.Affixes.indexOf(arg), 1)
            arg.Remove()
            AffixFactory.AllAffixes.splice(AffixFactory.AllAffixes.indexOf(arg), 1)
        }
    }

    public HasAffix(affixName: string) {
        if (this.Affixes.length === 0) return false
        for (let i: number = 0; i < this.Affixes.length; i++)
            if (this.Affixes[i].constructor.name === affixName) return true

        return false
    }

    public RemoveAllWolfAffixes() {
        if (this.AffixCount() === 0) return

        try {
            for (let i: number = this.Affixes.length - 1; i >= 0; i--) {
                this.Affixes[i].Remove()
                AffixFactory.AllAffixes.splice(AffixFactory.AllAffixes.indexOf(this.Affixes[i]), 1)
            }
        } catch (e: any) {
            Logger.Warning('Error in RemoveAllWolfAffixes: {e.Message}')
        }

        this.Affixes = []
    }

    public IsAffixed(): boolean {
        return this.Affixes.length > 0
    }

    public AffixCount(): number {
        return this.Affixes.length
    }

    // #endregion AFFIXES
}
