import { Affix } from 'src/Affixes/Affix'
import { RemoveAllWolfAffixes } from 'src/Affixes/AffixUtil'
import { Constants } from 'src/AutoGenerated/Constants'
import { PROD } from 'src/env'
import { Logger } from 'src/Events/Logger/Logger'
import { CurrentGameMode } from 'src/Gamemodes/CurrentGameMode'
import { GameMode } from 'src/Gamemodes/GameModeEnum'
import { DEFAULT_OVERHEAD_EFFECT, Globals } from 'src/Global/Globals'
import { Difficulty } from 'src/Init/Difficulty/Difficulty'
import { Disco } from 'src/Misc/Disco'
import { FandF } from 'src/Rewards/EasterEggs/F&F/FandF'
import { Utility } from 'src/Utility/Utility'
import { Effect, MapPlayer, TextTag, Timer, Unit } from 'w3ts'
import { WolfArea } from '../WolfArea'
import { WolfPoint } from '../WolfPoint'
import { NamedWolves } from './NamedWolves'

export class Wolf {
    public static WOLF_MODEL = Constants.UNIT_CUSTOM_DOG
    public static DisableEffects = false
    private WANDER_LOWER_BOUND = 0.7 // reaction time lower bound
    private WANDER_UPPER_BOUND = 0.83 // reaction time upper bound
    private NEXT_WANDER_DELAY = 1.9 // time before wolf can move again

    private static wolfPlayerIndex = 0

    public RegionIndex = 0
    public OVERHEAD_EFFECT_PATH: string
    public WanderTimer: Timer

    public EffectTimer: Timer | undefined

    public Texttag: TextTag | undefined
    public Disco: Disco | undefined
    public WolfArea: WolfArea
    public Unit!: Unit
    public Affixes: Affix[]
    private OverheadEffect: Effect | undefined
    // private effect RandomEffect // some random cool event - can do later on (roar, stomps, whatever)
    public WolfPoint: WolfPoint
    public paused = false
    public IsReviving = false
    public IsWalking = false

    public constructor(regionIndex: number) {
        this.RegionIndex = regionIndex
        this.WolfArea = WolfArea.WolfAreas.get(regionIndex)!
        this.Affixes = [] // Consider creating a new object that contains Affix[] so we're not making a new one each wolf.
        this.OVERHEAD_EFFECT_PATH = DEFAULT_OVERHEAD_EFFECT
        this.WolfPoint = new WolfPoint(this) // Consider changing this to be a part of the memory handler. Remove the parameter

        this.InitializeWolf()
        this.WanderTimer = Timer.create()
        this.WanderTimer.start(GetRandomReal(2.0, 4.5), false, this.StartWandering)
        Globals.ALL_WOLVES.set(this.Unit, this)

        this.WolfArea.Wolves.push(this)
    }

    /// <summary>
    /// Spawns wolves based on round and lane according to the Globals.WolvesPerRound dictionary.
    /// </summary>
    public static SpawnWolves = () => {
        try {
            const wolvesInRound = Globals.WolvesPerRound.get(Globals.ROUND)
            Wolf.setWolfPlayers()
            if (wolvesInRound) {
                for (const [laneStr, numberOfWolves] of Object.entries(wolvesInRound)) {
                    const lane = Number(laneStr)
                    for (let i = 0; i < numberOfWolves; i++) new Wolf(lane)
                }
                FandF.CreateBloodWolf()
                NamedWolves.CreateNamedWolves()
            }
        } catch (e) {
            Logger.Critical(`Error in Wolf.SpawnWolves: ${e}`)
            throw e
        }
    }

    public StartWandering = (forced = false) => {
        let realTime = GetRandomReal(1.0, 1.12)
        if ((this.ShouldStartEffect() || forced) && !this.paused && !this.IsReviving && this != NamedWolves.StanWolf) {
            this.ApplyEffect()
            realTime = this.NEXT_WANDER_DELAY // Gives a brief delay before the wolf has a chance to move again.
        }
        this.WanderTimer?.start(realTime, false, this.StartWandering)
    }

    /// <summary>
    /// Wolf moves to a random location within its lane.
    /// </summary>
    public WolfMove = (forced = false) => {
        if (this.paused || this.IsReviving) return
        if (this.HasAffix('Blitzer')) return
        if (this.paused && this.HasAffix('Bomber')) return
        this.WolfPoint.DiagonalRegionCreate(
            this.Unit.x,
            this.Unit.y,
            GetRandomReal(this.WolfArea.Rectangle.minX, this.WolfArea.Rectangle.maxX),
            GetRandomReal(this.WolfArea.Rectangle.minY, this.WolfArea.Rectangle.maxY)
        )
    }

    public dispose = () => {
        RemoveAllWolfAffixes(this)
        this.EffectTimer?.destroy()
        this.OverheadEffect?.destroy()
        this.WanderTimer?.destroy()
        this.Texttag?.destroy()
        this.WolfArea.Wolves.splice(this.WolfArea.Wolves.indexOf(this), 1)
        //this.Disco?.dispose()
        this.WolfPoint?.dispose()
        this.Unit?.destroy()
    }

    /// <summary>
    /// Removes all wolves from the game and clears wolf list.
    /// </summary>
    public static RemoveAllWolves = () => {
        for (const [_, wolf] of Globals.ALL_WOLVES) {
            wolf.dispose()
        }
        Globals.ALL_WOLVES.clear()
    }

    /// <summary>
    /// Pauses or resumes all wolves in the game.
    /// </summary>
    /// <param name="pause"></param>
    public static PauseAllWolves = (pause: boolean) => {
        for (const [_, wolf] of Globals.ALL_WOLVES) {
            wolf.PauseSelf(pause)
        }
    }

    public static PauseSelectedWolf = (selectedUnit: Unit, pause: boolean) => {
        const wolf = Globals.ALL_WOLVES.get(selectedUnit)
        if (!wolf) return
        wolf.PauseSelf(pause)
    }

    public PauseSelf = (pause: boolean) => {
        try {
            if (pause) {
                this.WanderTimer?.pause()
                this.EffectTimer?.pause()
                for (let i = 0; i < this.Affixes.length; i++) {
                    this.Affixes[i].pause(true)
                }
                BlzUnitClearOrders(this.Unit.handle, false)
                this.IsWalking = false
                this.paused = true
                this.Unit.paused = true // Wander Wolf
            } else {
                if (this.Affixes.length > 1) {
                    for (let i = 0; i < this.Affixes.length; i++) {
                        //this.Affixes[i].pause(false)
                    }
                }
                this.WanderTimer?.resume()
                if (this.EffectTimer && this.EffectTimer.remaining > 0) this.EffectTimer.resume()
                this.IsWalking = true
                this.paused = false
                this.Unit.paused = false
            }
        } catch (e) {
            Logger.Warning(`Error in Wolf.PauseSelf: ${e}`)
        }
    }

    private InitializeWolf = () => {
        const selectedPlayer = Wolf.getNextWolfPlayer()

        const randomX = GetRandomReal(this.WolfArea.Rectangle.minX, this.WolfArea.Rectangle.maxX)
        const randomY = GetRandomReal(this.WolfArea.Rectangle.minY, this.WolfArea.Rectangle.maxY)
        const facing = GetRandomReal(0, 360)

        this.Unit ??= Unit.create(selectedPlayer, Wolf.WOLF_MODEL, randomX, randomY, facing)!
        Utility.MakeUnitLocust(this.Unit)
        this.Unit.name = `Lane: ${this.RegionIndex + 1}`
        this.Unit.invulnerable = true
        this.Unit.color = ConvertPlayerColor(24)!

        if (!PROD) selectedPlayer.setAlliance(MapPlayer.fromIndex(0)!, ALLIANCE_SHARED_CONTROL, true)
    }

    private ShouldStartEffect(): boolean {
        return CurrentGameMode.active !== GameMode.Standard
            ? this.TournamentChance()
            : GetRandomInt(1, 18 - (Difficulty.DifficultyValue + Globals.ROUND)) === 1
    }

    private TournamentChance(): boolean {
        const baseChance = 14.0
        const increasePerRound = 2.0
        const maxProbability = 22.5

        const currentRound = Globals.ROUND
        if (currentRound < 1 || currentRound > 5) return false

        const linearProbability = baseChance + increasePerRound * (currentRound - 1)
        const randomAdjustment = GetRandomReal(0, 4) // Random adjustment between 0 and 4%
        let totalProbability = linearProbability + randomAdjustment

        // Cap the probability to the maximum limit
        totalProbability = Math.min(totalProbability, maxProbability)
        return GetRandomReal(0, 100) <= totalProbability
    }

    private ApplyEffect = () => {
        const effectDuration = GetRandomReal(this.WANDER_LOWER_BOUND, this.WANDER_UPPER_BOUND)

        this.OverheadEffect ??= Effect.createAttachment(this.OVERHEAD_EFFECT_PATH, this.Unit, 'overhead')!
        BlzPlaySpecialEffect(this.OverheadEffect.handle, ANIM_TYPE_STAND)

        this.EffectTimer ??= Timer.create()
        this.EffectTimer?.start(effectDuration, false, this.WolfMoveCancelEffect)
    }

    private WolfMoveCancelEffect = () => {
        this.WolfMove()

        if (this.OverheadEffect) {
            BlzPlaySpecialEffect(this.OverheadEffect.handle, ANIM_TYPE_DEATH)

            if (this.IsAffixed()) {
                this.OverheadEffect.destroy()
            }
        }
    }

    public HasAffix = (affixName: string) => {
        if (this.Affixes.length === 0) return false
        for (let i = 0; i < this.Affixes.length; i++) if (this.Affixes[i].constructor.name === affixName) return true

        return false
    }

    public IsAffixed(): boolean {
        return this.Affixes.length > 0
    }

    public AffixCount(): number {
        return this.Affixes.length
    }

    private static wolfPlayers = [
        MapPlayer.fromIndex(bj_PLAYER_NEUTRAL_EXTRA)!,
        MapPlayer.fromIndex(bj_PLAYER_NEUTRAL_VICTIM)!,
        MapPlayer.fromIndex(PLAYER_NEUTRAL_AGGRESSIVE)!,
        MapPlayer.fromIndex(PLAYER_NEUTRAL_PASSIVE)!,
    ]

    public static getNextWolfPlayer(): MapPlayer {
        const selectedPlayer = Wolf.wolfPlayers[Wolf.wolfPlayerIndex]
        Wolf.wolfPlayerIndex = (Wolf.wolfPlayerIndex + 1) % Wolf.wolfPlayers.length
        return selectedPlayer
    }

    private static setWolfPlayers = () => {
        for (let i = 0; i < GetBJMaxPlayers(); i++) {
            if (MapPlayer.fromIndex(i)!.slotState !== PLAYER_SLOT_STATE_PLAYING) {
                Wolf.wolfPlayers.push(MapPlayer.fromIndex(i)!)
            }
        }
    }
}
