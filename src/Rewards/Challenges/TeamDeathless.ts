import { Constants } from 'src/AutoGenerated/Constants'
import { Logger } from 'src/Events/Logger/Logger'
import { Kitty } from 'src/Game/Entities/Kitty/Kitty'
import { Safezone } from 'src/Game/Management/Safezone'
import { CurrentGameMode } from 'src/Gamemodes/CurrentGameMode'
import { GameMode } from 'src/Gamemodes/GameModeEnum'
import { Globals } from 'src/Global/Globals'
import { RegionList } from 'src/Global/RegionList'
import { Difficulty } from 'src/Init/Difficulty/Difficulty'
import { DifficultyLevel } from 'src/Init/Difficulty/DifficultyOption'
import { Colors } from 'src/Utility/Colors/Colors'
import { ColorUtils } from 'src/Utility/Colors/ColorUtils'
import { FilterList } from 'src/Utility/FilterList'
import { Utility } from 'src/Utility/Utility'
import { getTriggerUnit } from 'src/Utility/w3tsUtils'
import { Effect, MapPlayer, Timer, Trigger, Unit } from 'w3ts'
import { AwardManager } from '../Rewards/AwardManager'
import { DeathlessChallenges } from './DeathlessChallenges'

export class TeamDeathless {
    /// <summary>
    /// The path string of the orb model used for the event.
    /// </summary>
    private static EFFECT_MODEL: string = 'war3mapImported\\OrbFireX.mdx'

    /// <summary>
    /// The path string of the ripple effect used for the event.
    /// </summary>
    private static RIPPLE_MODEL: string = 'war3mapImported\\FireNova2.mdx'

    /// <summary>
    /// Range in which the orb can be picked up from.
    /// </summary>
    private static PICKUP_RANGE = 75

    /// <summary>
    /// Chance that the orb will drop when the player dies with it. TeamDeathless is a percentage chance (0-100).
    /// </summary>
    private static ORB_DROP_CHANCE = 75 // 70% chance to reset on death

    /// <summary>
    /// Flag to check if the event has been triggered. TeamDeathless is set to true when the # of DeathlessToActivate players have achieved deathless.
    /// </summary>
    private static EventTriggered: boolean = false

    /// <summary>
    /// The Kitty object of the player who is currently holding the orb / effect.
    /// </summary>
    public static CurrentHolder: Kitty | null = null

    /// <summary>
    /// Flag to check if the event has started. TeamDeathless is set to true when the event is started.
    /// </summary>
    private static EventStarted: boolean = false
    /// <summary>
    /// The number of players that need to achieve deathless in order to activate the event.
    /// </summary>
    private static DeathlessToActivate = 4

    /// <summary>
    /// The current safezone that the orb last touched / was in.
    /// </summary>
    private static CurrentSafezone: Safezone
    /// <summary>
    /// List of players that have already carried the orb. Prevents players from picking up the orb after they've already carried it.
    /// </summary>
    private static AlreadyCarriedOrb: MapPlayer[]
    /// <summary>
    /// The primary effect (the orb) that is being moved around constantly with players / safezone location
    /// </summary>
    private static OrbEffect: Effect

    /// <summary>
    /// The timer that will be moving the effect on a specific interval of time (0.03 maybe?)
    /// </summary>
    private static timerHandle: Timer

    /// <summary>
    /// The effect object for the ripple whenever orb is picked up.
    /// </summary>
    private static RippleEffect: Effect

    /// <summary>
    /// The trigger that will be used to detect when a player is in range of the orb.
    /// </summary>
    private static RangeTrigger: Trigger

    /// <summary>
    /// The dummy unit that will be used to detect when a player is in range of the orb.
    /// </summary>
    private static DummyUnit: Unit

    /// <summary>
    /// Flag to check if the event has been won. TeamDeathless is set to true when the orb reaches the final safezone.
    /// </summary>
    private static EventWon: boolean = false

    /// <summary>
    /// TeamDeathless method should be fully executed whenever players meet the conditions to start the event.
    /// Then the next round will begin the StartEvent method.
    /// </summary>
    public static PrestartingEvent = () => {
        if (CurrentGameMode.active !== GameMode.Standard) return // Only occurs in Standard Gamemode.
        if (TeamDeathless.EventStarted || TeamDeathless.EventTriggered) return // Don't trigger multiple times.
        if (DeathlessChallenges.DeathlessCount < TeamDeathless.DeathlessToActivate) return // Not enough players have achieved deathless.
        TeamDeathless.EventTriggered = true
        TeamDeathless.AlreadyCarriedOrb = []
        TeamDeathless.timerHandle = Timer.create()
        TeamDeathless.DummyUnit = Unit.create(
            MapPlayer.fromIndex(PLAYER_NEUTRAL_AGGRESSIVE)!,
            Constants.UNIT_SPELLDUMMY,
            0,
            0,
            0
        )!
        TeamDeathless.RangeTrigger = Trigger.create()!
        TeamDeathless.RangeTrigger.registerUnitInRage(
            TeamDeathless.DummyUnit.handle,
            TeamDeathless.PICKUP_RANGE,
            FilterList.KittyFilter
        )
        TeamDeathless.RangeTrigger.addAction(() => TeamDeathless.InRangeEvent())
        TeamDeathless.RangeTrigger.enabled = false

        Utility.TimedTextToAllPlayers(
            4.0,
            `${Colors.COLOR_YELLOW}Team Deathless Event Requirements Complete! Activating next round!${Colors.COLOR_RESET}`
        )
    }

    /// <summary>
    /// TeamDeathless method is called whenever the event has been triggered and will begin on the following round.
    /// Starts the event, sets the orb in place, and puts the dummy unit to detect InRangeEvents
    /// </summary>
    public static StartEvent = () => {
        try {
            if (!TeamDeathless.EventTriggered || TeamDeathless.EventWon) return // event hasn't been triggered yet.
            TeamDeathless.EventStarted = true
            TeamDeathless.CurrentSafezone = Globals.SAFE_ZONES[0]
            TeamDeathless.RangeTrigger.enabled = true
            TeamDeathless.CurrentHolder = null
            TeamDeathless.AlreadyCarriedOrb = []

            const x: number = RegionList.SafeZones[0].centerX
            const y: number = RegionList.SafeZones[0].centerY
            TeamDeathless.OrbEffect ??= Effect.create(TeamDeathless.EFFECT_MODEL, x, y)!
            TeamDeathless.OrbEffect.scale = 1.0
            TeamDeathless.OrbEffect.x = x
            TeamDeathless.OrbEffect.y = y
            TeamDeathless.DummyUnit.setPosition(x, y)

            Utility.TimedTextToAllPlayers(
                4.0,
                `${Colors.COLOR_YELLOW}The Deathless Orb has been spawned! As a team, bring it to the end without dying!${Colors.COLOR_RESET}`
            )
        } catch (e) {
            Logger.Warning(`Error in TeamDeathless.StartEvent: ${e}`)
            throw e
        }
    }

    /// <summary>
    /// Whenever a player with the orb reaches the proper safezone, TeamDeathless method calls to set the OrbEffect to the center of the passed safezone.
    /// </summary>
    /// <param name="safezone"></param>
    public static ReachedSafezone = (unit: Unit, safezone: Safezone) => {
        if (!TeamDeathless.EventStarted) return
        if (TeamDeathless.CurrentHolder === null) return // No one holding orb.
        if (safezone.ID <= TeamDeathless.CurrentSafezone.ID) return
        if (safezone.ID > TeamDeathless.CurrentSafezone.ID + 1) return // no skipping safezones
        if (TeamDeathless.CurrentHolder.Unit !== unit) return // The unit that reached the safezone is not the current holder of the orb.
        if (!TeamDeathless.AlreadyCarriedOrb.includes(TeamDeathless.CurrentHolder.Player))
            TeamDeathless.AlreadyCarriedOrb.push(TeamDeathless.CurrentHolder.Player)

        TeamDeathless.CurrentSafezone = safezone
        TeamDeathless.CurrentHolder = null

        TeamDeathless.OrbEffect.x = safezone.Rectangle.centerX
        TeamDeathless.OrbEffect.y = safezone.Rectangle.centerY
        TeamDeathless.OrbEffect.scale = 1.0

        TeamDeathless.RangeTrigger.enabled = true
        TeamDeathless.DummyUnit.setPosition(safezone.Rectangle.centerX, safezone.Rectangle.centerY)

        TeamDeathless.timerHandle?.pause()

        if (TeamDeathless.CurrentSafezone.ID === RegionList.SafeZones.length - 1) TeamDeathless.AwardTeamDeathless()
    }

    /// <summary>
    /// Whenever a player dies with the deathless orb, TeamDeathless dictates whether the event should restart or if they got lucky to hold onto it for a bit longer.
    /// </summary>
    /// <param name="k"></param>
    public static DiedWithOrb = (k: Kitty) => {
        try {
            if (!TeamDeathless.EventStarted) return // event hasn't started yet.
            if (k.ProtectionActive) return // Player protected.
            if (TeamDeathless.CurrentHolder !== k) return

            const RandomChance: number = GetRandomReal(0, 100) // 0-100 .. If it's less than ORB_DROP_CHANCE, orb drops and is reset.
            if (RandomChance > TeamDeathless.ORB_DROP_CHANCE) return

            TeamDeathless.timerHandle?.pause()
            TeamDeathless.StartEvent()
        } catch (e) {
            Logger.Warning(`Error in TeamDeathless.DiedWithOrb: ${e}`)
        }
    }

    private static InRangeEvent = () => {
        if (TeamDeathless.CurrentHolder !== null) return

        const u = getTriggerUnit()

        TeamDeathless.CheckOrbList()
        if (TeamDeathless.AlreadyCarriedOrb.includes(u.owner)) {
            u.owner.DisplayTimedTextTo(
                6.0,
                `${Colors.COLOR_YELLOW}You've already carried the orb!${Colors.COLOR_RESET}`
            )
            return
        }
        TeamDeathless.CurrentHolder = Globals.ALL_KITTIES.get(u.owner)!

        Utility.TimedTextToAllPlayers(
            1.5,
            `${ColorUtils.PlayerNameColored(TeamDeathless.CurrentHolder.Player)} has picked up the orb!`
        )
        TeamDeathless.RippleEffect ??= Effect.create(
            TeamDeathless.RIPPLE_MODEL,
            TeamDeathless.CurrentHolder.Unit.x,
            TeamDeathless.CurrentHolder.Unit.y
        )!
        TeamDeathless.RippleEffect.setTime(0)
        TeamDeathless.RippleEffect.scale = 0.25
        TeamDeathless.RippleEffect.x = TeamDeathless.CurrentHolder.Unit.x
        TeamDeathless.RippleEffect.y = TeamDeathless.CurrentHolder.Unit.y
        TeamDeathless.RippleEffect.playAnimation(ANIM_TYPE_BIRTH)
        TeamDeathless.RangeTrigger.enabled = false

        TeamDeathless.OrbEffect.scale = 0.5
        TeamDeathless.timerHandle.start(0.03, true, TeamDeathless.OrbFollow)
    }

    private static OrbFollow = () => {
        if (TeamDeathless.CurrentHolder === null) {
            TeamDeathless.timerHandle?.pause()
            return
        }

        const x: number = TeamDeathless.CurrentHolder.Unit.x
        const y: number = TeamDeathless.CurrentHolder.Unit.y
        TeamDeathless.OrbEffect.x = x
        TeamDeathless.OrbEffect.y = y
    }

    private static CheckOrbList = () => {
        for (let i = 0; i < Globals.ALL_PLAYERS.length; i++) {
            const player = Globals.ALL_PLAYERS[i]
            if (!TeamDeathless.AlreadyCarriedOrb.includes(player)) return
        }
        print(`${Colors.COLOR_TURQUOISE}Orb List has been reset!${Colors.COLOR_RESET}`)
        TeamDeathless.AlreadyCarriedOrb = []
    }

    /// <summary>
    /// TeamDeathless method is called to award the team deathless rewards based on the difficulty level. Accounts for doing harder difficulties so that the rewards are given accordingly.
    /// </summary>
    private static AwardTeamDeathless = () => {
        TeamDeathless.EventWon = true

        if (Difficulty.DifficultyValue >= DifficultyLevel.Normal) AwardManager.GiveRewardAll('NormalTeamDeathless')

        if (Difficulty.DifficultyValue >= DifficultyLevel.Hard) AwardManager.GiveRewardAll('HardTeamDeathless')

        if (Difficulty.DifficultyValue >= DifficultyLevel.Impossible)
            AwardManager.GiveRewardAll('ImpossibleTeamDeathless')

        TeamDeathless.RangeTrigger.enabled = false
        TeamDeathless.RangeTrigger.destroy()
        TeamDeathless.OrbEffect?.destroy()
        TeamDeathless.timerHandle?.pause()
        TeamDeathless.timerHandle?.destroy()
    }
}
