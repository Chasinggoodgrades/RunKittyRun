import { Constants } from 'src/AutoGenerated/Constants'
import { Gameover } from 'src/Events/Gameover'
import { Kitty } from 'src/Game/Entities/Kitty/Kitty'
import { Gamemode } from 'src/Gamemodes/Gamemode'
import { GameMode } from 'src/Gamemodes/GameModeEnum'
import { Globals } from 'src/Global/Globals'
import { RegionList } from 'src/Global/RegionList'
import { Difficulty } from 'src/Init/Difficulty/Difficulty'
import { DifficultyLevel } from 'src/Init/Difficulty/DifficultyOption'
import { ErrorHandler } from 'src/Utility/ErrorHandler'
import { AchesTimers } from 'src/Utility/MemoryHandler/AchesTimers'
import { MemoryHandler } from 'src/Utility/MemoryHandler/MemoryHandler'
import { MapPlayer, Trigger } from 'w3ts'
import { AwardManager } from '../Rewards/AwardManager'
import { DeathlessChallenges } from './DeathlessChallenges'
import { NitroChallenges } from './NitroChallenges'

export class Challenges {
    public static DIVINITY_TENDRILS_COUNT: number = 4
    public static FREEZE_AURA_WOLF_REQUIREMENT: number = 50
    private static TURQUOISE_FIRE_DEATH_REQUIREMENT: number = 10
    private static BLUE_FIRE_DEATH_REQUIREMENT: number = 25
    private static PURPLE_FIRE_DEATH_REQUIREMENT: number = 0
    private static PINK_FIRE_SD_REQUIREMENT: number = 3.0
    private static WHITE_FIRE_DEATH_REQUIREMENT: number = 3
    private static PURPLE_LIGHTNING_SAVE_REQUIREMENT: number = 175

    public static Initialize() {
        NitroChallenges.Initialize()
        DeathlessChallenges.Initialize()
        Challenges.DoubleBackingTrigger()
    }

    public static WhiteTendrils() {
        if (Difficulty.DifficultyValue < DifficultyLevel.Impossible) return
        AwardManager.GiveRewardAll('WhiteTendrils')
    }

    public static DivinityTendrils(player: MapPlayer) {
        return AwardManager.GiveReward(player, 'DivinityTendrils')
    }

    public static NecroWindwalk() {
        if (Globals.GAME_TIMER.remaining > 1500) return // only awarded if under 25 mins.
        AwardManager.GiveRewardAll('WWNecro')
    }

    // Violet Windwalk, awarded for killing stan with something, then taking some burnt meat n and turning it in.
    public static VioletWindwalk(player: MapPlayer) {
        AwardManager.GiveReward(player, 'WWViolet')
    }

    // finished round, then run all the way back to the start.
    public static DivineWindwalk(player: MapPlayer) {
        AwardManager.GiveReward(player, 'WWDivine')
    }

    // Kibble Event, give all
    public static HuntressKitty() {
        AwardManager.GiveRewardAll('HuntressKitty')
    }

    public static PatrioticLight(kitty: Kitty) {
        if (Globals.ROUND != 5) return
        if (Difficulty.DifficultyValue < DifficultyLevel.Impossible) return
        if (Globals.GAME_TIMER.remaining > 995) return // Formally 20 mins, now 16:35 and awards to all players.
        AwardManager.GiveRewardAll('PatrioticLight')
    }

    public static ButterflyAura(player: MapPlayer) {
        if (Difficulty.DifficultyValue < DifficultyLevel.Impossible) return
        let currentDeaths = Globals.ALL_KITTIES.get(player)!.CurrentStats.RoundDeaths
        if (currentDeaths > 5) return
        AwardManager.GiveReward(player, 'ButterflyAura')
    }

    public static PurpleFire(player: MapPlayer) {
        let currentDeaths = Globals.ALL_KITTIES.get(player)!.CurrentStats.RoundDeaths
        if (Globals.ROUND != 2 || currentDeaths > Challenges.PURPLE_FIRE_DEATH_REQUIREMENT) return
        if (Difficulty.DifficultyValue < DifficultyLevel.Impossible) return
        AwardManager.GiveReward(player, 'PurpleFire')
    }

    public static BlueFire() {
        for (let player of Globals.ALL_PLAYERS) {
            let gameDeaths = Globals.ALL_KITTIES.get(player)!.CurrentStats.TotalDeaths
            if (gameDeaths >= Challenges.BLUE_FIRE_DEATH_REQUIREMENT) continue
            AwardManager.GiveReward(player, 'BlueFire')
        }
    }

    public static TurquoiseFire(player: MapPlayer) {
        let currentDeaths = Globals.ALL_KITTIES.get(player)!.CurrentStats.RoundDeaths
        if (Globals.ROUND != 5 || currentDeaths > Challenges.TURQUOISE_FIRE_DEATH_REQUIREMENT) return
        AwardManager.GiveReward(player, 'TurquoiseFire')
    }

    public static PinkFire() {
        for (let player of Globals.ALL_PLAYERS) {
            let stats = Globals.ALL_KITTIES.get(player)!.CurrentStats
            let currentSaves = stats.TotalSaves
            let currentDeaths = stats.TotalDeaths

            if (
                currentDeaths == 0
                    ? currentSaves < Challenges.PINK_FIRE_SD_REQUIREMENT
                    : currentSaves / currentDeaths < Challenges.PINK_FIRE_SD_REQUIREMENT
            )
                continue

            AwardManager.GiveReward(player, 'PinkFire')
        }
    }

    public static WhiteFire(player: MapPlayer) {
        if (NitroChallenges.GetNitroTimeRemaining() <= 0) return
        let currentDeaths = Globals.ALL_KITTIES.get(player)!.CurrentStats.RoundDeaths
        if (Globals.ROUND != 3 || currentDeaths > Challenges.WHITE_FIRE_DEATH_REQUIREMENT) return
        AwardManager.GiveReward(player, 'WhiteFire')
    }

    public static PurpleLighting(kitty: Kitty) {
        if (kitty.CurrentStats.TotalSaves < Challenges.PURPLE_LIGHTNING_SAVE_REQUIREMENT) return
        AwardManager.GiveReward(kitty.Player, 'PurpleLightning')
    }

    public static GreenLightning(player: MapPlayer) {
        let kitty = Globals.ALL_KITTIES.get(player)!
        let currentDeaths = kitty.CurrentStats.RoundDeaths
        let saveStreak = kitty.SaveData.GameStats.SaveStreak // current or overall, either is fine tbh.
        if (saveStreak < 10 || currentDeaths > 0) return
        AwardManager.GiveReward(player, 'GreenLightning')
    }

    public static FreezeAura() {
        if (!Gameover.WinGame) return
        for (let kitty in Globals.ALL_KITTIES) {
            if (kitty.Value.CurrentStats.WolfFreezeCount < Challenges.FREEZE_AURA_WOLF_REQUIREMENT) continue
            AwardManager.GiveReward(kitty.Value.Player, 'FreezeAura')
        }
    }

    /// <summary>
    /// Hard+, Nitro Round 4 and Win game.
    /// </summary>
    /// <param name="player"></param>
    public static ZandalariKitty() {
        if (Difficulty.DifficultyValue < DifficultyLevel.Hard) return
        if (!Gameover.WinGame) return
        for (let kitty in Globals.ALL_KITTIES) {
            if (!kitty.Value.CurrentStats.ObtainedNitros.includes(4)) continue
            AwardManager.GiveReward(kitty.Value.Player, 'ZandalariKitty')
        }
    }

    private static DoubleBackingTrigger() {
        if (Gamemode.CurrentGameMode != GameMode.Standard) return
        let t = Trigger.create()!
        TriggerregisterEnterRegionSimple(t, RegionList.SafeZones[0].Region)
        t.addAction(
            ErrorHandler.Wrap(() => {
                let unit = getTriggerUnit()
                let player = unit.owner
                if (!Globals.GAME_ACTIVE) return
                if (GetUnitTypeId(unit) != Constants.UNIT_KITTY) return
                if (!Globals.ALL_PLAYERS.includes(player)) return
                if (!Globals.ALL_KITTIES.get(player)!.CurrentStats.RoundFinished) return
                Challenges.DivineWindwalk(player)
            })
        )
    }
}

export class YellowLightning {
    private YELLOW_LIGHTNING_SAVE_REQUIREMENT: number = 6
    private YELLOW_LIGHTNING_TIMER: number = 3.0
    public Kitty: Kitty
    public Timer: AchesTimers
    public SaveCount: number

    public constructor(kitty: Kitty) {
        this.Kitty = kitty
        this.Timer = MemoryHandler.getEmptyObject<AchesTimers>()
    }

    public SaveIncrement() {
        if (this.Timer.Timer.remaining <= 0) this.Timer.Timer.start(this.YELLOW_LIGHTNING_TIMER, false, this.EndTimer)
        this.SaveCount++
    }

    private EndTimer() {
        if (this.SaveCount >= this.YELLOW_LIGHTNING_SAVE_REQUIREMENT && Gamemode.CurrentGameMode == GameMode.Standard) {
            AwardManager.GiveReward(this.Kitty.Player, 'YellowLightning')
        }
        this.SaveCount = 0
    }

    public dispose() {
        this.Timer.pause()
        this.Timer.dispose()
    }
}
