import { Constants } from 'src/AutoGenerated/Constants'
import { Kitty } from 'src/Game/Entities/Kitty/Kitty'
import { CurrentGameMode } from 'src/Gamemodes/CurrentGameMode'
import { GameMode } from 'src/Gamemodes/GameModeEnum'
import { Globals } from 'src/Global/Globals'
import { RegionList } from 'src/Global/RegionList'
import { Difficulty } from 'src/Init/Difficulty/Difficulty'
import { DifficultyLevel } from 'src/Init/Difficulty/DifficultyOption'
import { ErrorHandler } from 'src/Utility/ErrorHandler'
import { AchesTimers, createAchesTimer } from 'src/Utility/MemoryHandler/AchesTimers'
import { getTriggerUnit } from 'src/Utility/w3tsUtils'
import { MapPlayer, Trigger } from 'w3ts'
import { AwardManager } from '../Rewards/AwardManager'
import { DeathlessChallenges } from './DeathlessChallenges'

export class Challenges {
    public static DIVINITY_TENDRILS_COUNT = 4
    public static FREEZE_AURA_WOLF_REQUIREMENT = 50
    private static TURQUOISE_FIRE_DEATH_REQUIREMENT = 10
    private static BLUE_FIRE_DEATH_REQUIREMENT = 25
    private static PURPLE_FIRE_DEATH_REQUIREMENT = 0
    private static PINK_FIRE_SD_REQUIREMENT = 3.0
    private static PURPLE_LIGHTNING_SAVE_REQUIREMENT = 175

    public static Initialize = () => {
        DeathlessChallenges.Initialize()
        Challenges.DoubleBackingTrigger()
    }

    public static WhiteTendrils = () => {
        if (Difficulty.DifficultyValue < DifficultyLevel.Impossible) return
        AwardManager.GiveRewardAll('WhiteTendrils')
    }

    public static DivinityTendrils(player: MapPlayer) {
        return AwardManager.GiveReward(player, 'DivinityTendrils')
    }

    public static NecroWindwalk = () => {
        if (Globals.GAME_TIMER.remaining > 1500) return // only awarded if under 25 mins.
        AwardManager.GiveRewardAll('WWNecro')
    }

    // finished round, then run all the way back to the start.
    public static DivineWindwalk(player: MapPlayer) {
        AwardManager.GiveReward(player, 'WWDivine')
    }

    // Kibble Event, give all
    public static HuntressKitty = () => {
        AwardManager.GiveRewardAll('HuntressKitty')
    }

    public static PatrioticLight(kitty: Kitty) {
        if (Globals.ROUND !== 5) return
        if (Difficulty.DifficultyValue < DifficultyLevel.Impossible) return
        if (Globals.GAME_TIMER.remaining > 995) return // Formally 20 mins, now 16:35 and awards to all players.
        AwardManager.GiveRewardAll('PatrioticLight')
    }

    public static ButterflyAura(player: MapPlayer) {
        if (Difficulty.DifficultyValue < DifficultyLevel.Impossible) return
        const currentDeaths = Globals.ALL_KITTIES.get(player)!.CurrentStats.RoundDeaths
        if (currentDeaths > 5) return
        AwardManager.GiveReward(player, 'ButterflyAura')
    }

    public static PurpleFire(player: MapPlayer) {
        const currentDeaths = Globals.ALL_KITTIES.get(player)!.CurrentStats.RoundDeaths
        if (Globals.ROUND !== 2 || currentDeaths > Challenges.PURPLE_FIRE_DEATH_REQUIREMENT) return
        if (Difficulty.DifficultyValue < DifficultyLevel.Impossible) return
        AwardManager.GiveReward(player, 'PurpleFire')
    }

    public static BlueFire = () => {
        for (const player of Globals.ALL_PLAYERS) {
            const gameDeaths = Globals.ALL_KITTIES.get(player)!.CurrentStats.TotalDeaths
            if (gameDeaths >= Challenges.BLUE_FIRE_DEATH_REQUIREMENT) continue
            AwardManager.GiveReward(player, 'BlueFire')
        }
    }

    public static TurquoiseFire(player: MapPlayer) {
        const currentDeaths = Globals.ALL_KITTIES.get(player)!.CurrentStats.RoundDeaths
        if (Globals.ROUND !== 5 || currentDeaths > Challenges.TURQUOISE_FIRE_DEATH_REQUIREMENT) return
        AwardManager.GiveReward(player, 'TurquoiseFire')
    }

    public static PinkFire = () => {
        for (const player of Globals.ALL_PLAYERS) {
            const stats = Globals.ALL_KITTIES.get(player)!.CurrentStats
            const currentSaves = stats.TotalSaves
            const currentDeaths = stats.TotalDeaths

            if (
                currentDeaths === 0
                    ? currentSaves < Challenges.PINK_FIRE_SD_REQUIREMENT
                    : currentSaves / currentDeaths < Challenges.PINK_FIRE_SD_REQUIREMENT
            )
                continue

            AwardManager.GiveReward(player, 'PinkFire')
        }
    }

    public static PurpleLighting(kitty: Kitty) {
        if (kitty.CurrentStats.TotalSaves < Challenges.PURPLE_LIGHTNING_SAVE_REQUIREMENT) return
        AwardManager.GiveReward(kitty.Player, 'PurpleLightning')
    }

    public static GreenLightning(player: MapPlayer) {
        const kitty = Globals.ALL_KITTIES.get(player)!
        const currentDeaths = kitty.CurrentStats.RoundDeaths
        const saveStreak = kitty.SaveData.GameStats.SaveStreak // current or overall, either is fine tbh.
        if (saveStreak < 10 || currentDeaths > 0) return
        AwardManager.GiveReward(player, 'GreenLightning')
    }

    public static FreezeAura = () => {
        if (!Globals.WinGame) return
        for (const [_, kitty] of Globals.ALL_KITTIES) {
            if (kitty.CurrentStats.WolfFreezeCount < Challenges.FREEZE_AURA_WOLF_REQUIREMENT) continue
            AwardManager.GiveReward(kitty.Player, 'FreezeAura')
        }
    }

    /// <summary>
    /// Hard+, Nitro Round 4 and Win game.
    /// </summary>
    /// <param name="player"></param>
    public static ZandalariKitty = () => {
        if (Difficulty.DifficultyValue < DifficultyLevel.Hard) return
        if (!Globals.WinGame) return
        for (const [_, kitty] of Globals.ALL_KITTIES) {
            if (!kitty.CurrentStats.ObtainedNitros.includes(4)) continue
            AwardManager.GiveReward(kitty.Player, 'ZandalariKitty')
        }
    }

    private static DoubleBackingTrigger = () => {
        if (CurrentGameMode.active !== GameMode.Standard) return
        const t = Trigger.create()!
        t.registerEnterRegion(RegionList.SafeZones[0].region(), () => true)
        t.addAction(
            ErrorHandler.Wrap(() => {
                const unit = getTriggerUnit()
                const player = unit.owner
                if (!Globals.GAME_ACTIVE) return
                if (unit.typeId !== Constants.UNIT_KITTY) return
                if (!Globals.ALL_PLAYERS.includes(player)) return
                if (!Globals.ALL_KITTIES.get(player)!.CurrentStats.RoundFinished) return
                Challenges.DivineWindwalk(player)
            })
        )
    }
}

export class YellowLightning {
    private YELLOW_LIGHTNING_SAVE_REQUIREMENT = 6
    private YELLOW_LIGHTNING_TIMER = 3.0
    public Kitty: Kitty
    public Timer: AchesTimers
    public SaveCount = 0

    public constructor(kitty: Kitty) {
        this.Kitty = kitty
        this.Timer = createAchesTimer()
    }

    public SaveIncrement = () => {
        if (this.Timer.Timer.remaining <= 0) this.Timer.Timer.start(this.YELLOW_LIGHTNING_TIMER, false, this.EndTimer)
        this.SaveCount++
    }

    private EndTimer = () => {
        if (this.SaveCount >= this.YELLOW_LIGHTNING_SAVE_REQUIREMENT && CurrentGameMode.active === GameMode.Standard) {
            AwardManager.GiveReward(this.Kitty.Player, 'YellowLightning')
        }
        this.SaveCount = 0
    }

    public dispose = () => {
        this.Timer.pause()
        this.Timer.dispose()
    }
}
