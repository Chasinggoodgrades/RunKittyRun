import { Constants } from 'src/AutoGenerated/Constants'
import { Logger } from 'src/Events/Logger/Logger'
import { Kitty } from 'src/Game/Entities/Kitty/Kitty'
import { Globals } from 'src/Global/Globals'
import { MapPlayer, Unit } from 'w3ts'
import { isNullOrEmpty } from '../StringUtils'
import { Colors } from './Colors'

export class ColorData {
    public colorname: string
    public colorID: number
    public colorcode: string
    public playercolor: playercolor
    public red: number
    public green: number
    public blue: number

    constructor(
        colorname: string,
        colorID: number,
        colorcode: string,
        playercolor: playercolor,
        red: number,
        green: number,
        blue: number
    ) {
        this.colorname = colorname
        this.colorID = colorID
        this.colorcode = colorcode
        this.playercolor = playercolor
        this.red = red
        this.green = green
        this.blue = blue
    }
}

export class ColorUtils {
    public static ColorManager: ColorData[] = []
    public static sb: string = ''

    public static AddColor(
        colorname: string,
        colorID: number,
        colorcode: string,
        playercolor: playercolor,
        redValue: number,
        greenValue: number,
        blueValue: number
    ) {
        ColorUtils.ColorManager.push(
            new ColorData(colorname, colorID, colorcode, playercolor, redValue, greenValue, blueValue)
        )
    }

    public static Initialize() {
        ColorUtils.AddColor('red', 1, '|cffff0303', PLAYER_COLOR_RED, 255, 3, 3)
        ColorUtils.AddColor('blue', 2, '|cff0042f', PLAYER_COLOR_BLUE, 0, 66, 255)
        ColorUtils.AddColor('teal', 3, '|cff1be7ba', PLAYER_COLOR_CYAN, 27, 231, 186)
        ColorUtils.AddColor('purple', 4, '|cff550081', PLAYER_COLOR_PURPLE, 85, 0, 129)
        ColorUtils.AddColor('yellow', 5, '|cfffefc00', PLAYER_COLOR_YELLOW, 254, 252, 0)
        ColorUtils.AddColor('orange', 6, '|cfffe890d', PLAYER_COLOR_ORANGE, 254, 137, 13)
        ColorUtils.AddColor('green', 7, '|cff21bf00', PLAYER_COLOR_GREEN, 33, 191, 0)
        ColorUtils.AddColor('pink', 8, '|cffe45caf', PLAYER_COLOR_PINK, 228, 92, 175)
        ColorUtils.AddColor('gray', 9, '|cff939596', PLAYER_COLOR_LIGHT_GRAY, 147, 149, 150)
        ColorUtils.AddColor('lightblue,lb,light-blue', 10, '|cff7ebff1', PLAYER_COLOR_LIGHT_BLUE, 126, 191, 241)
        ColorUtils.AddColor('darkgreen,dg,dark-green', 11, '|cff106247', PLAYER_COLOR_EMERALD, 16, 98, 71)
        ColorUtils.AddColor('brown', 12, '|cff42b05', PLAYER_COLOR_BROWN, 79, 43, 5)
        ColorUtils.AddColor('maroon', 13, '|cff9c0000', PLAYER_COLOR_MAROON, 156, 0, 0)
        ColorUtils.AddColor('navy', 14, '|cff0000c3', PLAYER_COLOR_NAVY, 0, 0, 195)
        ColorUtils.AddColor('turquoise', 15, '|cff00ebff', PLAYER_COLOR_TURQUOISE, 0, 235, 255)
        ColorUtils.AddColor('violet', 16, '|cffbd00f', PLAYER_COLOR_VIOLET, 189, 0, 255)
        ColorUtils.AddColor('wheat', 17, '|cffecce87', PLAYER_COLOR_WHEAT, 236, 206, 135)
        ColorUtils.AddColor('peach', 18, '|cfff7a58b', PLAYER_COLOR_PEACH, 247, 165, 139)
        ColorUtils.AddColor('mint', 19, '|cffbfff81', PLAYER_COLOR_MINT, 191, 255, 129)
        ColorUtils.AddColor('lavender', 20, '|cffdbb8eb', PLAYER_COLOR_LAVENDER, 219, 184, 235)
        ColorUtils.AddColor('coal', 21, '|cff45055', PLAYER_COLOR_COAL, 79, 80, 85)
        ColorUtils.AddColor('snow,white', 22, '|cffecf0f', PLAYER_COLOR_SNOW, 236, 240, 255)
        ColorUtils.AddColor('emerald', 23, '|cff00781e', PLAYER_COLOR_EMERALD, 0, 120, 30)
        ColorUtils.AddColor('peanut', 24, '|cffa5634', PLAYER_COLOR_PEANUT, 165, 111, 52)
    }

    /// <summary>
    /// Colorizes a player's name based on their player ID.
    /// </summary>
    public static PlayerNameColored(p: MapPlayer) {
        return ColorUtils.GetStringColorOfPlayer(p.id + 1) + p.name + Colors.COLOR_RESET
    }

    /// <summary>
    /// Colorizes a string based on integer value of player color ID.
    /// Use (1-24) for player ColorUtils.
    /// </summary>
    public static ColorString(text: string, playerColorID: number) {
        return ColorUtils.GetStringColorOfPlayer(playerColorID) + text + Colors.COLOR_RESET
    }

    /// <summary>
    /// Returns the color code string for that particular color.
    /// Use (1-24) for player ColorUtils. So.. (player.id + 1)
    /// </summary>
    public static GetStringColorOfPlayer(playerColorID: number) {
        for (let i: number = 0; i < ColorUtils.ColorManager.length; i++) {
            let color: ColorData = ColorUtils.ColorManager[i]
            if (color.colorID === playerColorID) {
                return color.colorcode
            }
        }
        return '|cffffffff'
    }

    public static SetPlayerColor(p: MapPlayer, color: string) {
        let kitty: Kitty = Globals.ALL_KITTIES.get(p)!
        for (let c of ColorUtils.ColorManager) {
            if (ColorUtils.ColorContainsCommand(c, color)) {
                kitty.Unit.color = ConvertPlayerColor(c.colorID - 1)!
                kitty.SaveData.PlayerColorData.LastPlayedColor = c.colorname.split(',')[0]
            }
        }
    }

    public static SetColorJoinedAs(p: MapPlayer) {
        let kitty: Kitty = Globals.ALL_KITTIES.get(p)!
        let color = ColorUtils.ColorManager[p.id]
        kitty.SaveData.PlayerColorData.LastPlayedColor = color.colorname.split(',')[0]
    }

    public static SetPlayerVertexColor(p: MapPlayer, RGB: string[]) {
        let kitty: Kitty = Globals.ALL_KITTIES.get(p)!
        let r: number = 0,
            g = 0,
            b = 0

        if (RGB.length > 0) r = S2I(RGB[0])
        if (RGB.length > 1) g = S2I(RGB[1])
        if (RGB.length > 2) b = S2I(RGB[2])

        kitty.Unit.setVertexColor(r, g, b, 255)
        Globals.ALL_KITTIES.get(p)!.SaveData.PlayerColorData.VortexColor = `${r},${g},${b}`
    }

    /// <summary>
    /// Sets a player's vertex color to a random RGB value.
    /// </summary>
    /// <param name="p">The player object</param>
    public static SetPlayerRandomVertexColor(p: MapPlayer) {
        let kitty: Kitty = Globals.ALL_KITTIES.get(p)!
        let r: number = GetRandomInt(0, 255)
        let g: number = GetRandomInt(0, 255)
        let b: number = GetRandomInt(0, 255)
        kitty.Unit.setVertexColor(r, g, b, 255)
        p.DisplayTimedTextTo(
            5.0,
            `${Colors.COLOR_RED}Red: ${Colors.COLOR_RESET}${r}, ${Colors.COLOR_GREEN}Green: ${Colors.COLOR_RESET}${g}, ${Colors.COLOR_BLUE}Blue: ${Colors.COLOR_RESET}${b}`
        )
    }

    private static ColorContainsCommand(color: ColorData, inputColor: string) {
        let colorCommands = color.colorname.split(',')
        for (let command of colorCommands) if (command === inputColor) return true
        return false
    }

    /// <summary>
    /// Highlights a string with yellow color.
    /// </summary>
    /// <param name="text"></param>
    /// <returns></returns>
    public static HighlightString(text: string) {
        return text !== null && text.length > 0
            ? Colors.COLOR_YELLOW + text + Colors.COLOR_RESET
            : `${Colors.COLOR_RED}ERROR${Colors.COLOR_RESET}`
    }

    /// <summary>
    /// Sets the unit's vertex color based on the passed parameter playerID...
    /// </summary>
    /// <param name="unit"></param>
    /// <param name="playerID"></param>
    public static SetUnitToVertexColor(unit: Unit, playerID: number) {
        let color: ColorData = ColorUtils.ColorManager[playerID]
        unit.setVertexColor(color.red, color.green, color.blue, 255)
        if (unit.typeId === Constants.UNIT_CUSTOM_DOG) return
        Globals.ALL_KITTIES.get(unit.owner)!.SaveData.PlayerColorData.VortexColor =
            `${color.red},${color.green},${color.blue}`
    }

    public static ListColorCommands(player: MapPlayer) {
        ColorUtils.sb = ''
        for (let color of ColorUtils.ColorManager) ColorUtils.sb += `${color.colorcode}${color.colorname}|r, `

        player.DisplayTimedTextTo(10.0, ColorUtils.sb)
    }

    public static GetPlayerByColor(colorName: string): MapPlayer | undefined {
        for (let color of ColorUtils.ColorManager) {
            if (ColorUtils.ColorContainsCommand(color, colorName.toLowerCase())) {
                return MapPlayer.fromIndex(color.colorID - 1)!
            }
        }
        return undefined
    }

    public static PopulateColorsData(kitty: Kitty) {
        try {
            let colorData: string = kitty.SaveData.PlayerColorData.PlayedColors
            if (!isNullOrEmpty(colorData)) return // already populated
            ColorUtils.sb = ''

            for (
                let i: number = 0;
                i < ColorUtils.ColorManager.length;
                i++ // else populate it
            ) {
                let colorName = ColorUtils.ColorManager[i].colorname.split(',')
                ColorUtils.sb += colorName[0] + ':0'
                if (i < ColorUtils.ColorManager.length - 1) ColorUtils.sb += ','
            }

            kitty.SaveData.PlayerColorData.PlayedColors = ColorUtils.sb
        } catch (e: any) {
            Logger.Warning(`Error in PopulateColorsData: ${e.message}`)
        }
    }

    /// <summary>
    /// This function only calls at the end of the game for SaveData purposes. So it should be okay to run and update all player colors accordingly.
    /// </summary>
    /// <param name="kitty"></param>
    public static UpdateColors(kitty: Kitty) {
        try {
            let colorData: string = kitty.SaveData.PlayerColorData.PlayedColors
            let currentColor: string = kitty.SaveData.PlayerColorData.LastPlayedColor

            if (isNullOrEmpty(colorData) || isNullOrEmpty(currentColor)) return

            ColorUtils.sb = ''
            let pairs = colorData.split(',')

            for (let i = 0; i < pairs.length; i++) {
                const parts = pairs[i].split(':')

                if (parts.length === 2) {
                    let count = parseInt(parts[1], 10)

                    if (!isNaN(count)) {
                        if (parts[0] === currentColor) {
                            count++
                        }

                        ColorUtils.sb += `${parts[0]}:${count},`
                    }
                }
            }

            if (ColorUtils.sb.length > 0) {
                ColorUtils.sb = ColorUtils.sb.slice(0, -1)
            }

            kitty.SaveData.PlayerColorData.PlayedColors = ColorUtils.sb
        } catch (e: any) {
            Logger.Warning(`Error in UpdateColors: ${e.message}`)
        }
    }

    /// <summary>
    /// Returns the string of the most played color and also updates the PlayerColorData.MostPlayedColor to that color.
    /// </summary>
    /// <param name="kitty"></param>
    /// <returns></returns>
    public static GetMostPlayedColor(kitty: Kitty) {
        let colorData: string = kitty.SaveData.PlayerColorData.PlayedColors
        if (isNullOrEmpty(colorData)) return null

        const pairs: string[] = colorData.split(',') // splits like .. "red:5", "blue:6", etc.
        const names: string[] = colorData.split(':') // splits like .. "red", "5", "blue", "6", etc.

        let mostPlayedColor: string | null = null
        let maxCount = 0

        for (let i = 0; i < pairs.length; i++) {
            const pair = pairs[i]
            const parts = pair.split(':')

            if (parts.length === 2) {
                const count = parseInt(parts[1], 10)

                if (!isNaN(count) && count > maxCount) {
                    mostPlayedColor = parts[0]
                    maxCount = count
                }
            }
        }

        // Set the save data to the most played color
        kitty.SaveData.PlayerColorData.MostPlayedColor = mostPlayedColor || ''

        return mostPlayedColor
    }
}
