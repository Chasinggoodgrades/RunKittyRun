using System;
using System.Configuration;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;
using CSharpLua;
using Microsoft.CodeAnalysis;
using War3Net.Build;
using War3Net.Build.Extensions;
using War3Net.IO.Mpq;
using WCSharp.ConstantGenerator;
using System.Text.RegularExpressions;

namespace Launcher
{
	internal static class Program
	{
		// Input
		private const string SOURCE_CODE_PROJECT_FOLDER_PATH = @"..\..\..\..\Source";
		private const string AUTO_GENERATED_FOLDER_PATH = @"..\..\..\..\Source\AutoGenerated";
		private const string BASE_MAP_PATH = @"..\..\..\..\source.w3x";

		// Output
		private const string OUTPUT_FOLDER_PATH = @"..\..\..\..\artifacts";
		private const string OUTPUT_SCRIPT_NAME = @"war3map.lua";
		private const string OUTPUT_MAP_NAME = @"target.w3x";

		// Warcraft III
		private const string GRAPHICS_API = "Direct3D9";
		private const bool PAUSE_GAME_ON_LOSE_FOCUS = false;
#if DEBUG
		private const bool DEBUG = true;
#else
		private const bool DEBUG = false;
#endif

		private static void Main()
		{
			Console.WriteLine("The following actions are available:");
			Console.WriteLine("1. Generate constants");
			Console.WriteLine("2. Compile map");
			Console.WriteLine("3. Compile and run map");
			Console.WriteLine("4. Compile and run map and track memory usage");
			MakeDecision();
		}

		private static void MakeDecision()
		{
			Console.Write("Please type the number of your desired action: ");
			switch (Console.ReadKey().Key)
			{
				case ConsoleKey.D1:
					ConstantGenerator.Run(BASE_MAP_PATH, AUTO_GENERATED_FOLDER_PATH, new ConstantGeneratorOptions
					{
						IncludeCode = false
					});
					break;
				case ConsoleKey.D2:
					Build(false);
					break;
				case ConsoleKey.D3:
					Build(true);
					break;
				case ConsoleKey.D4:
					Build(true, true);
					break;
				default:
					Console.WriteLine($"{Environment.NewLine}Invalid input. Please choose again.");
					MakeDecision();
					break;
			}
		}

		public static void Build(bool launch, bool mem = false)
		{
			// Ensure these folders exist
			Directory.CreateDirectory(OUTPUT_FOLDER_PATH);

			// Load existing map data
			var map = Map.Open(BASE_MAP_PATH);
			var builder = new MapBuilder(map);
			builder.AddFiles(BASE_MAP_PATH, "*", SearchOption.AllDirectories);

			// Set debug options if necessary, configure compiler
			var csc = DEBUG ? "-debug -define:DEBUG" : null;
			var csproj = Directory.EnumerateFiles(SOURCE_CODE_PROJECT_FOLDER_PATH, "*.csproj", SearchOption.TopDirectoryOnly).Single();
			var compiler = new Compiler(csproj, OUTPUT_FOLDER_PATH, string.Empty, null, "War3Api.*;WCSharp.*", "", csc, false, null, string.Empty)
			{
				IsExportMetadata = true,
				IsModule = false,
				IsInlineSimpleProperty = false,
				IsPreventDebugObject = true,
				IsCommentsDisabled = !DEBUG,
			};

			// Collect required paths and compile
			var coreSystemFiles = CSharpLua.CoreSystem.CoreSystemProvider.GetCoreSystemFiles()
				.Where(x => !x.EndsWith("Common.lua"))
				.Concat(new[] { "CoreSystem/WCSharp.lua", "PriorityQueue.lua", "SortedDictionary.lua", "SortedList.lua" });
			var blizzardJ = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments), "Warcraft III/JassHelper/Blizzard.j");
			var commonJ = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments), "Warcraft III/JassHelper/common.j");
			var compileResult = map.CompileScript(compiler, coreSystemFiles, blizzardJ, commonJ);

			// If compilation failed, output an error
			if (!compileResult.Success)
			{
				throw new Exception(compileResult.Diagnostics.First(x => x.Severity == DiagnosticSeverity.Error).GetMessage());
			}

			if (mem)
			{
				map.Script = LuaScriptProcessor.ProcessLuaScript(map.Script);
			}

			// Update war3map.lua so you can inspect the generated Lua code easily
			File.WriteAllText(Path.Combine(OUTPUT_FOLDER_PATH, OUTPUT_SCRIPT_NAME), map.Script);

			// Build w3x file
			var archiveCreateOptions = new MpqArchiveCreateOptions
			{
				ListFileCreateMode = MpqFileCreateMode.Overwrite,
				AttributesCreateMode = MpqFileCreateMode.Prune,
				BlockSize = 3,
			};

			builder.Build(Path.Combine(OUTPUT_FOLDER_PATH, OUTPUT_MAP_NAME), archiveCreateOptions);

			// Launch if that option was selected
			if (launch)
			{
				var wc3exe = ConfigurationManager.AppSettings["wc3exe"];
				if (File.Exists(wc3exe))
				{
					var commandLineArgs = new StringBuilder();
					var isReforged = Version.Parse(FileVersionInfo.GetVersionInfo(wc3exe).FileVersion) >= new Version(1, 32);
					if (isReforged)
					{
						commandLineArgs.Append(" -launch");
					}
					else if (GRAPHICS_API != null)
					{
						commandLineArgs.Append($" -graphicsapi {GRAPHICS_API}");
					}

					if (!PAUSE_GAME_ON_LOSE_FOCUS)
					{
						commandLineArgs.Append(" -nowfpause");
					}

					var mapPath = Path.Combine(OUTPUT_FOLDER_PATH, OUTPUT_MAP_NAME);
					var absoluteMapPath = new FileInfo(mapPath).FullName;
					commandLineArgs.Append($" -loadfile \"{absoluteMapPath}\"");

					Process.Start(wc3exe, commandLineArgs.ToString());
				}
				else
				{
					throw new Exception("Please set wc3exe in Launcher/app.config to the path of your Warcraft III executable.");
				}
			}
		}
	}
}

public static class LuaScriptProcessor
{
	public static string ProcessLuaScript(string script)
	{
		int counter = 0;
		string objPrefix = "info.GetStackTrace() .. ' > ' .. "; // "info.GetStackTrace() .. ' > ' .. "

		// Replace MemoryHandler.getEmptyObject()
		script = Regex.Replace(
			script,
			"MemoryHandler\\.getEmptyObject\\(\\)",
			m => $"MemoryHandler.getEmptyObject({objPrefix}'obj.{counter++}')",
			RegexOptions.Multiline | RegexOptions.IgnoreCase);

		// Replace MemoryHandler.getEmptyArray()
		script = Regex.Replace(
			script,
			"MemoryHandler\\.getEmptyArray\\(\\)",
			m => $"MemoryHandler.getEmptyArray({objPrefix}'arr.{counter++}')",
			RegexOptions.Multiline | RegexOptions.IgnoreCase);

		// Replace occurrences of an object literal initialization to insert a print statement.
		script = Regex.Replace(
			script,
			"(=|return|,)\\s+\\{",
			m => $"{m.Groups[1].Value} __fakePrint({objPrefix}'Object #{counter++}') or {{",
			RegexOptions.Multiline | RegexOptions.IgnoreCase);

		// Replace occurrences where an object literal is immediately wrapped in parentheses.
		script = Regex.Replace(
			script,
			"\\(\\{",
			m => $"(__fakePrint({objPrefix}'Object #{counter++}') or {{",
			RegexOptions.Multiline | RegexOptions.IgnoreCase);

		// Replace occurrences of function expressions to insert a print statement.
		script = Regex.Replace(
			script,
			"(=|return|,)\\s+function\\(",
			m => $"{m.Groups[1].Value} __fakePrint({objPrefix}'Function #{counter++}') or function(",
			RegexOptions.Multiline | RegexOptions.IgnoreCase);

		// Insert a print for local function declarations. -- Doesn't work??
		script = Regex.Replace(
			script,
			"^(\\s+)?local function",
			m => $"__fakePrint({objPrefix}'Function #{counter++}')\nlocal function",
			RegexOptions.Multiline | RegexOptions.IgnoreCase);

		// Define the fakePrint Lua code block to prepend.
		string fakePrint = @"_G['__fakePrintMap'] = {}

function __fakePrint(s)
    if _G['trackPrintMap'] then
        if (not _G['__fakePrintMap'][s]) then
            _G['__fakePrintMap'][s] = 0
        end

        _G['__fakePrintMap'][s] = _G['__fakePrintMap'][s] + 1
    end

    if _G['printCreation'] then
	    print(s)
    end
end";

		script = script.Replace("class._G:set(\"trackPrintMap\", true)", "_G['trackPrintMap'] = true");
		script = script.Replace("class._G:get(\"__fakePrintMap\")", "_G['__fakePrintMap']");

		script = script.Replace("-- {{ LUA_REPLACE }}", @"-- Create an empty array to store targets
    local sortedTargets = {}
    
    -- Convert each key/value pair from the targets table into a target object
    for debugName, count in pairs(_G['__fakePrintMap']) do
        table.insert(sortedTargets, { debugName = debugName, count = count })
    end

    -- If there is at least one target, proceed
    if #sortedTargets > 0 then
        -- Sort the targets in descending order by count
        table.sort(sortedTargets, function(a, b)
            return a.count > b.count
        end)

        -- Build the string for the top 10 targets
        local d = ''
        for i = 1, math.min(10, #sortedTargets) do
            local target = sortedTargets[i]
            if #d > 0 then
                d = d .. ', '
            end
            d = d .. tostring(target.debugName) .. ': ' .. tostring(target.count)
        end

        -- Print the output
        print('Most used ' .. title .. ': ' .. d)
    end");

		string lualib_info = @"info = {}

info.GetStackTrace = function()
    local trace, lastMsg, i, separator = '', '', 5, ' > '
    local store = function(msg) lastMsg = msg:sub(1,-3) end
    xpcall(error, store, '', 4)
    while lastMsg:sub(1,11) == 'war3map.lua' or lastMsg:sub(1,14) == 'blizzard.j.lua' do
        if lastMsg:sub(1,11) == 'war3map.lua' then
            trace = separator .. lastMsg:sub(13) .. trace
        else
            trace = separator .. lastMsg .. trace
        end
        xpcall(error, store, '', i)
        i = i+1
    end
    return 'T' .. trace
end";

		// Prepend the fakePrint code to the modified script.
		return lualib_info + "\n\n" + fakePrint + "\n\n" + script;
	}
}
